// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: predictor.proto

package dlframework

import proto "github.com/gogo/protobuf/proto"
import golang_proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/gogo/protobuf/gogoproto"

import descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
import gzip "compress/gzip"
import bytes "bytes"
import ioutil "io/ioutil"

import strings "strings"
import reflect "reflect"
import sortkeys "github.com/gogo/protobuf/sortkeys"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ExecutionOptions_TraceLevel int32

const (
	ExecutionOptions_NO_TRACE        ExecutionOptions_TraceLevel = 0
	ExecutionOptions_STEP_TRACE      ExecutionOptions_TraceLevel = 1
	ExecutionOptions_FRAMEWORK_TRACE ExecutionOptions_TraceLevel = 2
	ExecutionOptions_CPU_ONLY_TRACE  ExecutionOptions_TraceLevel = 3
	ExecutionOptions_HARDWARE_TRACE  ExecutionOptions_TraceLevel = 4
	ExecutionOptions_FULL_TRACE      ExecutionOptions_TraceLevel = 5
)

var ExecutionOptions_TraceLevel_name = map[int32]string{
	0: "NO_TRACE",
	1: "STEP_TRACE",
	2: "FRAMEWORK_TRACE",
	3: "CPU_ONLY_TRACE",
	4: "HARDWARE_TRACE",
	5: "FULL_TRACE",
}
var ExecutionOptions_TraceLevel_value = map[string]int32{
	"NO_TRACE":        0,
	"STEP_TRACE":      1,
	"FRAMEWORK_TRACE": 2,
	"CPU_ONLY_TRACE":  3,
	"HARDWARE_TRACE":  4,
	"FULL_TRACE":      5,
}

func (x ExecutionOptions_TraceLevel) String() string {
	return proto.EnumName(ExecutionOptions_TraceLevel_name, int32(x))
}
func (ExecutionOptions_TraceLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorPredictor, []int{2, 0}
}

type CPUOptions struct {
}

func (m *CPUOptions) Reset()                    { *m = CPUOptions{} }
func (*CPUOptions) ProtoMessage()               {}
func (*CPUOptions) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{0} }

type GPUOptions struct {
	// A value between 0 and 1 that indicates what fraction of the
	// available GPU memory to pre-allocate for each process.  1 means
	// to pre-allocate all of the GPU memory, 0.5 means the process
	// allocates ~50% of the available GPU memory.
	PerProcessGpuMemoryFraction float64 `protobuf:"fixed64,1,opt,name=per_process_gpu_memory_fraction,json=perProcessGpuMemoryFraction,proto3" json:"per_process_gpu_memory_fraction,omitempty" yaml:"per_process_gpu_memory_fraction,omitempty"`
	// The type of GPU allocation strategy to use.
	//
	// Allowed values:
	// "": The empty string (default) uses a system-chosen default
	//     which may change over time.
	//
	// "BFC": A "Best-fit with coalescing" algorithm, simplified from a
	//        version of dlmalloc.
	AllocatorType string `protobuf:"bytes,2,opt,name=allocator_type,json=allocatorType,proto3" json:"allocator_type,omitempty" yaml:"allocator_type,omitempty"`
	// A comma-separated list of GPU ids that determines the 'visible'
	// to 'virtual' mapping of GPU devices.  For example, if TensorFlow
	// can see 8 GPU devices in the process, and one wanted to map
	// visible GPU devices 5 and 3 as "/device:GPU:0", and "/device:GPU:1", then
	// one would specify this field as "5,3".  This field is similar in spirit to
	// the CUDA_VISIBLE_DEVICES environment variable, except it applies to the
	// visible GPU devices in the process.
	//
	// NOTE: The GPU driver provides the process with the visible GPUs
	// in an order which is not guaranteed to have any correlation to
	// the *physical* GPU id in the machine.  This field is used for
	// remapping "visible" to "virtual", which means this operates only
	// after the process starts.  Users are required to use vendor
	// specific mechanisms (e.g., CUDA_VISIBLE_DEVICES) to control the
	// physical to visible device mapping prior to invoking TensorFlow.
	VisibleDeviceList string `protobuf:"bytes,5,opt,name=visible_device_list,json=visibleDeviceList,proto3" json:"visible_device_list,omitempty" yaml:"visible_device_list,omitempty"`
	// Force all tensors to be gpu_compatible. On a GPU-enabled TensorFlow,
	// enabling this option forces all CPU tensors to be allocated with Cuda
	// pinned memory. Normally, TensorFlow will infer which tensors should be
	// allocated as the pinned memory. But in case where the inference is
	// incomplete, this option can significantly speed up the cross-device memory
	// copy performance as long as it fits the memory.
	// Note that this option is not something that should be
	// enabled by default for unknown or very large models, since all Cuda pinned
	// memory is unpageable, having too much pinned memory might negatively impact
	// the overall host system performance.
	ForceGpuCompatible bool `protobuf:"varint,8,opt,name=force_gpu_compatible,json=forceGpuCompatible,proto3" json:"force_gpu_compatible,omitempty" yaml:"force_gpu_compatible,omitempty"`
}

func (m *GPUOptions) Reset()                    { *m = GPUOptions{} }
func (*GPUOptions) ProtoMessage()               {}
func (*GPUOptions) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{1} }

func (m *GPUOptions) GetPerProcessGpuMemoryFraction() float64 {
	if m != nil {
		return m.PerProcessGpuMemoryFraction
	}
	return 0
}

func (m *GPUOptions) GetAllocatorType() string {
	if m != nil {
		return m.AllocatorType
	}
	return ""
}

func (m *GPUOptions) GetVisibleDeviceList() string {
	if m != nil {
		return m.VisibleDeviceList
	}
	return ""
}

func (m *GPUOptions) GetForceGpuCompatible() bool {
	if m != nil {
		return m.ForceGpuCompatible
	}
	return false
}

type ExecutionOptions struct {
	TraceLevel ExecutionOptions_TraceLevel `protobuf:"varint,1,opt,name=trace_level,json=traceLevel,proto3,enum=carml.org.dlframework.ExecutionOptions_TraceLevel" json:"trace_level,omitempty" yaml:"trace_level,omitempty"`
	// Time to wait for operation to complete in milliseconds.
	TimeoutInMs int64 `protobuf:"varint,2,opt,name=timeout_in_ms,json=timeoutInMs,proto3" json:"timeout_in_ms,omitempty" yaml:"timeout_in_ms,omitempty"`
	// Map from device type name (e.g., "CPU" or "GPU" ) to maximum
	// number of devices of that type to use.  If a particular device
	// type is not found in the map, the system picks an appropriate
	// number.
	DeviceCount map[string]int32 `protobuf:"bytes,3,rep,name=device_count,json=deviceCount" json:"device_count,omitempty" yaml:"device_count,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Options that apply to all CPUs.
	CpuOptions *CPUOptions `protobuf:"bytes,4,opt,name=cpu_options,json=cpuOptions" json:"cpu_options,omitempty" yaml:"cpu_options,omitempty"`
	// Options that apply to all GPUs.
	GpuOptions *GPUOptions `protobuf:"bytes,5,opt,name=gpu_options,json=gpuOptions" json:"gpu_options,omitempty" yaml:"gpu_options,omitempty"`
}

func (m *ExecutionOptions) Reset()                    { *m = ExecutionOptions{} }
func (*ExecutionOptions) ProtoMessage()               {}
func (*ExecutionOptions) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{2} }

func (m *ExecutionOptions) GetTraceLevel() ExecutionOptions_TraceLevel {
	if m != nil {
		return m.TraceLevel
	}
	return ExecutionOptions_NO_TRACE
}

func (m *ExecutionOptions) GetTimeoutInMs() int64 {
	if m != nil {
		return m.TimeoutInMs
	}
	return 0
}

func (m *ExecutionOptions) GetDeviceCount() map[string]int32 {
	if m != nil {
		return m.DeviceCount
	}
	return nil
}

func (m *ExecutionOptions) GetCpuOptions() *CPUOptions {
	if m != nil {
		return m.CpuOptions
	}
	return nil
}

func (m *ExecutionOptions) GetGpuOptions() *GPUOptions {
	if m != nil {
		return m.GpuOptions
	}
	return nil
}

type PredictionOptions struct {
	RequestID        string            `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty" yaml:"request_id,omitempty"`
	FeatureLimit     int32             `protobuf:"varint,2,opt,name=feature_limit,json=featureLimit,proto3" json:"feature_limit,omitempty" yaml:"feature_limit,omitempty"`
	BatchSize        uint32            `protobuf:"varint,3,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty" yaml:"batch_size,omitempty"`
	ExecutionOptions *ExecutionOptions `protobuf:"bytes,4,opt,name=execution_options,json=executionOptions" json:"execution_options,omitempty" yaml:"execution_options,omitempty"`
}

func (m *PredictionOptions) Reset()                    { *m = PredictionOptions{} }
func (*PredictionOptions) ProtoMessage()               {}
func (*PredictionOptions) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{3} }

func (m *PredictionOptions) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *PredictionOptions) GetFeatureLimit() int32 {
	if m != nil {
		return m.FeatureLimit
	}
	return 0
}

func (m *PredictionOptions) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *PredictionOptions) GetExecutionOptions() *ExecutionOptions {
	if m != nil {
		return m.ExecutionOptions
	}
	return nil
}

type PredictorOpenRequest struct {
	ModelName        string             `protobuf:"bytes,1,opt,name=model_name,json=modelName,proto3" json:"model_name,omitempty" yaml:"model_name,omitempty"`
	ModelVersion     string             `protobuf:"bytes,2,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty" yaml:"model_version,omitempty"`
	FrameworkName    string             `protobuf:"bytes,3,opt,name=framework_name,json=frameworkName,proto3" json:"framework_name,omitempty" yaml:"framework_name,omitempty"`
	FrameworkVersion string             `protobuf:"bytes,4,opt,name=framework_version,json=frameworkVersion,proto3" json:"framework_version,omitempty" yaml:"framework_version,omitempty"`
	Options          *PredictionOptions `protobuf:"bytes,5,opt,name=options" json:"options,omitempty" yaml:"options,omitempty"`
}

func (m *PredictorOpenRequest) Reset()                    { *m = PredictorOpenRequest{} }
func (*PredictorOpenRequest) ProtoMessage()               {}
func (*PredictorOpenRequest) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{4} }

func (m *PredictorOpenRequest) GetModelName() string {
	if m != nil {
		return m.ModelName
	}
	return ""
}

func (m *PredictorOpenRequest) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func (m *PredictorOpenRequest) GetFrameworkName() string {
	if m != nil {
		return m.FrameworkName
	}
	return ""
}

func (m *PredictorOpenRequest) GetFrameworkVersion() string {
	if m != nil {
		return m.FrameworkVersion
	}
	return ""
}

func (m *PredictorOpenRequest) GetOptions() *PredictionOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

type PredictorCloseResponse struct {
}

func (m *PredictorCloseResponse) Reset()                    { *m = PredictorCloseResponse{} }
func (*PredictorCloseResponse) ProtoMessage()               {}
func (*PredictorCloseResponse) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{5} }

type Predictor struct {
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" yaml:"id,omitempty"`
}

func (m *Predictor) Reset()                    { *m = Predictor{} }
func (*Predictor) ProtoMessage()               {}
func (*Predictor) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{6} }

func (m *Predictor) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type URLsRequest struct {
	Predictor *Predictor         `protobuf:"bytes,1,opt,name=predictor" json:"predictor,omitempty" yaml:"predictor,omitempty"`
	Urls      []*URLsRequest_URL `protobuf:"bytes,2,rep,name=urls" json:"urls,omitempty" yaml:"urls,omitempty"`
	Options   *PredictionOptions `protobuf:"bytes,3,opt,name=options" json:"options,omitempty" yaml:"options,omitempty"`
}

func (m *URLsRequest) Reset()                    { *m = URLsRequest{} }
func (*URLsRequest) ProtoMessage()               {}
func (*URLsRequest) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{7} }

func (m *URLsRequest) GetPredictor() *Predictor {
	if m != nil {
		return m.Predictor
	}
	return nil
}

func (m *URLsRequest) GetUrls() []*URLsRequest_URL {
	if m != nil {
		return m.Urls
	}
	return nil
}

func (m *URLsRequest) GetOptions() *PredictionOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

type URLsRequest_URL struct {
	// An id used to identify the output feature: maps to input_id for output
	ID   string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" yaml:"id,omitempty"`
	Data string `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty" yaml:"data,omitempty"`
}

func (m *URLsRequest_URL) Reset()                    { *m = URLsRequest_URL{} }
func (*URLsRequest_URL) ProtoMessage()               {}
func (*URLsRequest_URL) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{7, 0} }

func (m *URLsRequest_URL) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *URLsRequest_URL) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type ImagesRequest struct {
	Predictor *Predictor `protobuf:"bytes,1,opt,name=predictor" json:"predictor,omitempty" yaml:"predictor,omitempty"`
	// A list of Base64 encoded images
	Images  []*ImagesRequest_Image `protobuf:"bytes,2,rep,name=images" json:"images,omitempty" yaml:"images,omitempty"`
	Options *PredictionOptions     `protobuf:"bytes,3,opt,name=options" json:"options,omitempty" yaml:"options,omitempty"`
}

func (m *ImagesRequest) Reset()                    { *m = ImagesRequest{} }
func (*ImagesRequest) ProtoMessage()               {}
func (*ImagesRequest) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{8} }

func (m *ImagesRequest) GetPredictor() *Predictor {
	if m != nil {
		return m.Predictor
	}
	return nil
}

func (m *ImagesRequest) GetImages() []*ImagesRequest_Image {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *ImagesRequest) GetOptions() *PredictionOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

type ImagesRequest_Image struct {
	// An id used to identify the output feature: maps to input_id for output
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" yaml:"id,omitempty"`
	// The image is base64 encoded
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty" yaml:"data,omitempty"`
}

func (m *ImagesRequest_Image) Reset()                    { *m = ImagesRequest_Image{} }
func (*ImagesRequest_Image) ProtoMessage()               {}
func (*ImagesRequest_Image) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{8, 0} }

func (m *ImagesRequest_Image) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ImagesRequest_Image) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DatasetRequest struct {
	Predictor *Predictor              `protobuf:"bytes,1,opt,name=predictor" json:"predictor,omitempty" yaml:"predictor,omitempty"`
	Dataset   *DatasetRequest_Dataset `protobuf:"bytes,2,opt,name=dataset" json:"dataset,omitempty" yaml:"dataset,omitempty"`
	Options   *PredictionOptions      `protobuf:"bytes,3,opt,name=options" json:"options,omitempty" yaml:"options,omitempty"`
}

func (m *DatasetRequest) Reset()                    { *m = DatasetRequest{} }
func (*DatasetRequest) ProtoMessage()               {}
func (*DatasetRequest) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{9} }

func (m *DatasetRequest) GetPredictor() *Predictor {
	if m != nil {
		return m.Predictor
	}
	return nil
}

func (m *DatasetRequest) GetDataset() *DatasetRequest_Dataset {
	if m != nil {
		return m.Dataset
	}
	return nil
}

func (m *DatasetRequest) GetOptions() *PredictionOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

type DatasetRequest_Dataset struct {
	Category string `protobuf:"bytes,1,opt,name=category,proto3" json:"category,omitempty" yaml:"category,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" yaml:"name,omitempty"`
}

func (m *DatasetRequest_Dataset) Reset()      { *m = DatasetRequest_Dataset{} }
func (*DatasetRequest_Dataset) ProtoMessage() {}
func (*DatasetRequest_Dataset) Descriptor() ([]byte, []int) {
	return fileDescriptorPredictor, []int{9, 0}
}

func (m *DatasetRequest_Dataset) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

func (m *DatasetRequest_Dataset) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Feature struct {
	Index       int64             `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty" yaml:"index,omitempty"`
	Name        string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" yaml:"name,omitempty"`
	Probability float32           `protobuf:"fixed32,3,opt,name=probability,proto3" json:"probability,omitempty" yaml:"probability,omitempty"`
	Metadata    map[string]string `protobuf:"bytes,4,rep,name=metadata" json:"metadata,omitempty" yaml:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Feature) Reset()                    { *m = Feature{} }
func (*Feature) ProtoMessage()               {}
func (*Feature) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{10} }

func (m *Feature) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Feature) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Feature) GetProbability() float32 {
	if m != nil {
		return m.Probability
	}
	return 0
}

func (m *Feature) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type FeatureResponse struct {
	ID        string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" yaml:"id,omitempty"`
	RequestID string            `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty" yaml:"request_id,omitempty"`
	InputID   string            `protobuf:"bytes,3,opt,name=input_id,json=inputId,proto3" json:"input_id,omitempty" yaml:"input_id,omitempty"`
	Features  []*Feature        `protobuf:"bytes,4,rep,name=features" json:"features,omitempty" yaml:"features,omitempty"`
	Metadata  map[string]string `protobuf:"bytes,5,rep,name=metadata" json:"metadata,omitempty" yaml:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FeatureResponse) Reset()                    { *m = FeatureResponse{} }
func (*FeatureResponse) ProtoMessage()               {}
func (*FeatureResponse) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{11} }

func (m *FeatureResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *FeatureResponse) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *FeatureResponse) GetInputID() string {
	if m != nil {
		return m.InputID
	}
	return ""
}

func (m *FeatureResponse) GetFeatures() []*Feature {
	if m != nil {
		return m.Features
	}
	return nil
}

func (m *FeatureResponse) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type FeaturesResponse struct {
	ID        string             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" yaml:"id,omitempty"`
	Responses []*FeatureResponse `protobuf:"bytes,2,rep,name=responses" json:"responses,omitempty" yaml:"responses,omitempty"`
}

func (m *FeaturesResponse) Reset()                    { *m = FeaturesResponse{} }
func (*FeaturesResponse) ProtoMessage()               {}
func (*FeaturesResponse) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{12} }

func (m *FeaturesResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *FeaturesResponse) GetResponses() []*FeatureResponse {
	if m != nil {
		return m.Responses
	}
	return nil
}

type ResetRequest struct {
	ID        string     `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty" yaml:"id,omitempty"`
	Predictor *Predictor `protobuf:"bytes,1,opt,name=predictor" json:"predictor,omitempty" yaml:"predictor,omitempty"`
}

func (m *ResetRequest) Reset()                    { *m = ResetRequest{} }
func (*ResetRequest) ProtoMessage()               {}
func (*ResetRequest) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{13} }

func (m *ResetRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ResetRequest) GetPredictor() *Predictor {
	if m != nil {
		return m.Predictor
	}
	return nil
}

type ResetResponse struct {
	*Predictor `protobuf:"bytes,1,opt,name=predictor,embedded=predictor" json:"predictor,omitempty" yaml:"predictor,omitempty"`
}

func (m *ResetResponse) Reset()                    { *m = ResetResponse{} }
func (*ResetResponse) ProtoMessage()               {}
func (*ResetResponse) Descriptor() ([]byte, []int) { return fileDescriptorPredictor, []int{14} }

func init() {
	proto.RegisterType((*CPUOptions)(nil), "carml.org.dlframework.CPUOptions")
	golang_proto.RegisterType((*CPUOptions)(nil), "carml.org.dlframework.CPUOptions")
	proto.RegisterType((*GPUOptions)(nil), "carml.org.dlframework.GPUOptions")
	golang_proto.RegisterType((*GPUOptions)(nil), "carml.org.dlframework.GPUOptions")
	proto.RegisterType((*ExecutionOptions)(nil), "carml.org.dlframework.ExecutionOptions")
	golang_proto.RegisterType((*ExecutionOptions)(nil), "carml.org.dlframework.ExecutionOptions")
	proto.RegisterType((*PredictionOptions)(nil), "carml.org.dlframework.PredictionOptions")
	golang_proto.RegisterType((*PredictionOptions)(nil), "carml.org.dlframework.PredictionOptions")
	proto.RegisterType((*PredictorOpenRequest)(nil), "carml.org.dlframework.PredictorOpenRequest")
	golang_proto.RegisterType((*PredictorOpenRequest)(nil), "carml.org.dlframework.PredictorOpenRequest")
	proto.RegisterType((*PredictorCloseResponse)(nil), "carml.org.dlframework.PredictorCloseResponse")
	golang_proto.RegisterType((*PredictorCloseResponse)(nil), "carml.org.dlframework.PredictorCloseResponse")
	proto.RegisterType((*Predictor)(nil), "carml.org.dlframework.Predictor")
	golang_proto.RegisterType((*Predictor)(nil), "carml.org.dlframework.Predictor")
	proto.RegisterType((*URLsRequest)(nil), "carml.org.dlframework.URLsRequest")
	golang_proto.RegisterType((*URLsRequest)(nil), "carml.org.dlframework.URLsRequest")
	proto.RegisterType((*URLsRequest_URL)(nil), "carml.org.dlframework.URLsRequest.URL")
	golang_proto.RegisterType((*URLsRequest_URL)(nil), "carml.org.dlframework.URLsRequest.URL")
	proto.RegisterType((*ImagesRequest)(nil), "carml.org.dlframework.ImagesRequest")
	golang_proto.RegisterType((*ImagesRequest)(nil), "carml.org.dlframework.ImagesRequest")
	proto.RegisterType((*ImagesRequest_Image)(nil), "carml.org.dlframework.ImagesRequest.Image")
	golang_proto.RegisterType((*ImagesRequest_Image)(nil), "carml.org.dlframework.ImagesRequest.Image")
	proto.RegisterType((*DatasetRequest)(nil), "carml.org.dlframework.DatasetRequest")
	golang_proto.RegisterType((*DatasetRequest)(nil), "carml.org.dlframework.DatasetRequest")
	proto.RegisterType((*DatasetRequest_Dataset)(nil), "carml.org.dlframework.DatasetRequest.Dataset")
	golang_proto.RegisterType((*DatasetRequest_Dataset)(nil), "carml.org.dlframework.DatasetRequest.Dataset")
	proto.RegisterType((*Feature)(nil), "carml.org.dlframework.Feature")
	golang_proto.RegisterType((*Feature)(nil), "carml.org.dlframework.Feature")
	proto.RegisterType((*FeatureResponse)(nil), "carml.org.dlframework.FeatureResponse")
	golang_proto.RegisterType((*FeatureResponse)(nil), "carml.org.dlframework.FeatureResponse")
	proto.RegisterType((*FeaturesResponse)(nil), "carml.org.dlframework.FeaturesResponse")
	golang_proto.RegisterType((*FeaturesResponse)(nil), "carml.org.dlframework.FeaturesResponse")
	proto.RegisterType((*ResetRequest)(nil), "carml.org.dlframework.ResetRequest")
	golang_proto.RegisterType((*ResetRequest)(nil), "carml.org.dlframework.ResetRequest")
	proto.RegisterType((*ResetResponse)(nil), "carml.org.dlframework.ResetResponse")
	golang_proto.RegisterType((*ResetResponse)(nil), "carml.org.dlframework.ResetResponse")
	proto.RegisterEnum("carml.org.dlframework.ExecutionOptions_TraceLevel", ExecutionOptions_TraceLevel_name, ExecutionOptions_TraceLevel_value)
	golang_proto.RegisterEnum("carml.org.dlframework.ExecutionOptions_TraceLevel", ExecutionOptions_TraceLevel_name, ExecutionOptions_TraceLevel_value)
}
func (this *PredictionOptions) Description() (desc *descriptor.FileDescriptorSet) {
	return PredictorDescription()
}
func (this *PredictorOpenRequest) Description() (desc *descriptor.FileDescriptorSet) {
	return PredictorDescription()
}
func (this *Predictor) Description() (desc *descriptor.FileDescriptorSet) {
	return PredictorDescription()
}
func (this *URLsRequest) Description() (desc *descriptor.FileDescriptorSet) {
	return PredictorDescription()
}
func (this *ImagesRequest) Description() (desc *descriptor.FileDescriptorSet) {
	return PredictorDescription()
}
func (this *DatasetRequest) Description() (desc *descriptor.FileDescriptorSet) {
	return PredictorDescription()
}
func (this *Feature) Description() (desc *descriptor.FileDescriptorSet) {
	return PredictorDescription()
}
func (this *FeatureResponse) Description() (desc *descriptor.FileDescriptorSet) {
	return PredictorDescription()
}
func (this *FeaturesResponse) Description() (desc *descriptor.FileDescriptorSet) {
	return PredictorDescription()
}
func (this *ResetRequest) Description() (desc *descriptor.FileDescriptorSet) {
	return PredictorDescription()
}
func (this *ResetResponse) Description() (desc *descriptor.FileDescriptorSet) {
	return PredictorDescription()
}
func PredictorDescription() (desc *descriptor.FileDescriptorSet) {
	d := &descriptor.FileDescriptorSet{}
	var gzipped = []byte{
		// 6690 bytes of a gzipped FileDescriptorSet
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x7c, 0x6b, 0x6c, 0x24, 0xc7,
		0x75, 0xae, 0x7a, 0x1e, 0xe4, 0xcc, 0x99, 0x21, 0xd9, 0x2c, 0x52, 0xbb, 0xb3, 0xb3, 0x5a, 0xce,
		0xee, 0x48, 0xf2, 0xae, 0x1e, 0x4b, 0xea, 0xae, 0xa4, 0xd5, 0x6a, 0xf6, 0x4a, 0x02, 0x87, 0x9c,
		0xa5, 0xb8, 0xe6, 0x63, 0xdc, 0x24, 0xf5, 0xf2, 0x85, 0xfb, 0x36, 0x7b, 0x8a, 0xc3, 0xd6, 0xce,
		0x74, 0xb7, 0xba, 0x7b, 0x76, 0xc5, 0xbd, 0xf7, 0x1a, 0xf2, 0xeb, 0x1a, 0x8e, 0xf3, 0x70, 0xe2,
		0x20, 0x7e, 0xc4, 0x0f, 0xd9, 0x80, 0x23, 0xc7, 0x79, 0xd8, 0x8e, 0x1f, 0x71, 0x82, 0x24, 0x30,
		0x02, 0x24, 0x31, 0x12, 0x20, 0xb0, 0x11, 0x20, 0x08, 0xf2, 0x83, 0xb1, 0xd6, 0x02, 0x92, 0x38,
		0x4a, 0xe2, 0x30, 0x02, 0x62, 0x40, 0xf9, 0x11, 0xd4, 0xab, 0xa7, 0x7a, 0x66, 0xc8, 0x99, 0x5d,
		0x49, 0x2b, 0xe4, 0x17, 0xa7, 0x4f, 0x9d, 0xef, 0xab, 0x53, 0xa7, 0x4e, 0x55, 0x9d, 0xaa, 0xea,
		0x26, 0x7c, 0x3f, 0x01, 0xb7, 0xd6, 0x1d, 0xa7, 0xde, 0xc0, 0x33, 0x86, 0x6b, 0xcd, 0x6c, 0x07,
		0x81, 0x3b, 0xed, 0x7a, 0x4e, 0xe0, 0x20, 0x60, 0xe2, 0x69, 0xc3, 0xb5, 0x8a, 0x67, 0x20, 0xf1,
		0x78, 0x10, 0xb8, 0xe8, 0x6e, 0x48, 0x7a, 0xad, 0x06, 0xf6, 0x73, 0xca, 0xf1, 0xf8, 0xa9, 0xcc,
		0x99, 0xc9, 0xe9, 0xb6, 0xce, 0x34, 0x51, 0xd0, 0x5a, 0x0d, 0xac, 0x31, 0x95, 0xe2, 0xb7, 0x62,
		0x90, 0x12, 0x32, 0x94, 0x87, 0x94, 0x8f, 0x1b, 0xd8, 0x0c, 0x1c, 0x2f, 0xa7, 0x1c, 0x57, 0x4e,
		0xa5, 0xb5, 0xf0, 0x19, 0x21, 0x88, 0xd7, 0x71, 0x90, 0x8b, 0x11, 0xf1, 0xe3, 0xb7, 0x68, 0xe4,
		0x81, 0xc8, 0xdc, 0x56, 0x90, 0x8b, 0x0b, 0x99, 0xdb, 0x0a, 0xd0, 0x24, 0x24, 0x5c, 0xc7, 0x0f,
		0x72, 0x09, 0x2e, 0xa4, 0x4f, 0x28, 0x07, 0x43, 0x35, 0xdc, 0xc0, 0x01, 0xce, 0x25, 0xb9, 0x9c,
		0x3f, 0xa3, 0x43, 0x90, 0x74, 0x8d, 0xc0, 0xdc, 0xce, 0x0d, 0xf1, 0x02, 0xf6, 0x88, 0x10, 0x24,
		0x36, 0x9d, 0xda, 0x4e, 0x6e, 0x98, 0xda, 0x41, 0x7f, 0xa3, 0x87, 0x60, 0xc8, 0x6c, 0xf9, 0x81,
		0xd3, 0xcc, 0xa5, 0x8e, 0x2b, 0xa7, 0x32, 0x67, 0x8e, 0xc9, 0x2d, 0x9b, 0xa3, 0x25, 0xa4, 0x2d,
		0x55, 0x23, 0x08, 0xb0, 0x67, 0x93, 0x4a, 0x98, 0x3a, 0xaa, 0xc0, 0x84, 0x51, 0xab, 0x59, 0x81,
		0xe5, 0xd8, 0x46, 0x43, 0xdf, 0xb4, 0xec, 0x9a, 0x65, 0xd7, 0xfd, 0x5c, 0xe6, 0x00, 0xff, 0xa0,
		0x36, 0xa0, 0xcc, 0xf5, 0xcb, 0x69, 0x18, 0x76, 0x19, 0x77, 0xf1, 0x3c, 0x8c, 0x77, 0x55, 0x48,
		0x6c, 0xbe, 0x64, 0xd9, 0x35, 0xee, 0x3b, 0xfa, 0x9b, 0xc8, 0x5c, 0x23, 0xd8, 0x66, 0x8e, 0xd3,
		0xe8, 0xef, 0xf2, 0xd5, 0xef, 0x5d, 0x9b, 0x52, 0xbe, 0x7f, 0x6d, 0x4a, 0xf9, 0xe1, 0xb5, 0x29,
		0xe5, 0x63, 0x3f, 0x9a, 0xba, 0x05, 0x46, 0x4d, 0xa7, 0x29, 0x99, 0x51, 0x4e, 0x53, 0x5a, 0xd2,
		0xc3, 0x55, 0xe5, 0x99, 0x59, 0x5e, 0x50, 0x77, 0x1a, 0x86, 0x5d, 0x9f, 0x76, 0xbc, 0xfa, 0x4c,
		0x1d, 0xdb, 0xb4, 0xff, 0x67, 0x58, 0x91, 0xe1, 0x5a, 0x3e, 0x8d, 0x0c, 0xc3, 0xb6, 0x9d, 0xc0,
		0x20, 0x66, 0xfb, 0xe7, 0xa5, 0xdf, 0x3f, 0x55, 0x94, 0x2f, 0xc6, 0x12, 0x0b, 0xb3, 0xd5, 0xc5,
		0xcd, 0x21, 0x8a, 0xbb, 0x1f, 0xbe, 0x72, 0x16, 0x8e, 0xf3, 0x90, 0xa2, 0x92, 0xcd, 0xd6, 0xd6,
		0x4c, 0x0d, 0xfb, 0xa6, 0x67, 0xb9, 0x81, 0xe3, 0xf1, 0xe8, 0x1a, 0xe3, 0x35, 0x0b, 0x8d, 0xe2,
		0x32, 0x8c, 0x5f, 0xb0, 0x1a, 0x78, 0x3e, 0x54, 0x5c, 0xc3, 0x01, 0x3a, 0x07, 0x89, 0x2d, 0xab,
		0x81, 0x79, 0xb8, 0xdd, 0x31, 0xdd, 0x01, 0x9a, 0x8e, 0x22, 0x68, 0xab, 0x34, 0x8a, 0x28, 0xbe,
		0x92, 0x80, 0x89, 0x1e, 0xa5, 0xc4, 0x69, 0xb6, 0xd1, 0xc4, 0xc2, 0x91, 0xe4, 0x37, 0xca, 0x11,
		0xe7, 0x9b, 0x97, 0x8c, 0x3a, 0xe6, 0xbe, 0x14, 0x8f, 0x68, 0x0a, 0xa0, 0x86, 0x5d, 0x6c, 0xd7,
		0xb0, 0x6d, 0xee, 0xe4, 0xe2, 0xc7, 0xe3, 0xa7, 0xd2, 0x9a, 0x24, 0x41, 0xf7, 0xc0, 0xb8, 0xdb,
		0xda, 0x6c, 0x58, 0xa6, 0x2e, 0xa9, 0xc1, 0xf1, 0xf8, 0xa9, 0xa4, 0xa6, 0xb2, 0x82, 0xf9, 0xb6,
		0xf2, 0x49, 0x18, 0xbb, 0x82, 0x8d, 0x4b, 0xb2, 0x6a, 0x86, 0xaa, 0x8e, 0x12, 0xb1, 0xa4, 0x38,
		0x07, 0xd9, 0x26, 0xf6, 0x7d, 0xa3, 0x8e, 0xf5, 0x60, 0xc7, 0xc5, 0xb9, 0x04, 0x6d, 0xfd, 0xf1,
		0xae, 0xd6, 0x77, 0xb6, 0x3c, 0xc3, 0x51, 0xeb, 0x3b, 0x2e, 0x46, 0xb3, 0x90, 0xc6, 0x76, 0xab,
		0xc9, 0x18, 0x92, 0xfb, 0xf8, 0xaf, 0x62, 0xb7, 0x9a, 0x9d, 0x2c, 0x29, 0x02, 0xe3, 0x14, 0xc3,
		0x3e, 0xf6, 0x2e, 0x5b, 0x26, 0xce, 0x0d, 0x51, 0x82, 0x93, 0x5d, 0x04, 0x6b, 0xac, 0xbc, 0x93,
		0x43, 0xe0, 0xd0, 0x1c, 0xa4, 0xf1, 0xf3, 0x01, 0xb6, 0x7d, 0xcb, 0xb1, 0x73, 0xc3, 0x94, 0xe4,
		0xce, 0x1e, 0xbd, 0x88, 0x1b, 0xb5, 0x4e, 0x8a, 0x36, 0x0e, 0x9d, 0x85, 0x61, 0xc7, 0xa5, 0xd1,
		0xc6, 0x47, 0xe7, 0x6d, 0x3d, 0x03, 0x61, 0x95, 0xe9, 0x68, 0x42, 0x19, 0x2d, 0x82, 0xea, 0x3b,
		0x2d, 0xcf, 0xc4, 0xba, 0xe9, 0xd4, 0xb0, 0x6e, 0xd9, 0x5b, 0x4e, 0x2e, 0x4d, 0x09, 0x0a, 0xdd,
		0x0d, 0xa1, 0x8a, 0x73, 0x4e, 0x0d, 0x2f, 0xda, 0x5b, 0x8e, 0x36, 0xea, 0x47, 0x9e, 0xd1, 0x21,
		0x18, 0xf2, 0x77, 0xec, 0xc0, 0x78, 0x3e, 0x97, 0xa5, 0x11, 0xc2, 0x9f, 0x8a, 0xff, 0x91, 0x84,
		0xb1, 0x41, 0x42, 0xec, 0x3c, 0x24, 0xb7, 0x48, 0x2b, 0x73, 0xb1, 0xeb, 0xf1, 0x01, 0xc3, 0x44,
		0x9d, 0x38, 0x74, 0x83, 0x4e, 0x9c, 0x85, 0x8c, 0x8d, 0xfd, 0x00, 0xd7, 0x58, 0x44, 0xc4, 0x07,
		0x8c, 0x29, 0x60, 0xa0, 0xee, 0x90, 0x4a, 0xdc, 0x50, 0x48, 0x3d, 0x05, 0x63, 0xa1, 0x49, 0xba,
		0x67, 0xd8, 0x75, 0x11, 0x9b, 0x33, 0xfd, 0x2c, 0x99, 0xae, 0x08, 0x9c, 0x46, 0x60, 0xda, 0x28,
		0x8e, 0x3c, 0xa3, 0x79, 0x00, 0xc7, 0xc6, 0xce, 0x96, 0x5e, 0xc3, 0x66, 0x23, 0x97, 0xda, 0xc7,
		0x4b, 0xab, 0x44, 0xa5, 0xcb, 0x4b, 0x0e, 0x93, 0x9a, 0x0d, 0xf4, 0x70, 0x3b, 0xd4, 0x86, 0xf7,
		0x89, 0x94, 0x65, 0x36, 0xc8, 0xba, 0xa2, 0x6d, 0x03, 0x46, 0x3d, 0x4c, 0xe2, 0x1e, 0xd7, 0x78,
		0xcb, 0xd2, 0xd4, 0x88, 0xe9, 0xbe, 0x2d, 0xd3, 0x38, 0x8c, 0x35, 0x6c, 0xc4, 0x93, 0x1f, 0xd1,
		0xed, 0x10, 0x0a, 0x74, 0x1a, 0x56, 0x40, 0x67, 0xa1, 0xac, 0x10, 0xae, 0x18, 0x4d, 0x9c, 0x3f,
		0x07, 0xa3, 0x51, 0xf7, 0xa0, 0x49, 0x48, 0xfa, 0x81, 0xe1, 0x05, 0x34, 0x0a, 0x93, 0x1a, 0x7b,
		0x40, 0x2a, 0xc4, 0xb1, 0x5d, 0xa3, 0xb3, 0x5c, 0x52, 0x23, 0x3f, 0xf3, 0x0f, 0xc1, 0x48, 0xa4,
		0xfa, 0x41, 0x81, 0xc5, 0x4f, 0x0e, 0xc1, 0x64, 0xaf, 0x98, 0xeb, 0x19, 0xfe, 0x87, 0x60, 0xc8,
		0x6e, 0x35, 0x37, 0xb1, 0x47, 0x57, 0xf4, 0xa4, 0xc6, 0x9f, 0xd0, 0x2c, 0x24, 0x1b, 0xc6, 0x26,
		0x6e, 0xd0, 0x35, 0x7d, 0xf4, 0xcc, 0x3d, 0x03, 0x45, 0xf5, 0xf4, 0x12, 0x81, 0x68, 0x0c, 0x89,
		0x1e, 0x85, 0x04, 0x9f, 0xe2, 0x08, 0xc3, 0xdd, 0x83, 0x31, 0x90, 0x58, 0xd4, 0x28, 0x0e, 0x1d,
		0x85, 0x34, 0xf9, 0xcb, 0x7c, 0x3b, 0xc4, 0x52, 0x13, 0x22, 0x20, 0x7e, 0x25, 0x69, 0x0b, 0x0d,
		0xb3, 0x1a, 0x16, 0x4b, 0x43, 0xf8, 0x4c, 0x3a, 0xa6, 0x86, 0xb7, 0x8c, 0x56, 0x23, 0xd0, 0x2f,
		0x1b, 0x8d, 0x16, 0xe6, 0xf9, 0x44, 0x96, 0x0b, 0x9f, 0x20, 0x32, 0x54, 0x80, 0x0c, 0x8b, 0x4a,
		0xcb, 0xae, 0xe1, 0xe7, 0xe9, 0xec, 0x93, 0xd4, 0x58, 0xa0, 0x2e, 0x12, 0x09, 0xa9, 0xfe, 0x59,
		0xdf, 0xb1, 0x45, 0xd7, 0xd2, 0x2a, 0x88, 0x80, 0x56, 0xff, 0x50, 0xe7, 0xc4, 0x77, 0xac, 0x77,
		0xf3, 0x3a, 0x63, 0xb1, 0xf8, 0xed, 0x18, 0x24, 0xe8, 0x78, 0x1b, 0x83, 0xcc, 0xfa, 0xd3, 0xd5,
		0x8a, 0x3e, 0xbf, 0xba, 0x51, 0x5e, 0xaa, 0xa8, 0x0a, 0x1a, 0x05, 0xa0, 0x82, 0x0b, 0x4b, 0xab,
		0xb3, 0xeb, 0x6a, 0x2c, 0x7c, 0x5e, 0x5c, 0x59, 0x3f, 0xfb, 0x80, 0x1a, 0x0f, 0x01, 0x1b, 0x4c,
		0x90, 0x90, 0x15, 0xee, 0x3f, 0xa3, 0x26, 0x91, 0x0a, 0x59, 0x46, 0xb0, 0xf8, 0x54, 0x65, 0xfe,
		0xec, 0x03, 0xea, 0x50, 0x54, 0x72, 0xff, 0x19, 0x75, 0x18, 0x8d, 0x40, 0x9a, 0x4a, 0xca, 0xab,
		0xab, 0x4b, 0x6a, 0x2a, 0xe4, 0x5c, 0x5b, 0xd7, 0x16, 0x57, 0x16, 0xd4, 0x74, 0xc8, 0xb9, 0xa0,
		0xad, 0x6e, 0x54, 0x55, 0x08, 0x19, 0x96, 0x2b, 0x6b, 0x6b, 0xb3, 0x0b, 0x15, 0x35, 0x13, 0x6a,
		0x94, 0x9f, 0x5e, 0xaf, 0xac, 0xa9, 0xd9, 0x88, 0x59, 0xf7, 0x9f, 0x51, 0x47, 0xc2, 0x2a, 0x2a,
		0x2b, 0x1b, 0xcb, 0xea, 0x28, 0x1a, 0x87, 0x11, 0x56, 0x85, 0x30, 0x62, 0xac, 0x43, 0x74, 0xf6,
		0x01, 0x55, 0x6d, 0x1b, 0xc2, 0x58, 0xc6, 0x23, 0x82, 0xb3, 0x0f, 0xa8, 0xa8, 0x38, 0x07, 0x49,
		0x1a, 0x5d, 0x08, 0xc1, 0xe8, 0xd2, 0x6c, 0xb9, 0xb2, 0xa4, 0xaf, 0x56, 0xd7, 0x17, 0x57, 0x57,
		0x66, 0x97, 0x54, 0xa5, 0x2d, 0xd3, 0x2a, 0xef, 0xda, 0x58, 0xd4, 0x2a, 0xf3, 0x6a, 0x4c, 0x96,
		0x55, 0x2b, 0xb3, 0xeb, 0x95, 0x79, 0x35, 0x5e, 0x34, 0x61, 0xb2, 0xd7, 0x3c, 0xd3, 0x73, 0x64,
		0x48, 0x5d, 0x1c, 0xdb, 0xa7, 0x8b, 0x29, 0x57, 0x57, 0x17, 0x7f, 0x51, 0x81, 0x89, 0x1e, 0x73,
		0x6d, 0xcf, 0x4a, 0x1e, 0x83, 0x24, 0x0b, 0x51, 0xb6, 0xfa, 0xdc, 0xd5, 0x73, 0xd2, 0xa6, 0x01,
		0xdb, 0xb5, 0x02, 0x51, 0x9c, 0xbc, 0x02, 0xc7, 0xf7, 0x59, 0x81, 0x09, 0x45, 0x97, 0x91, 0x1f,
		0x50, 0x20, 0xb7, 0x1f, 0x77, 0x9f, 0x89, 0x22, 0x16, 0x99, 0x28, 0xce, 0x77, 0x1a, 0x70, 0x62,
		0xff, 0x36, 0x74, 0x59, 0xf1, 0x92, 0x02, 0x87, 0x7a, 0x27, 0x2a, 0x3d, 0x6d, 0x78, 0x14, 0x86,
		0x9a, 0x38, 0xd8, 0x76, 0xc4, 0x62, 0xfd, 0x8e, 0x1e, 0x4b, 0x00, 0x29, 0xee, 0xf4, 0x15, 0x47,
		0xc9, 0x6b, 0x48, 0x7c, 0xbf, 0x6c, 0x83, 0x59, 0xd3, 0x65, 0xe9, 0x47, 0x62, 0x70, 0x6b, 0x4f,
		0xf2, 0x9e, 0x86, 0x1e, 0x03, 0xb0, 0x6c, 0xb7, 0x15, 0xb0, 0x05, 0x99, 0xcd, 0x4f, 0x69, 0x2a,
		0xa1, 0x63, 0x9f, 0xcc, 0x3d, 0xad, 0x20, 0x2c, 0xa7, 0x7b, 0x29, 0x0d, 0x98, 0x88, 0x2a, 0x9c,
		0x6b, 0x1b, 0x9a, 0xa0, 0x86, 0x4e, 0xed, 0xd3, 0xd2, 0xae, 0xb5, 0xee, 0x3e, 0x50, 0xcd, 0x86,
		0x85, 0xed, 0x40, 0xf7, 0x03, 0x0f, 0x1b, 0x4d, 0xcb, 0xae, 0xd3, 0x09, 0x38, 0x55, 0x4a, 0x6e,
		0x19, 0x0d, 0x1f, 0x6b, 0x63, 0xac, 0x78, 0x4d, 0x94, 0x12, 0x04, 0x5d, 0x65, 0x3c, 0x09, 0x31,
		0x14, 0x41, 0xb0, 0xe2, 0x10, 0x51, 0xfc, 0xfa, 0x30, 0x64, 0xa4, 0xb4, 0x0e, 0x9d, 0x80, 0xec,
		0xb3, 0xc6, 0x65, 0x43, 0x17, 0xa9, 0x3a, 0xf3, 0x44, 0x86, 0xc8, 0xaa, 0x3c, 0x5d, 0xbf, 0x0f,
		0x26, 0xa9, 0x8a, 0xd3, 0x0a, 0xb0, 0xa7, 0x9b, 0x0d, 0xc3, 0xf7, 0xa9, 0xd3, 0x52, 0x54, 0x15,
		0x91, 0xb2, 0x55, 0x52, 0x34, 0x27, 0x4a, 0xd0, 0x83, 0x30, 0x41, 0x11, 0xcd, 0x56, 0x23, 0xb0,
		0xdc, 0x06, 0xd6, 0xc9, 0xe6, 0xc1, 0xa7, 0x13, 0x71, 0x68, 0xd9, 0x38, 0xd1, 0x58, 0xe6, 0x0a,
		0xc4, 0x22, 0x1f, 0xcd, 0xc3, 0x31, 0x0a, 0xab, 0x63, 0x1b, 0x7b, 0x46, 0x80, 0x75, 0xfc, 0x5c,
		0xcb, 0x68, 0xf8, 0xba, 0x61, 0xd7, 0xf4, 0x6d, 0xc3, 0xdf, 0xce, 0x4d, 0x12, 0x82, 0x72, 0x2c,
		0xa7, 0x68, 0x47, 0x88, 0xe2, 0x02, 0xd7, 0xab, 0x50, 0xb5, 0x59, 0xbb, 0xf6, 0xb8, 0xe1, 0x6f,
		0xa3, 0x12, 0x1c, 0xa2, 0x2c, 0x7e, 0xe0, 0x59, 0x76, 0x5d, 0x37, 0xb7, 0xb1, 0x79, 0x49, 0x6f,
		0x05, 0x5b, 0xe7, 0x72, 0x47, 0xe5, 0xfa, 0xa9, 0x85, 0x6b, 0x54, 0x67, 0x8e, 0xa8, 0x6c, 0x04,
		0x5b, 0xe7, 0xd0, 0x1a, 0x64, 0x49, 0x67, 0x34, 0xad, 0xab, 0x58, 0xdf, 0x72, 0x3c, 0xba, 0xb2,
		0x8c, 0xf6, 0x18, 0xd9, 0x92, 0x07, 0xa7, 0x57, 0x39, 0x60, 0xd9, 0xa9, 0xe1, 0x52, 0x72, 0xad,
		0x5a, 0xa9, 0xcc, 0x6b, 0x19, 0xc1, 0x72, 0xc1, 0xf1, 0x48, 0x40, 0xd5, 0x9d, 0xd0, 0xc1, 0x19,
		0x16, 0x50, 0x75, 0x47, 0xb8, 0xf7, 0x41, 0x98, 0x30, 0x4d, 0xd6, 0x66, 0xcb, 0xd4, 0x79, 0x8a,
		0xef, 0xe7, 0xd4, 0x88, 0xb3, 0x4c, 0x73, 0x81, 0x29, 0xf0, 0x18, 0xf7, 0xd1, 0xc3, 0x70, 0x6b,
		0xdb, 0x59, 0x32, 0x70, 0xbc, 0xab, 0x95, 0x9d, 0xd0, 0x07, 0x61, 0xc2, 0xdd, 0xe9, 0x06, 0xa2,
		0x48, 0x8d, 0xee, 0x4e, 0x27, 0xec, 0x4e, 0xba, 0x6d, 0xf3, 0xb0, 0x69, 0x04, 0xb8, 0x96, 0x3b,
		0x2c, 0x6b, 0x4b, 0x05, 0x68, 0x06, 0x54, 0xd3, 0xd4, 0xb1, 0x6d, 0x6c, 0x36, 0xb0, 0x6e, 0x78,
		0xd8, 0x36, 0xfc, 0x5c, 0x41, 0x56, 0x1e, 0x35, 0xcd, 0x0a, 0x2d, 0x9d, 0xa5, 0x85, 0xe8, 0x6e,
		0x18, 0x77, 0x36, 0x9f, 0x35, 0x59, 0x64, 0xe9, 0xae, 0x87, 0xb7, 0xac, 0xe7, 0x73, 0x77, 0x50,
		0x37, 0x8d, 0x91, 0x02, 0x1a, 0x57, 0x55, 0x2a, 0x46, 0x77, 0x81, 0x6a, 0xfa, 0xdb, 0x86, 0xe7,
		0xd2, 0xa5, 0xdd, 0x77, 0x0d, 0x13, 0xe7, 0xee, 0x64, 0xaa, 0x4c, 0xbe, 0x22, 0xc4, 0x24, 0xb2,
		0xfd, 0x2b, 0xd6, 0x56, 0x20, 0x18, 0x4f, 0xb2, 0xc8, 0xa6, 0x32, 0xce, 0xf6, 0x14, 0x4c, 0xb6,
		0x6c, 0xcb, 0x0e, 0xb0, 0xe7, 0x7a, 0x98, 0x24, 0xf1, 0x6c, 0x24, 0xe6, 0xfe, 0x7e, 0x78, 0x9f,
		0x34, 0x7c, 0x43, 0xd6, 0x66, 0x01, 0xa0, 0x4d, 0xb4, 0xba, 0x85, 0xc5, 0x12, 0x64, 0xe5, 0xb8,
		0x40, 0x69, 0x60, 0x91, 0xa1, 0x2a, 0x64, 0x8d, 0x9d, 0x5b, 0x9d, 0x27, 0xab, 0xe3, 0x33, 0x15,
		0x35, 0x46, 0x56, 0xe9, 0xa5, 0xc5, 0xf5, 0x8a, 0xae, 0x6d, 0xac, 0xac, 0x2f, 0x2e, 0x57, 0xd4,
		0xf8, 0xdd, 0xe9, 0xd4, 0x3f, 0x0c, 0xab, 0x2f, 0xbc, 0xf0, 0xc2, 0x0b, 0xb1, 0x8b, 0x89, 0xd4,
		0x3b, 0xd4, 0x93, 0xc5, 0xbf, 0x88, 0xc1, 0x68, 0x34, 0x3f, 0x46, 0xff, 0x13, 0x0e, 0x8b, 0xcd,
		0xac, 0x8f, 0x03, 0xfd, 0x8a, 0xe5, 0xd1, 0x80, 0x6d, 0x1a, 0x2c, 0xc3, 0x0c, 0x7d, 0x3d, 0xc9,
		0xb5, 0xd6, 0x70, 0xf0, 0xa4, 0xe5, 0x91, 0x70, 0x6c, 0x1a, 0x01, 0x5a, 0x82, 0x82, 0xed, 0xe8,
		0x7e, 0x60, 0xd8, 0x35, 0xc3, 0xab, 0xe9, 0xed, 0x63, 0x04, 0xdd, 0x30, 0x4d, 0xec, 0xfb, 0x0e,
		0x5b, 0x28, 0x42, 0x96, 0xdb, 0x6c, 0x67, 0x8d, 0x2b, 0xb7, 0x67, 0xd0, 0x59, 0xae, 0xda, 0x11,
		0x17, 0xf1, 0xfd, 0xe2, 0xe2, 0x28, 0xa4, 0x9b, 0x86, 0xab, 0x63, 0x3b, 0xf0, 0xd8, 0x29, 0x51,
		0x4a, 0x4b, 0x35, 0x0d, 0xb7, 0x42, 0x9e, 0xdf, 0xba, 0x9e, 0x88, 0x7a, 0x33, 0xa5, 0xa6, 0x8b,
		0xd7, 0xe2, 0x90, 0x95, 0xf3, 0x3b, 0x92, 0x2e, 0x9b, 0x74, 0x2e, 0x57, 0xe8, 0x68, 0xbf, 0xfd,
		0xc0, 0x6c, 0x70, 0x7a, 0x8e, 0x4c, 0xf2, 0xa5, 0x21, 0x96, 0x75, 0x69, 0x0c, 0x49, 0x16, 0x58,
		0x32, 0xbe, 0x31, 0xcb, 0xe5, 0x53, 0x1a, 0x7f, 0x42, 0x0b, 0x30, 0xf4, 0xac, 0x4f, 0xb9, 0x87,
		0x28, 0xf7, 0x1d, 0x07, 0x73, 0x5f, 0x5c, 0xa3, 0xe4, 0xe9, 0x8b, 0x6b, 0xfa, 0xca, 0xaa, 0xb6,
		0x3c, 0xbb, 0xa4, 0x71, 0x38, 0x3a, 0x02, 0x89, 0x86, 0x71, 0x75, 0x27, 0xba, 0x1c, 0x50, 0xd1,
		0xa0, 0xee, 0x3f, 0x02, 0x89, 0x2b, 0xd8, 0xb8, 0x14, 0x9d, 0x84, 0xa9, 0xe8, 0x2d, 0x1c, 0x06,
		0x33, 0x90, 0xa4, 0xfe, 0x42, 0x00, 0xdc, 0x63, 0xea, 0x2d, 0x28, 0x05, 0x89, 0xb9, 0x55, 0x8d,
		0x0c, 0x05, 0x15, 0xb2, 0x4c, 0xaa, 0x57, 0x17, 0x2b, 0x73, 0x15, 0x35, 0x56, 0x7c, 0x10, 0x86,
		0x98, 0x13, 0xc8, 0x30, 0x09, 0xdd, 0xa0, 0xde, 0xc2, 0x1f, 0x39, 0x87, 0x22, 0x4a, 0x37, 0x96,
		0xcb, 0x15, 0x4d, 0x8d, 0x45, 0x3b, 0x39, 0xa1, 0x26, 0x8b, 0x3e, 0x64, 0xe5, 0x04, 0xef, 0xa6,
		0xc4, 0x57, 0xf1, 0xf7, 0x15, 0xc8, 0x48, 0x09, 0x1b, 0x49, 0x15, 0x8c, 0x46, 0xc3, 0xb9, 0xa2,
		0x1b, 0x0d, 0xcb, 0xf0, 0x79, 0x68, 0x00, 0x15, 0xcd, 0x12, 0xc9, 0xa0, 0x5d, 0x77, 0x53, 0x8c,
		0xff, 0x9c, 0x02, 0x6a, 0x67, 0xb2, 0xd7, 0x61, 0xa0, 0xf2, 0xb6, 0x1a, 0xf8, 0x19, 0x05, 0x46,
		0xa3, 0x19, 0x5e, 0x87, 0x79, 0x27, 0xde, 0x56, 0xf3, 0x7e, 0x18, 0x83, 0x91, 0x48, 0x5e, 0x37,
		0xa8, 0x75, 0xcf, 0xc1, 0xb8, 0x55, 0xc3, 0x4d, 0xd7, 0x09, 0xb0, 0x6d, 0xee, 0xe8, 0x0d, 0x7c,
		0x19, 0x37, 0x72, 0x45, 0x3a, 0x5d, 0xcc, 0x1c, 0x9c, 0x39, 0x4e, 0x2f, 0xb6, 0x71, 0x4b, 0x04,
		0x56, 0x9a, 0x58, 0x9c, 0xaf, 0x2c, 0x57, 0x57, 0xd7, 0x2b, 0x2b, 0x73, 0x4f, 0xeb, 0x1b, 0x2b,
		0xef, 0x5c, 0x59, 0x7d, 0x72, 0x45, 0x53, 0xad, 0x0e, 0xb5, 0xb7, 0x70, 0xc0, 0x57, 0x41, 0xed,
		0x34, 0x0a, 0x1d, 0x86, 0x5e, 0x66, 0xa9, 0xb7, 0xa0, 0x09, 0x18, 0x5b, 0x59, 0xd5, 0xd7, 0x16,
		0xe7, 0x2b, 0x7a, 0xe5, 0xc2, 0x85, 0xca, 0xdc, 0xfa, 0x1a, 0xdb, 0x4a, 0x87, 0xda, 0xeb, 0x91,
		0xa1, 0x5d, 0xfc, 0x74, 0x1c, 0x26, 0x7a, 0x58, 0x82, 0x66, 0x79, 0x16, 0xcf, 0x36, 0x16, 0xa7,
		0x07, 0xb1, 0x7e, 0x9a, 0xe4, 0x09, 0x55, 0xc3, 0x0b, 0x78, 0xd2, 0x7f, 0x17, 0x10, 0x2f, 0xd9,
		0x81, 0xb5, 0x65, 0x61, 0x8f, 0x9f, 0x3c, 0xb0, 0xd4, 0x7e, 0xac, 0x2d, 0x67, 0x87, 0x0f, 0xf7,
		0x02, 0x72, 0x1d, 0xdf, 0x0a, 0xac, 0xcb, 0x58, 0xb7, 0x6c, 0x71, 0x4c, 0x41, 0x52, 0xfd, 0x84,
		0xa6, 0x8a, 0x92, 0x45, 0x3b, 0x08, 0xb5, 0x6d, 0x5c, 0x37, 0x3a, 0xb4, 0xc9, 0x34, 0x1e, 0xd7,
		0x54, 0x51, 0x12, 0x6a, 0x9f, 0x80, 0x6c, 0xcd, 0x69, 0x91, 0xc4, 0x89, 0xe9, 0x91, 0x55, 0x43,
		0xd1, 0x32, 0x4c, 0x16, 0xaa, 0xf0, 0xcc, 0xb6, 0x7d, 0x3e, 0x92, 0xd5, 0x32, 0x4c, 0xc6, 0x54,
		0x4e, 0xc2, 0x98, 0x51, 0xaf, 0x7b, 0x84, 0x5c, 0x10, 0xb1, 0x5c, 0x7d, 0x34, 0x14, 0x53, 0xc5,
		0xfc, 0x45, 0x48, 0x09, 0x3f, 0x90, 0xe5, 0x99, 0x78, 0x42, 0x77, 0xd9, 0x29, 0x55, 0xec, 0x54,
		0x5a, 0x4b, 0xd9, 0xa2, 0xf0, 0x04, 0x64, 0x2d, 0x5f, 0x6f, 0x1f, 0x97, 0xc6, 0x8e, 0xc7, 0x4e,
		0xa5, 0xb4, 0x8c, 0xe5, 0x87, 0xe7, 0x63, 0xc5, 0x97, 0x62, 0x30, 0x1a, 0x3d, 0xee, 0x45, 0xf3,
		0x90, 0x6a, 0x38, 0x26, 0xbd, 0xd1, 0xe0, 0x77, 0x0d, 0xa7, 0xfa, 0x9c, 0x10, 0x4f, 0x2f, 0x71,
		0x7d, 0x2d, 0x44, 0xe6, 0xff, 0x52, 0x81, 0x94, 0x10, 0xa3, 0x43, 0xfc, 0x76, 0x86, 0xd0, 0x25,
		0xcb, 0x31, 0x55, 0x61, 0x37, 0x34, 0x44, 0xee, 0xbb, 0x86, 0x4d, 0x43, 0x80, 0xcb, 0xc9, 0x33,
		0xe9, 0xd7, 0x06, 0x36, 0x6a, 0x74, 0x23, 0xe0, 0x34, 0x9b, 0xd8, 0x0e, 0x7c, 0xd1, 0xaf, 0x5c,
		0x3e, 0xc7, 0xc5, 0xe8, 0x1e, 0x18, 0x0f, 0x3c, 0xc3, 0x6a, 0x44, 0x74, 0xe9, 0xad, 0x98, 0xa6,
		0x8a, 0x82, 0x50, 0xb9, 0x04, 0x47, 0x04, 0x6f, 0x0d, 0x07, 0x86, 0xb9, 0x8d, 0x6b, 0x6d, 0xd0,
		0x10, 0x3d, 0x4b, 0x3c, 0xcc, 0x15, 0xe6, 0x79, 0xb9, 0xc0, 0x16, 0x7f, 0xa0, 0xc0, 0xb8, 0xd8,
		0xba, 0xd4, 0x42, 0x67, 0x2d, 0x03, 0xb4, 0x2f, 0x80, 0xb8, 0xbb, 0xba, 0x43, 0xb9, 0x0b, 0x37,
		0x3d, 0x1b, 0x82, 0x34, 0x89, 0x20, 0xdf, 0x04, 0x68, 0x97, 0xec, 0xeb, 0xb6, 0x02, 0x64, 0xf8,
		0x59, 0x3e, 0xbd, 0x10, 0x62, 0x9b, 0x5d, 0x60, 0x22, 0xb2, 0xc7, 0x41, 0x93, 0x90, 0xdc, 0xc4,
		0x75, 0xcb, 0xe6, 0x27, 0x8c, 0xec, 0x41, 0x9c, 0x5b, 0x26, 0xc2, 0x73, 0xcb, 0xf2, 0xcf, 0x2a,
		0x30, 0x21, 0x5d, 0x89, 0x09, 0x7b, 0xcb, 0x6a, 0xc7, 0x8e, 0xdb, 0x7f, 0x5c, 0x79, 0xe6, 0xd1,
		0xba, 0x15, 0x6c, 0xb7, 0x36, 0xa7, 0x4d, 0xa7, 0x39, 0xc3, 0xae, 0xc8, 0xda, 0x37, 0x5a, 0xf4,
		0x87, 0x79, 0xba, 0x8e, 0xed, 0xd3, 0x75, 0x47, 0xba, 0xdf, 0x3a, 0xdf, 0xfe, 0xf9, 0xc5, 0x58,
		0x7c, 0xa1, 0x5a, 0xfe, 0x4a, 0x2c, 0xbf, 0xc0, 0xea, 0xaa, 0x0a, 0xdf, 0x68, 0x78, 0xab, 0x81,
		0x4d, 0xd2, 0x5e, 0xf8, 0x4e, 0x0c, 0x6e, 0x93, 0xee, 0x5f, 0xa5, 0x9b, 0xb5, 0xee, 0x6b, 0xd8,
		0x7c, 0xef, 0x9b, 0xda, 0x7c, 0xdf, 0xdb, 0xb6, 0xd2, 0x3b, 0x21, 0x41, 0xf4, 0x51, 0x9f, 0x0d,
		0x7e, 0xee, 0x6b, 0x7f, 0xfe, 0x07, 0x45, 0x7a, 0x12, 0xd0, 0xfb, 0xe6, 0x92, 0x92, 0x94, 0xdf,
		0xdb, 0xf7, 0x8e, 0x51, 0x6d, 0x77, 0xa8, 0xff, 0xe6, 0x5d, 0x35, 0x76, 0xde, 0x33, 0xbe, 0x74,
		0x12, 0x4e, 0x47, 0x3a, 0xa8, 0xee, 0xb4, 0x5d, 0x40, 0x9e, 0x04, 0x79, 0xdd, 0xe1, 0xbe, 0x4c,
		0x87, 0xd2, 0x01, 0x7c, 0xb6, 0x02, 0x13, 0x5c, 0x59, 0xa7, 0xb7, 0x1e, 0x6c, 0x73, 0x86, 0x0e,
		0x3c, 0xf9, 0xca, 0x7d, 0xfd, 0x15, 0x9a, 0x1b, 0x69, 0xe3, 0x1c, 0x4a, 0xca, 0xd8, 0x16, 0xae,
		0xa4, 0xc1, 0xad, 0x11, 0x3e, 0x36, 0x0f, 0x62, 0xaf, 0x0f, 0xe3, 0x9f, 0x70, 0xc6, 0x09, 0x89,
		0x71, 0x8d, 0x43, 0x4b, 0x73, 0x30, 0x72, 0x3d, 0x5c, 0x7f, 0xca, 0xb9, 0xb2, 0x58, 0x26, 0x59,
		0x80, 0x31, 0x4a, 0xc2, 0x6e, 0xb4, 0xe9, 0x22, 0x73, 0x30, 0xcd, 0x9f, 0xbd, 0xc2, 0x26, 0xa6,
		0x51, 0x02, 0x9b, 0x0b, 0x51, 0xa5, 0x12, 0xd0, 0x8b, 0x9e, 0x1a, 0x36, 0x1b, 0x7d, 0x18, 0xbe,
		0xc7, 0x0d, 0x09, 0xf5, 0x4b, 0x4f, 0xc0, 0x24, 0xf9, 0x4d, 0xd7, 0x00, 0xd9, 0x92, 0xfe, 0xe7,
		0x7c, 0xb9, 0x1f, 0x7c, 0x80, 0xcd, 0x7d, 0x13, 0x21, 0x81, 0x64, 0x93, 0xd4, 0x8b, 0x75, 0x1c,
		0x04, 0xd8, 0xf3, 0x75, 0xa3, 0xd1, 0xcb, 0x3c, 0xe9, 0xa0, 0x24, 0xf7, 0xa9, 0x57, 0xa3, 0xbd,
		0xb8, 0xc0, 0x90, 0xb3, 0x8d, 0x46, 0x69, 0x03, 0x0e, 0xf7, 0x88, 0x8a, 0x01, 0x38, 0x3f, 0xcd,
		0x39, 0x27, 0xbb, 0x22, 0x83, 0xd0, 0x56, 0x41, 0xc8, 0xc3, 0xbe, 0x1c, 0x80, 0xf3, 0x57, 0x39,
		0x27, 0xe2, 0x58, 0xd1, 0xa5, 0x84, 0xf1, 0x22, 0x8c, 0x5f, 0xc6, 0xde, 0xa6, 0xe3, 0xf3, 0xc3,
		0xa9, 0x01, 0xe8, 0x3e, 0xc3, 0xe9, 0xc6, 0x38, 0x90, 0x9e, 0x56, 0x11, 0xae, 0x87, 0x21, 0xb5,
		0x65, 0x98, 0x78, 0x00, 0x8a, 0xcf, 0x72, 0x8a, 0x61, 0xa2, 0x4f, 0xa0, 0xb3, 0x90, 0xad, 0x3b,
		0x3c, 0x0d, 0xe8, 0x0f, 0xff, 0x1c, 0x87, 0x67, 0x04, 0x86, 0x53, 0xb8, 0x8e, 0xdb, 0x6a, 0x90,
		0x1c, 0xa1, 0x3f, 0xc5, 0xe7, 0x05, 0x85, 0xc0, 0x70, 0x8a, 0xeb, 0x70, 0xeb, 0x8b, 0x82, 0xc2,
		0x97, 0xfc, 0xf9, 0x18, 0x64, 0x1c, 0xbb, 0xb1, 0xe3, 0xd8, 0x83, 0x18, 0xf1, 0x05, 0xce, 0x00,
		0x1c, 0x42, 0x08, 0xce, 0x43, 0x7a, 0xd0, 0x8e, 0xf8, 0xd2, 0xab, 0x62, 0x78, 0x88, 0x1e, 0x58,
		0x80, 0x31, 0x31, 0x41, 0x59, 0x8e, 0x3d, 0x00, 0xc5, 0xaf, 0x71, 0x8a, 0x51, 0x09, 0xc6, 0x9b,
		0x11, 0x60, 0x3f, 0xa8, 0xe3, 0x41, 0x48, 0x5e, 0x12, 0xcd, 0xe0, 0x10, 0xee, 0xca, 0x4d, 0x6c,
		0x9b, 0xdb, 0x83, 0x31, 0x7c, 0x59, 0xb8, 0x52, 0x60, 0x08, 0xc5, 0x1c, 0x8c, 0x34, 0x0d, 0xcf,
		0xdf, 0x36, 0x1a, 0x03, 0x75, 0xc7, 0xaf, 0x73, 0x8e, 0x6c, 0x08, 0xe2, 0x1e, 0x69, 0xd9, 0xd7,
		0x43, 0xf3, 0x15, 0xe1, 0x11, 0x09, 0xc6, 0x87, 0x9e, 0x1f, 0xd0, 0x23, 0xc0, 0xeb, 0x61, 0xfb,
		0x0d, 0x31, 0xf4, 0x18, 0x76, 0x59, 0x66, 0x3c, 0x0f, 0x69, 0xdf, 0xba, 0x3a, 0x10, 0xcd, 0x6f,
		0x8a, 0x9e, 0xa6, 0x00, 0x02, 0x7e, 0x1a, 0x8e, 0xf4, 0x5c, 0x26, 0x06, 0x20, 0xfb, 0x2d, 0x4e,
		0x76, 0xa8, 0xc7, 0x52, 0xc1, 0xa7, 0x84, 0xeb, 0xa5, 0xfc, 0x6d, 0x31, 0x25, 0xe0, 0x0e, 0xae,
		0x2a, 0xd9, 0x98, 0xf9, 0xc6, 0xd6, 0xf5, 0x79, 0xed, 0xab, 0xc2, 0x6b, 0x0c, 0x1b, 0xf1, 0xda,
		0x3a, 0x1c, 0xe2, 0x8c, 0xd7, 0xd7, 0xaf, 0x5f, 0x13, 0x13, 0x2b, 0x43, 0x6f, 0x44, 0x7b, 0xf7,
		0xdd, 0x90, 0x0f, 0xdd, 0x29, 0x76, 0x00, 0xbe, 0xde, 0x34, 0xdc, 0x01, 0x98, 0xbf, 0xce, 0x99,
		0xc5, 0x8c, 0x1f, 0x6e, 0x21, 0xfc, 0x65, 0xc3, 0x25, 0xe4, 0x4f, 0x41, 0x4e, 0x90, 0xb7, 0x6c,
		0x0f, 0x9b, 0x4e, 0xdd, 0xb6, 0xae, 0xe2, 0xda, 0x00, 0xd4, 0xbf, 0xd3, 0xd1, 0x55, 0x1b, 0x12,
		0x9c, 0x30, 0x2f, 0x82, 0x1a, 0xe6, 0x2a, 0xba, 0xd5, 0x74, 0x1d, 0x2f, 0xe8, 0xc3, 0xf8, 0x0d,
		0xd1, 0x53, 0x21, 0x6e, 0x91, 0xc2, 0x4a, 0x15, 0x18, 0xa5, 0x8f, 0x83, 0x86, 0xe4, 0x37, 0x39,
		0xd1, 0x48, 0x1b, 0xc5, 0x27, 0x0e, 0xd3, 0x69, 0xba, 0x86, 0x37, 0xc8, 0xfc, 0xf7, 0x2d, 0x31,
		0x71, 0x70, 0x08, 0x9f, 0x38, 0x82, 0x1d, 0x17, 0x93, 0xd5, 0x7e, 0x00, 0x86, 0x6f, 0x8b, 0x89,
		0x43, 0x60, 0x38, 0x85, 0x48, 0x18, 0x06, 0xa0, 0xf8, 0x5d, 0x41, 0x21, 0x30, 0x84, 0xe2, 0x5d,
		0xed, 0x85, 0xd6, 0xc3, 0x75, 0xcb, 0x0f, 0x3c, 0xb6, 0xef, 0x38, 0x98, 0xea, 0x3b, 0xaf, 0x46,
		0x93, 0x30, 0x4d, 0x82, 0x96, 0x2e, 0xc2, 0x58, 0x47, 0x8a, 0x81, 0xfa, 0xbd, 0x35, 0x92, 0x7b,
		0xdf, 0x6b, 0x7c, 0x32, 0x8a, 0x66, 0x18, 0xa5, 0x25, 0xd2, 0xef, 0xd1, 0x3c, 0xa0, 0x3f, 0xd9,
		0x07, 0x5e, 0x0b, 0xbb, 0x3e, 0x92, 0x06, 0x94, 0x2e, 0xc0, 0x48, 0x24, 0x07, 0xe8, 0x4f, 0xf5,
		0x41, 0x4e, 0x95, 0x95, 0x53, 0x80, 0xd2, 0x83, 0x90, 0x20, 0xeb, 0x79, 0x7f, 0xf8, 0x87, 0x38,
		0x9c, 0xaa, 0x97, 0x1e, 0x81, 0x94, 0x58, 0xc7, 0xfb, 0x43, 0xff, 0x3f, 0x87, 0x86, 0x10, 0x02,
		0x17, 0x6b, 0x78, 0x7f, 0xf8, 0x87, 0x05, 0x5c, 0x40, 0x08, 0x7c, 0x70, 0x17, 0x7e, 0xf7, 0xa3,
		0x09, 0x3e, 0x0f, 0x0b, 0xdf, 0x9d, 0x87, 0x61, 0xbe, 0x78, 0xf7, 0x47, 0x7f, 0x84, 0x57, 0x2e,
		0x10, 0xa5, 0x87, 0x20, 0x39, 0xa0, 0xc3, 0x7f, 0x8e, 0x43, 0x99, 0x7e, 0x69, 0x0e, 0x32, 0xd2,
		0x82, 0xdd, 0x1f, 0xfe, 0xf3, 0x1c, 0x2e, 0xa3, 0x88, 0xe9, 0x7c, 0xc1, 0xee, 0x4f, 0xf0, 0x0b,
		0xc2, 0x74, 0x8e, 0x20, 0x6e, 0x13, 0x6b, 0x75, 0x7f, 0xf4, 0xc7, 0x84, 0xd7, 0x05, 0xa4, 0xf4,
		0x18, 0xa4, 0xc3, 0xf9, 0xb7, 0x3f, 0xfe, 0x17, 0x39, 0xbe, 0x8d, 0x21, 0x1e, 0x90, 0xe6, 0xff,
		0xfe, 0x14, 0xbf, 0x24, 0x3c, 0x20, 0xa1, 0xc8, 0x30, 0xea, 0x5c, 0xd3, 0xfb, 0x33, 0x7d, 0x5c,
		0x0c, 0xa3, 0x8e, 0x25, 0x9d, 0xf4, 0x26, 0x9d, 0x06, 0xfb, 0x53, 0xfc, 0xb2, 0xe8, 0x4d, 0xaa,
		0x4f, 0xcc, 0xe8, 0x5c, 0x24, 0xfb, 0x73, 0x7c, 0x42, 0x98, 0xd1, 0xb1, 0x46, 0x96, 0xaa, 0x80,
		0xba, 0x17, 0xc8, 0xfe, 0x7c, 0x9f, 0xe4, 0x7c, 0xe3, 0x5d, 0xeb, 0x63, 0xe9, 0x49, 0x38, 0xd4,
		0x7b, 0x71, 0xec, 0xcf, 0xfa, 0xa9, 0xd7, 0x3a, 0xb6, 0x33, 0xf2, 0xda, 0x58, 0x5a, 0x6f, 0xcf,
		0xb2, 0xf2, 0xc2, 0xd8, 0x9f, 0xf6, 0xd3, 0xaf, 0x45, 0x27, 0x5a, 0x79, 0x5d, 0x2c, 0xcd, 0x02,
		0xb4, 0xd7, 0xa4, 0xfe, 0x5c, 0x9f, 0xe1, 0x5c, 0x12, 0x88, 0x0c, 0x0d, 0xbe, 0x24, 0xf5, 0xc7,
		0x7f, 0x56, 0x0c, 0x0d, 0x8e, 0x20, 0x43, 0x43, 0xac, 0x46, 0xfd, 0xd1, 0x9f, 0x13, 0x43, 0x43,
		0x40, 0x4a, 0xe7, 0x21, 0x65, 0xb7, 0x1a, 0x0d, 0x12, 0x5b, 0xe8, 0xe0, 0x17, 0xb9, 0x72, 0xff,
		0xf8, 0x3a, 0x07, 0x0b, 0x40, 0xe9, 0x41, 0x48, 0xe2, 0xe6, 0x26, 0xae, 0xf5, 0x43, 0xfe, 0xf8,
		0x75, 0x31, 0x9f, 0x10, 0xed, 0xd2, 0x63, 0x00, 0x6c, 0x33, 0x4d, 0xef, 0xe6, 0xfa, 0x60, 0xff,
		0xe9, 0x75, 0xfe, 0x8e, 0x48, 0x1b, 0xd2, 0x26, 0x60, 0x6f, 0x9c, 0x1c, 0x4c, 0xf0, 0x6a, 0x94,
		0x80, 0x6e, 0xc0, 0x1f, 0x86, 0xe1, 0x67, 0x7d, 0xc7, 0x0e, 0x8c, 0x7a, 0x3f, 0xf4, 0x3f, 0x73,
		0xb4, 0xd0, 0x27, 0x0e, 0x6b, 0x3a, 0x1e, 0x0e, 0x8c, 0xba, 0xdf, 0x0f, 0xfb, 0x2f, 0x1c, 0x1b,
		0x02, 0x08, 0xd8, 0x34, 0xfc, 0x60, 0x90, 0x76, 0xff, 0xab, 0x00, 0x0b, 0x00, 0x31, 0x9a, 0xfc,
		0xbe, 0x84, 0x77, 0xfa, 0x61, 0x7f, 0x22, 0x8c, 0xe6, 0xfa, 0xa5, 0x47, 0x20, 0x4d, 0x7e, 0xb2,
		0xf7, 0xa6, 0xfa, 0x80, 0xff, 0x8d, 0x83, 0xdb, 0x08, 0x52, 0xb3, 0x1f, 0xd4, 0x02, 0xab, 0xbf,
		0xb3, 0xf7, 0x78, 0x4f, 0x0b, 0xfd, 0xd2, 0x2c, 0x64, 0xfc, 0xa0, 0x56, 0x6b, 0xf1, 0x8c, 0xa6,
		0x0f, 0xfc, 0xdf, 0x5f, 0x0f, 0x37, 0xb9, 0x21, 0xa6, 0xbc, 0xd1, 0x75, 0xb4, 0xd7, 0xf3, 0xac,
		0x14, 0x16, 0x9c, 0x05, 0x87, 0x9d, 0x92, 0x3e, 0x53, 0xec, 0x7f, 0x04, 0x07, 0xff, 0x79, 0x0a,
		0x46, 0x79, 0xb6, 0xb5, 0xc3, 0x8f, 0xe2, 0x6e, 0x35, 0x0d, 0xaf, 0xd9, 0x98, 0x76, 0xbc, 0xfa,
		0x74, 0xad, 0xb1, 0xe5, 0x19, 0x4d, 0x7c, 0xc5, 0xf1, 0x2e, 0xe5, 0x0f, 0x3c, 0x0b, 0xcd, 0x5f,
		0xdf, 0x71, 0x5f, 0x31, 0x80, 0x4c, 0xc5, 0xf3, 0x1c, 0x6f, 0x2d, 0x30, 0x82, 0x96, 0x8f, 0x4e,
		0x42, 0xcc, 0xb9, 0xc4, 0xae, 0x06, 0xcb, 0x87, 0xf7, 0x76, 0x0b, 0x13, 0x3b, 0x46, 0xb3, 0x51,
		0x2a, 0x3a, 0x97, 0xee, 0x75, 0x9a, 0x56, 0x80, 0x9b, 0x6e, 0xb0, 0x53, 0xd4, 0x62, 0xce, 0x25,
		0x74, 0x16, 0x86, 0xf9, 0xcb, 0x08, 0xec, 0x9c, 0xb9, 0x7c, 0xdb, 0xde, 0x6e, 0x21, 0xc7, 0xb4,
		0x79, 0x81, 0x0c, 0x11, 0xca, 0xa5, 0xc4, 0x4f, 0x5e, 0x2c, 0x28, 0xc5, 0xe7, 0x60, 0x7c, 0x8e,
		0xc4, 0xaf, 0x65, 0x63, 0xef, 0x71, 0xc3, 0xab, 0x5d, 0x21, 0x93, 0xcd, 0xdd, 0x10, 0xaf, 0xbb,
		0x2d, 0xf6, 0xce, 0x52, 0x39, 0xb7, 0xb7, 0x5b, 0x98, 0x64, 0x74, 0x75, 0xb7, 0x25, 0x53, 0x11,
		0x25, 0xa2, 0x6b, 0xba, 0x2d, 0x5e, 0xb5, 0xa4, 0x6b, 0x76, 0xe8, 0x9a, 0x6e, 0x8b, 0x57, 0xf9,
		0x77, 0x31, 0x18, 0xbf, 0x20, 0x7c, 0xb8, 0x6c, 0xd8, 0xd6, 0x16, 0xf6, 0x03, 0x74, 0x5a, 0x7e,
		0x65, 0xac, 0x7c, 0x64, 0x6f, 0xb7, 0x70, 0x2b, 0x23, 0x22, 0x52, 0x99, 0x89, 0x5d, 0x2c, 0x9d,
		0x85, 0xe1, 0xcb, 0xd8, 0xe3, 0x97, 0x26, 0x1d, 0xad, 0xe6, 0x05, 0x91, 0x56, 0x73, 0x19, 0x6a,
		0x41, 0xda, 0x14, 0xed, 0xe5, 0xaf, 0x95, 0x3f, 0x34, 0xdd, 0xb3, 0x77, 0xa7, 0xbb, 0x6c, 0x9c,
		0x0e, 0x3d, 0x45, 0x5f, 0xae, 0x28, 0x4f, 0xed, 0xed, 0x16, 0xf2, 0xbc, 0xb5, 0xa2, 0x44, 0xae,
		0xb4, 0x5d, 0x53, 0x7e, 0x0b, 0x46, 0xa3, 0x60, 0xa4, 0x42, 0xfc, 0x12, 0xde, 0xe1, 0xef, 0x85,
		0x91, 0x9f, 0xe8, 0xd1, 0xf6, 0x7b, 0x8f, 0x0a, 0xbd, 0xd3, 0xe9, 0x6d, 0x56, 0x57, 0x77, 0xf1,
		0xd7, 0x1e, 0x4b, 0xb1, 0x73, 0x0a, 0xf7, 0xf0, 0x17, 0x26, 0x60, 0x64, 0xd9, 0xa9, 0xe1, 0xc6,
		0xcd, 0xf6, 0xee, 0x16, 0xa4, 0x43, 0x43, 0xf9, 0xeb, 0x84, 0xa7, 0x06, 0xf5, 0xae, 0xec, 0xce,
		0x50, 0x2d, 0xe2, 0xce, 0x50, 0x8a, 0x9e, 0x93, 0x7b, 0x91, 0xbd, 0xdb, 0x7f, 0xff, 0x3e, 0xf5,
		0x44, 0xfc, 0x70, 0xe3, 0x3d, 0x88, 0xca, 0x91, 0x5c, 0x97, 0x7d, 0xbe, 0x55, 0x3e, 0xbe, 0xb7,
		0x5b, 0xb8, 0x8d, 0xe1, 0xa5, 0x42, 0x99, 0x21, 0x92, 0x20, 0x3f, 0x02, 0x69, 0x0f, 0x6f, 0x61,
		0x0f, 0xdb, 0xfc, 0x23, 0x95, 0x74, 0xb9, 0xb0, 0xb7, 0x5b, 0x38, 0xca, 0x18, 0xc2, 0x22, 0x3f,
		0x62, 0x42, 0x28, 0x26, 0xbd, 0xd2, 0xb0, 0x4c, 0x6c, 0xfb, 0xfc, 0xed, 0x6d, 0xb9, 0x57, 0x78,
		0x41, 0xa4, 0x57, 0xb8, 0x0c, 0xbd, 0x07, 0x86, 0xe8, 0x7b, 0x96, 0x3e, 0xff, 0xd0, 0xe0, 0xae,
		0x81, 0x5c, 0xb5, 0xbe, 0xe3, 0xe2, 0xf2, 0xd1, 0xbd, 0xdd, 0xc2, 0x61, 0x56, 0x03, 0xa3, 0x90,
		0x2b, 0xe0, 0xac, 0x84, 0x9f, 0xbd, 0xa7, 0xc9, 0xbf, 0x57, 0xb9, 0x31, 0x7e, 0x46, 0x11, 0xe1,
		0x67, 0x22, 0xb4, 0x06, 0xe3, 0x9b, 0x78, 0xcb, 0xf1, 0xb0, 0xee, 0x7a, 0xd8, 0xf5, 0x1c, 0x13,
		0xfb, 0xec, 0xa5, 0xc7, 0x74, 0xf9, 0x1d, 0x7b, 0xbb, 0x85, 0x22, 0xc3, 0x77, 0xa9, 0xc8, 0x54,
		0x2a, 0x2b, 0xad, 0x86, 0x85, 0xe8, 0x31, 0x92, 0x9e, 0x85, 0x6c, 0xf4, 0xed, 0x41, 0xb9, 0x33,
		0x7a, 0xd3, 0x48, 0x10, 0x54, 0x05, 0xd5, 0xd8, 0x0a, 0xb0, 0x27, 0x1b, 0x45, 0x3f, 0xb7, 0x29,
		0xdf, 0xb9, 0xb7, 0x5b, 0x38, 0xc1, 0x68, 0x3a, 0x35, 0x64, 0xb2, 0x31, 0x5a, 0x28, 0x99, 0xf4,
		0x04, 0x20, 0xd1, 0x08, 0xc7, 0x0f, 0x04, 0xe7, 0x08, 0xe5, 0x3c, 0xb9, 0xb7, 0x5b, 0xb8, 0x3d,
		0xda, 0xd0, 0xb6, 0x8e, 0xcc, 0xca, 0x5d, 0x55, 0x6d, 0x97, 0x92, 0xd0, 0x95, 0x09, 0x47, 0x3b,
		0x43, 0x77, 0x1f, 0x26, 0x19, 0x44, 0xfa, 0x80, 0xb7, 0x45, 0x62, 0x1a, 0xeb, 0xec, 0x83, 0x2e,
		0x95, 0x48, 0x1f, 0xb0, 0xf6, 0x4a, 0xa4, 0xff, 0x0b, 0x92, 0x4d, 0x12, 0x13, 0xf4, 0xa5, 0xcc,
		0xcc, 0x99, 0xbb, 0x07, 0x8a, 0x1b, 0xfa, 0x54, 0xce, 0xef, 0xed, 0x16, 0x0e, 0xf1, 0x45, 0x8e,
		0x08, 0xe4, 0x8a, 0x18, 0x29, 0x6a, 0x01, 0x18, 0x41, 0xe0, 0x59, 0x9b, 0xad, 0x80, 0xbe, 0xbe,
		0x49, 0x42, 0xff, 0x81, 0x81, 0xaa, 0x98, 0x0d, 0x61, 0x6c, 0x9a, 0x90, 0xe2, 0xa2, 0xcd, 0x18,
		0x89, 0x8b, 0xb6, 0x18, 0xdd, 0x0f, 0x43, 0xdb, 0x56, 0xad, 0x86, 0x6d, 0xf6, 0xe2, 0xa7, 0x1c,
		0xe2, 0x4c, 0x1e, 0x09, 0x71, 0x26, 0xca, 0xbf, 0x18, 0xe7, 0x9f, 0x40, 0x9c, 0xe6, 0x1f, 0x88,
		0x74, 0x4d, 0xd4, 0x44, 0x1a, 0x99, 0xa8, 0x69, 0xae, 0xd8, 0x31, 0x2b, 0xc5, 0x6e, 0x64, 0x56,
		0xba, 0x0a, 0xe0, 0x1a, 0xc4, 0x13, 0x01, 0xf6, 0x7c, 0xbe, 0x26, 0x3e, 0x3c, 0xf0, 0x10, 0x9e,
		0xae, 0x86, 0xd8, 0x2e, 0x67, 0xb5, 0x69, 0xa3, 0x83, 0x28, 0x14, 0xe7, 0x1f, 0x84, 0x74, 0x88,
		0x47, 0xa7, 0xc4, 0x02, 0xc8, 0x1a, 0x8f, 0xf6, 0x76, 0x0b, 0xa3, 0x8c, 0xe8, 0x5e, 0xcb, 0x6e,
		0x58, 0x36, 0x2e, 0xf2, 0xa5, 0x2e, 0xef, 0xc1, 0x58, 0x47, 0xb5, 0x3d, 0xd6, 0xd3, 0xc5, 0xe8,
		0x7a, 0x7a, 0xff, 0x0d, 0x34, 0x49, 0x5a, 0x5a, 0xf3, 0x5f, 0x8a, 0x43, 0x92, 0xea, 0xa2, 0x73,
		0x90, 0xda, 0x34, 0x7c, 0xac, 0xb7, 0xbc, 0x06, 0x37, 0xf5, 0xd8, 0xde, 0x6e, 0xe1, 0x08, 0x1f,
		0x9d, 0xbc, 0x24, 0x32, 0x13, 0x13, 0xe1, 0x86, 0xd7, 0x40, 0xf3, 0x90, 0xbd, 0x82, 0xad, 0xfa,
		0x76, 0xe0, 0xeb, 0xed, 0x8f, 0x61, 0xcb, 0x27, 0xf6, 0x76, 0x0b, 0xc7, 0x18, 0x5a, 0x2e, 0x8d,
		0x74, 0x18, 0x2f, 0xa8, 0x1a, 0xc1, 0x36, 0x7a, 0x14, 0xa0, 0xee, 0x19, 0xee, 0x36, 0xe3, 0x88,
		0x77, 0x4e, 0x5d, 0xed, 0xb2, 0xc8, 0x3a, 0x42, 0xc5, 0x02, 0x6f, 0xf9, 0xba, 0xe1, 0x99, 0xdb,
		0xd6, 0x65, 0xf6, 0x86, 0x4d, 0x4a, 0xc6, 0xb7, 0xcb, 0x22, 0x78, 0xcb, 0x9f, 0x65, 0x52, 0x32,
		0xf3, 0x09, 0x3b, 0xe9, 0x5b, 0xe0, 0x7e, 0xab, 0xc9, 0xd7, 0x43, 0x69, 0xe6, 0xeb, 0xd4, 0x88,
		0xcc, 0x7c, 0xbc, 0x70, 0x8e, 0x97, 0xa1, 0x8b, 0x30, 0xca, 0xac, 0x0e, 0xf9, 0xe8, 0xb7, 0x4d,
		0xe5, 0xdb, 0xf7, 0x76, 0x0b, 0x05, 0xb9, 0x55, 0xbd, 0xd8, 0x46, 0x68, 0x91, 0xe0, 0xba, 0x59,
		0xa9, 0x56, 0xfe, 0x11, 0x18, 0xeb, 0x98, 0x27, 0x7a, 0x54, 0x34, 0x29, 0x57, 0x94, 0x96, 0xe0,
		0xc5, 0xdf, 0x53, 0x40, 0x0d, 0x73, 0x20, 0x0d, 0x3f, 0xd7, 0x22, 0x69, 0xda, 0x45, 0x18, 0x0d,
		0x6b, 0xd7, 0xa5, 0x84, 0x4d, 0xf2, 0x43, 0xb4, 0x3c, 0xe2, 0x87, 0xb0, 0x88, 0x7e, 0x8e, 0xb5,
		0x06, 0xe3, 0x6d, 0xdd, 0x68, 0x36, 0x27, 0xcd, 0xd8, 0x5d, 0x2a, 0x91, 0x19, 0x3b, 0x2c, 0x7d,
		0x82, 0x15, 0xf2, 0xfc, 0xf2, 0x67, 0x14, 0xc8, 0x77, 0xe5, 0x6f, 0xbe, 0x86, 0x7d, 0xd7, 0x21,
		0xf9, 0xc6, 0x16, 0xa4, 0x9b, 0x42, 0x18, 0xbe, 0xa0, 0x74, 0x03, 0x59, 0x60, 0x48, 0x12, 0x89,
		0xc3, 0x50, 0xca, 0x8d, 0xf9, 0x76, 0x02, 0x92, 0xb3, 0x75, 0x6c, 0xd3, 0x24, 0x77, 0xdb, 0xf1,
		0x83, 0xee, 0xb9, 0x93, 0x48, 0x23, 0x73, 0x27, 0x11, 0x10, 0x75, 0xd7, 0xf1, 0xf8, 0xa7, 0xfc,
		0xb2, 0x3a, 0x91, 0x46, 0xd4, 0xe9, 0x85, 0xc6, 0xc3, 0x90, 0x22, 0x30, 0xda, 0x2b, 0xf1, 0xce,
		0x51, 0x2f, 0x4a, 0x64, 0x58, 0xa8, 0x8e, 0x2a, 0x90, 0xa5, 0x23, 0x2a, 0xc0, 0x66, 0xd0, 0xf2,
		0xd8, 0x90, 0x8b, 0x0c, 0x7b, 0xb9, 0x54, 0xa6, 0x88, 0xc0, 0xe8, 0xca, 0x62, 0xf8, 0x64, 0x67,
		0x96, 0xec, 0x5a, 0x59, 0xa8, 0x3c, 0xba, 0xb2, 0x50, 0x11, 0x49, 0x1a, 0x4d, 0xb7, 0x45, 0xbf,
		0x26, 0x1e, 0xea, 0x4c, 0x1a, 0x79, 0x41, 0x64, 0xaa, 0xe2, 0x32, 0x82, 0xab, 0x73, 0x5c, 0x57,
		0xb2, 0x59, 0xef, 0x81, 0xe3, 0x32, 0x84, 0x21, 0xd5, 0xc4, 0x81, 0x51, 0x33, 0x02, 0x83, 0xa7,
		0x9b, 0xfb, 0x2d, 0xeb, 0xb4, 0xd3, 0xa6, 0x97, 0xb9, 0x32, 0x5b, 0x3c, 0x24, 0x97, 0x0a, 0x96,
		0x88, 0x4b, 0x85, 0x30, 0x7f, 0x9e, 0xbe, 0x15, 0xda, 0x46, 0x5e, 0xcf, 0xd8, 0xe3, 0x81, 0x63,
		0xc0, 0x10, 0x35, 0xc1, 0x47, 0xef, 0x82, 0x21, 0x83, 0xfe, 0xe2, 0xd1, 0x7a, 0xdb, 0x41, 0x16,
		0xcb, 0x6e, 0x67, 0xa8, 0x88, 0xdb, 0x99, 0x88, 0x57, 0xf1, 0x47, 0x31, 0xc8, 0xd2, 0x35, 0xe3,
		0xbf, 0xcb, 0x00, 0x27, 0x6b, 0x03, 0xcd, 0x9e, 0x74, 0x29, 0xce, 0xa5, 0xb5, 0xa1, 0x5d, 0x16,
		0x1d, 0x93, 0x44, 0x4c, 0x8d, 0x5a, 0x80, 0x11, 0xa6, 0x23, 0x0c, 0x62, 0xb1, 0x5e, 0xdc, 0xdb,
		0x2d, 0x4c, 0xc9, 0x14, 0x3d, 0x8c, 0xc9, 0xd2, 0x92, 0xe8, 0x4c, 0xf3, 0x7e, 0x05, 0x0e, 0x45,
		0x16, 0xe8, 0xf6, 0x2c, 0xb3, 0xd9, 0x3d, 0xcb, 0xdc, 0x31, 0xc8, 0x12, 0x7f, 0xdd, 0x33, 0xcc,
		0x99, 0x17, 0x13, 0x90, 0xe2, 0x77, 0x68, 0x3b, 0xe8, 0x13, 0x0a, 0xa0, 0xee, 0xb9, 0x0f, 0x9d,
		0xec, 0x37, 0xc1, 0xf1, 0x08, 0xc8, 0xff, 0x8f, 0x41, 0x67, 0xc2, 0xb0, 0xa5, 0xc5, 0x3b, 0xdf,
		0xff, 0x57, 0xaf, 0x7c, 0x3c, 0x56, 0x40, 0xc7, 0x66, 0xc4, 0xb1, 0xd4, 0x4c, 0x88, 0xf3, 0x67,
		0x84, 0xb5, 0xe8, 0xff, 0xc1, 0x58, 0x48, 0xc2, 0x03, 0x7b, 0x60, 0xab, 0x8e, 0x1d, 0x14, 0xf1,
		0x7e, 0xb1, 0x48, 0x2d, 0xb8, 0x0d, 0xe5, 0x7b, 0x5a, 0x40, 0x43, 0x1e, 0x7d, 0x58, 0x81, 0xd1,
		0x68, 0x57, 0xa1, 0xdb, 0x0f, 0xea, 0x0f, 0x51, 0xf5, 0xe9, 0x41, 0x3a, 0xad, 0xed, 0x8c, 0x13,
		0xd4, 0x94, 0xa3, 0xe8, 0x48, 0xdb, 0x14, 0x1a, 0x37, 0x92, 0x23, 0x9e, 0x83, 0x0c, 0x05, 0x73,
		0x27, 0x0c, 0x64, 0x45, 0x1f, 0x07, 0x4c, 0xd1, 0x5a, 0x73, 0xe8, 0x50, 0x57, 0xad, 0xb4, 0xf1,
		0xe5, 0xd9, 0xbf, 0x79, 0x79, 0xea, 0x96, 0x1f, 0xbe, 0x3c, 0xa5, 0xfc, 0xe4, 0xe5, 0x29, 0xe5,
		0xa7, 0x2f, 0x4f, 0x29, 0x2f, 0x5c, 0x9b, 0x52, 0xbe, 0x7c, 0x6d, 0x4a, 0xf9, 0xce, 0xb5, 0x29,
		0xe5, 0xbb, 0xd7, 0xa6, 0x94, 0xce, 0xa3, 0xca, 0xef, 0xfe, 0x68, 0x4a, 0x79, 0x26, 0x23, 0xd5,
		0x14, 0xbe, 0x28, 0xf8, 0x2b, 0x33, 0x30, 0xe6, 0x7a, 0xb8, 0x66, 0x99, 0xed, 0xff, 0x3f, 0x72,
		0x33, 0xce, 0x1f, 0xb3, 0x00, 0x73, 0xd5, 0x0d, 0x7e, 0xe0, 0x5a, 0xfc, 0x68, 0x1c, 0x60, 0x21,
		0x7c, 0x44, 0x57, 0xa1, 0xe0, 0xd2, 0x8d, 0x2c, 0xdd, 0xb8, 0xe9, 0x75, 0xb7, 0xa5, 0x37, 0x71,
		0xd3, 0xf1, 0x76, 0xf4, 0x2d, 0xcf, 0x30, 0xf9, 0xab, 0xb5, 0xca, 0x29, 0xa5, 0xfc, 0xc0, 0xde,
		0x6e, 0xe1, 0x3e, 0xbe, 0x8c, 0x1e, 0x0c, 0x90, 0x87, 0xdc, 0x51, 0x97, 0x6c, 0x84, 0xa9, 0xea,
		0x82, 0xdb, 0x5a, 0xa6, 0x8a, 0x17, 0xb8, 0x1e, 0x99, 0x33, 0x8d, 0x06, 0x7d, 0x6d, 0xd9, 0xf1,
		0xa4, 0x8f, 0x47, 0xe5, 0x39, 0x33, 0x5a, 0x1e, 0x99, 0x33, 0xc3, 0x22, 0xfe, 0x1f, 0x1d, 0x26,
		0x2e, 0x5b, 0xbe, 0xb5, 0xd9, 0xc0, 0x7a, 0x0d, 0x5f, 0xb6, 0x4c, 0xac, 0x37, 0x2c, 0x3f, 0xe0,
		0xd9, 0xeb, 0xa9, 0xbd, 0xdd, 0xc2, 0x1d, 0xfc, 0x90, 0xab, 0x5b, 0x29, 0xb2, 0xc9, 0xe6, 0xe5,
		0xf3, 0xb4, 0x78, 0xc9, 0xf2, 0x03, 0xf4, 0x6e, 0x98, 0xdc, 0x72, 0x3c, 0x13, 0xd3, 0xa6, 0xd2,
		0x3b, 0x98, 0x80, 0x68, 0xd0, 0x37, 0xc4, 0x53, 0xe5, 0xbb, 0xf6, 0x76, 0x0b, 0x77, 0xf2, 0x09,
		0xb9, 0x87, 0x96, 0xcc, 0x8d, 0xa8, 0xc2, 0x82, 0xdb, 0x9a, 0x0b, 0x8b, 0x8b, 0x7f, 0x9d, 0x04,
		0xb5, 0xf2, 0x3c, 0x36, 0x5b, 0xc4, 0x21, 0xa2, 0x4f, 0x5a, 0x90, 0x09, 0x3c, 0x83, 0x58, 0x47,
		0x3f, 0x6d, 0x60, 0x5f, 0x59, 0x9d, 0xd9, 0x27, 0x8e, 0x3b, 0xd1, 0xd3, 0xeb, 0x04, 0x4a, 0x3f,
		0x24, 0x90, 0xf7, 0x8b, 0x12, 0x61, 0x64, 0xcb, 0x16, 0x84, 0xda, 0xe8, 0x02, 0x8c, 0x04, 0x56,
		0x13, 0x3b, 0xad, 0x40, 0xb7, 0x6c, 0xbd, 0xc9, 0xbe, 0xbf, 0x89, 0xcb, 0x33, 0x7c, 0xa4, 0x38,
		0xb2, 0x8b, 0xe1, 0x25, 0x8b, 0xf6, 0xb2, 0x8f, 0xde, 0x0b, 0x59, 0xee, 0x5d, 0xd3, 0x69, 0xd9,
		0x01, 0xdf, 0x78, 0x9e, 0x1b, 0xd4, 0x7e, 0xe6, 0xfa, 0x39, 0x02, 0x65, 0xa9, 0x83, 0x94, 0x4e,
		0xc9, 0xbc, 0x1d, 0xdb, 0xde, 0x10, 0x84, 0x6a, 0x90, 0x31, 0xdd, 0x96, 0x1e, 0xfd, 0xa6, 0xf8,
		0xc4, 0x7e, 0x3b, 0x81, 0x70, 0x28, 0xc8, 0xde, 0x92, 0xf0, 0x11, 0x6f, 0x99, 0x6e, 0x4b, 0x74,
		0x52, 0x0d, 0x32, 0x75, 0xa9, 0x96, 0xe4, 0x81, 0xb5, 0x2c, 0xf4, 0xac, 0xa5, 0xbe, 0x4f, 0x2d,
		0xf5, 0xb0, 0x96, 0xfc, 0xa3, 0xa0, 0x76, 0xfa, 0xa3, 0x5f, 0x42, 0x94, 0x94, 0x37, 0x23, 0x57,
		0x00, 0xda, 0xf1, 0x80, 0xb2, 0x90, 0x5a, 0x59, 0xd5, 0xd7, 0xb5, 0xd9, 0xb9, 0x8a, 0x7a, 0x0b,
		0x1a, 0x05, 0x58, 0x5b, 0xaf, 0x54, 0xf9, 0xb3, 0x82, 0x26, 0x60, 0xec, 0x82, 0x36, 0xbb, 0x5c,
		0x79, 0x72, 0x55, 0x7b, 0x27, 0x17, 0xd2, 0x7f, 0x2c, 0x30, 0x57, 0xdd, 0xd0, 0x57, 0x57, 0x96,
		0x9e, 0xe6, 0xb2, 0x38, 0x91, 0x3d, 0x3e, 0xab, 0xcd, 0x3f, 0x39, 0xab, 0x55, 0xb8, 0x8c, 0xfe,
		0x7f, 0x86, 0x0b, 0x1b, 0x4b, 0x4b, 0xfc, 0x39, 0x59, 0xfc, 0x50, 0x1c, 0xc6, 0xab, 0x6c, 0xb2,
		0x93, 0x22, 0xdb, 0x04, 0xf0, 0xd8, 0xbc, 0xac, 0x5b, 0xfc, 0xbf, 0x48, 0x95, 0xe7, 0xaf, 0xed,
		0x16, 0xd2, 0x7c, 0xb6, 0x5e, 0x9c, 0xff, 0xf1, 0x6e, 0x61, 0xb2, 0xad, 0xd2, 0x76, 0x8b, 0x7c,
		0x9a, 0xda, 0x5d, 0x4a, 0x4f, 0x53, 0x19, 0x43, 0x8d, 0x64, 0x2a, 0x5b, 0xd8, 0x20, 0x89, 0xb5,
		0xde, 0xb0, 0x9a, 0x16, 0xdb, 0x07, 0x24, 0xe5, 0x38, 0x8e, 0x14, 0x47, 0x32, 0x15, 0x5e, 0xb2,
		0x44, 0x0a, 0x48, 0xca, 0xb4, 0x69, 0x04, 0xe6, 0xb6, 0xee, 0x5b, 0x57, 0x59, 0xca, 0x34, 0x22,
		0xa7, 0x4c, 0xed, 0xb2, 0x88, 0x21, 0x54, 0xbc, 0x66, 0x5d, 0xc5, 0xe8, 0xff, 0xc2, 0x38, 0x16,
		0xd1, 0xdd, 0x11, 0x8e, 0x27, 0x07, 0x1c, 0x0d, 0x72, 0xc2, 0xd7, 0xc5, 0x15, 0x49, 0xf8, 0x70,
		0x07, 0x92, 0xe7, 0x59, 0x5f, 0x8e, 0xc3, 0x64, 0x55, 0x2c, 0x3a, 0xab, 0x2e, 0xb6, 0x45, 0xc2,
		0x1a, 0xcd, 0x07, 0x95, 0x37, 0x9e, 0x0f, 0xc6, 0x6e, 0x2c, 0x1f, 0xec, 0x91, 0x39, 0xc7, 0xdf,
		0xdc, 0xcc, 0x39, 0xf1, 0x06, 0x33, 0xe7, 0xff, 0xdd, 0xfe, 0xff, 0x04, 0xc9, 0x03, 0x4f, 0x15,
		0xba, 0xe2, 0x5d, 0xde, 0x5a, 0xf5, 0xe8, 0x33, 0x41, 0xcb, 0xbb, 0x2a, 0x07, 0x87, 0xc2, 0x9e,
		0x9a, 0x6b, 0x38, 0x3e, 0x0e, 0x53, 0xa3, 0x2a, 0xa4, 0xc3, 0x12, 0xf4, 0x08, 0xc4, 0xc2, 0xb1,
		0x73, 0xfa, 0xda, 0x6e, 0x21, 0x46, 0x07, 0x4d, 0xb6, 0x63, 0xb0, 0xf0, 0x5b, 0xc5, 0xe8, 0x20,
		0x89, 0x59, 0x35, 0x71, 0x91, 0x14, 0x87, 0xcc, 0x86, 0xb6, 0xe4, 0x8b, 0x68, 0x78, 0x0f, 0xa4,
		0xc3, 0xd4, 0x84, 0x72, 0x67, 0xce, 0x1c, 0x3f, 0xb8, 0x95, 0x8e, 0x27, 0xe7, 0xdb, 0x21, 0x38,
		0x12, 0x2d, 0xa1, 0x14, 0x6d, 0x40, 0xa2, 0xe5, 0x35, 0xfc, 0xf0, 0x5f, 0x59, 0xf4, 0xa6, 0x96,
		0x2c, 0x22, 0xbf, 0xe5, 0xad, 0x3b, 0x41, 0x47, 0xb6, 0xee, 0x44, 0x20, 0x77, 0x4d, 0xfc, 0x2d,
		0xe9, 0x9a, 0xbc, 0x0f, 0xf1, 0x0d, 0x6d, 0xe9, 0x0d, 0x3a, 0x1d, 0x9d, 0x86, 0x04, 0xdd, 0x37,
		0x77, 0x9d, 0x48, 0x74, 0xee, 0x83, 0xa9, 0x1a, 0xef, 0xa3, 0xaf, 0xc6, 0x61, 0x64, 0xb1, 0x69,
		0xd4, 0xf1, 0x4d, 0xeb, 0x25, 0x1d, 0x86, 0x2c, 0x5a, 0x21, 0xef, 0xa7, 0xfd, 0x36, 0xf8, 0x11,
		0xab, 0xd8, 0x53, 0xe4, 0x42, 0x89, 0x16, 0x47, 0x2f, 0x94, 0xa8, 0xe8, 0x26, 0xf4, 0x57, 0x0b,
		0x92, 0xd4, 0x9e, 0x37, 0xb3, 0xc7, 0xb2, 0x83, 0xf6, 0xd8, 0x37, 0xe3, 0x30, 0x3a, 0x6f, 0x04,
		0x86, 0x8f, 0x83, 0x9b, 0xd5, 0x65, 0x18, 0x86, 0x6b, 0xac, 0x46, 0x7e, 0xe4, 0xb9, 0xdf, 0xae,
		0x2b, 0x6a, 0x97, 0x78, 0x94, 0xdd, 0xca, 0x79, 0x22, 0x6e, 0xe5, 0xb2, 0x9b, 0x32, 0xd0, 0x86,
		0xb9, 0x4d, 0xe8, 0x61, 0x48, 0x99, 0x46, 0x80, 0xeb, 0x8e, 0xb7, 0xd3, 0x7d, 0x0c, 0x2f, 0x4a,
		0x22, 0xa7, 0x47, 0x42, 0x18, 0x5e, 0x87, 0xc7, 0x06, 0xba, 0x0e, 0xe7, 0xdd, 0xf6, 0xb7, 0x31,
		0x18, 0xbe, 0xc0, 0x16, 0x7e, 0x74, 0x1f, 0x24, 0xd9, 0xff, 0xc8, 0x52, 0x68, 0xf2, 0x2b, 0xdd,
		0x46, 0x51, 0x71, 0xe4, 0x36, 0x8a, 0x4a, 0xae, 0xb3, 0x4a, 0x7a, 0x67, 0xe7, 0x39, 0x9b, 0xc6,
		0xa6, 0xd5, 0xb0, 0x82, 0x1d, 0xea, 0xcd, 0x58, 0xe4, 0xce, 0xae, 0x5d, 0x18, 0xbd, 0xb3, 0x6b,
		0xcb, 0x51, 0x5d, 0x3a, 0x8a, 0x63, 0x97, 0xe4, 0xf7, 0xee, 0x77, 0x1e, 0xc0, 0x9a, 0xf5, 0x36,
		0x1e, 0xc6, 0x7d, 0x3e, 0x01, 0x63, 0xdc, 0x8a, 0xf0, 0x84, 0xe7, 0x0d, 0x8e, 0xcd, 0x68, 0x16,
		0x19, 0x7b, 0x6b, 0xb2, 0xc8, 0xa7, 0x21, 0xc5, 0xfe, 0xab, 0x91, 0x55, 0xe3, 0x09, 0xc9, 0xa3,
		0xd7, 0x76, 0x0b, 0xc3, 0x8b, 0x44, 0x46, 0x2b, 0x40, 0xa2, 0x38, 0x42, 0x7f, 0x44, 0xba, 0x53,
		0xef, 0x20, 0x1f, 0xa6, 0x42, 0x46, 0xcd, 0xf3, 0x4c, 0x9f, 0x77, 0xdf, 0xd4, 0xc1, 0xdd, 0x27,
		0x77, 0x98, 0x40, 0x46, 0x3a, 0x4c, 0x08, 0x91, 0x23, 0x45, 0x46, 0xf2, 0xc0, 0x8b, 0xd1, 0x8e,
		0x3e, 0x79, 0x1b, 0x23, 0xe4, 0x0f, 0x15, 0x50, 0xb9, 0x35, 0xfe, 0x9b, 0x15, 0x22, 0x35, 0x48,
		0x7b, 0x9c, 0xaa, 0x5f, 0xd2, 0xd1, 0xe1, 0x08, 0x79, 0xf2, 0x0d, 0x29, 0x3a, 0x62, 0x84, 0x4b,
		0xb9, 0xfd, 0xdf, 0x50, 0x20, 0xab, 0x61, 0x69, 0xce, 0x67, 0xb6, 0xc7, 0x6e, 0xd4, 0xf6, 0xb7,
		0x78, 0xc9, 0xe0, 0x56, 0xef, 0xb0, 0xff, 0xb8, 0x18, 0xc8, 0xc7, 0xae, 0xd7, 0x5f, 0x6d, 0xf1,
		0xfb, 0xbb, 0x05, 0xe5, 0x3a, 0xab, 0x3e, 0xf3, 0xc7, 0x29, 0x18, 0xe6, 0x14, 0xc8, 0x81, 0x04,
		0xd9, 0x95, 0xa0, 0x7b, 0xfa, 0x55, 0x25, 0xed, 0x5d, 0xf2, 0x7d, 0xed, 0x2a, 0xe6, 0xe8, 0xb1,
		0x1e, 0x2a, 0x8e, 0xcc, 0xf0, 0xca, 0x67, 0x1c, 0x17, 0xdb, 0x25, 0xe5, 0x6e, 0xe4, 0x43, 0x92,
		0x26, 0xd7, 0xa8, 0x2f, 0xc9, 0xbe, 0x07, 0x98, 0xfb, 0x64, 0xe9, 0x47, 0x68, 0x9d, 0x13, 0xc5,
		0xd1, 0xb0, 0x4e, 0x93, 0x94, 0x93, 0x4a, 0x9b, 0x90, 0x20, 0xb9, 0x2d, 0x2a, 0xf6, 0x4f, 0x7c,
		0xf3, 0x27, 0x0f, 0x8e, 0xd3, 0xf6, 0x81, 0x69, 0x77, 0x1b, 0x49, 0x4e, 0x4c, 0xaa, 0xfb, 0x3f,
		0x00, 0x84, 0x91, 0xfd, 0x13, 0xb3, 0x81, 0x2a, 0x1d, 0x70, 0x70, 0x14, 0x0b, 0xb4, 0xce, 0x23,
		0xc5, 0xc9, 0xb0, 0x4e, 0xf6, 0x7f, 0xd4, 0x44, 0xd5, 0xf7, 0x29, 0xc8, 0x87, 0x21, 0x96, 0x1f,
		0xa2, 0x3b, 0x06, 0x49, 0x1f, 0x07, 0x6f, 0x6f, 0x9e, 0xd6, 0x3d, 0x59, 0x1c, 0x0b, 0xeb, 0x66,
		0x59, 0x25, 0x69, 0xf1, 0xfb, 0x14, 0xc8, 0x32, 0x5a, 0xde, 0xe8, 0xc1, 0xea, 0x1e, 0xb4, 0xd9,
		0xfc, 0x6c, 0xba, 0x78, 0xa8, 0xb3, 0xd9, 0xa1, 0x05, 0xf7, 0x29, 0xe8, 0x72, 0x3b, 0x83, 0xb9,
		0x73, 0xa0, 0x24, 0x6c, 0xf0, 0xa6, 0x1f, 0xa5, 0xf5, 0xdf, 0x5a, 0x54, 0xc3, 0xfa, 0x79, 0x62,
		0x46, 0xda, 0xfe, 0x41, 0x05, 0x46, 0x38, 0x31, 0x6f, 0xfc, 0x80, 0xd5, 0x0f, 0xda, 0x7a, 0x7e,
		0x49, 0x50, 0x3c, 0xdc, 0xd9, 0xfa, 0xb6, 0x11, 0xf7, 0x29, 0xa8, 0x09, 0x49, 0x3a, 0xa1, 0xec,
		0x7b, 0x2c, 0x2f, 0xcf, 0x91, 0xf9, 0x3b, 0x0e, 0x56, 0xda, 0x77, 0x48, 0x79, 0x98, 0x55, 0xf8,
		0x26, 0x1e, 0xcc, 0xff, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x87, 0xb5, 0x30, 0xca, 0x7d, 0x5e,
		0x00, 0x00,
	}
	r := bytes.NewReader(gzipped)
	gzipr, err := gzip.NewReader(r)
	if err != nil {
		panic(err)
	}
	ungzipped, err := ioutil.ReadAll(gzipr)
	if err != nil {
		panic(err)
	}
	if err := proto.Unmarshal(ungzipped, d); err != nil {
		panic(err)
	}
	return d
}
func (this *CPUOptions) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CPUOptions)
	if !ok {
		that2, ok := that.(CPUOptions)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CPUOptions")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CPUOptions but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CPUOptions but is not nil && this == nil")
	}
	return nil
}
func (this *CPUOptions) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CPUOptions)
	if !ok {
		that2, ok := that.(CPUOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *GPUOptions) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GPUOptions)
	if !ok {
		that2, ok := that.(GPUOptions)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GPUOptions")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GPUOptions but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GPUOptions but is not nil && this == nil")
	}
	if this.PerProcessGpuMemoryFraction != that1.PerProcessGpuMemoryFraction {
		return fmt.Errorf("PerProcessGpuMemoryFraction this(%v) Not Equal that(%v)", this.PerProcessGpuMemoryFraction, that1.PerProcessGpuMemoryFraction)
	}
	if this.AllocatorType != that1.AllocatorType {
		return fmt.Errorf("AllocatorType this(%v) Not Equal that(%v)", this.AllocatorType, that1.AllocatorType)
	}
	if this.VisibleDeviceList != that1.VisibleDeviceList {
		return fmt.Errorf("VisibleDeviceList this(%v) Not Equal that(%v)", this.VisibleDeviceList, that1.VisibleDeviceList)
	}
	if this.ForceGpuCompatible != that1.ForceGpuCompatible {
		return fmt.Errorf("ForceGpuCompatible this(%v) Not Equal that(%v)", this.ForceGpuCompatible, that1.ForceGpuCompatible)
	}
	return nil
}
func (this *GPUOptions) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GPUOptions)
	if !ok {
		that2, ok := that.(GPUOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.PerProcessGpuMemoryFraction != that1.PerProcessGpuMemoryFraction {
		return false
	}
	if this.AllocatorType != that1.AllocatorType {
		return false
	}
	if this.VisibleDeviceList != that1.VisibleDeviceList {
		return false
	}
	if this.ForceGpuCompatible != that1.ForceGpuCompatible {
		return false
	}
	return true
}
func (this *ExecutionOptions) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ExecutionOptions)
	if !ok {
		that2, ok := that.(ExecutionOptions)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ExecutionOptions")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ExecutionOptions but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ExecutionOptions but is not nil && this == nil")
	}
	if this.TraceLevel != that1.TraceLevel {
		return fmt.Errorf("TraceLevel this(%v) Not Equal that(%v)", this.TraceLevel, that1.TraceLevel)
	}
	if this.TimeoutInMs != that1.TimeoutInMs {
		return fmt.Errorf("TimeoutInMs this(%v) Not Equal that(%v)", this.TimeoutInMs, that1.TimeoutInMs)
	}
	if len(this.DeviceCount) != len(that1.DeviceCount) {
		return fmt.Errorf("DeviceCount this(%v) Not Equal that(%v)", len(this.DeviceCount), len(that1.DeviceCount))
	}
	for i := range this.DeviceCount {
		if this.DeviceCount[i] != that1.DeviceCount[i] {
			return fmt.Errorf("DeviceCount this[%v](%v) Not Equal that[%v](%v)", i, this.DeviceCount[i], i, that1.DeviceCount[i])
		}
	}
	if !this.CpuOptions.Equal(that1.CpuOptions) {
		return fmt.Errorf("CpuOptions this(%v) Not Equal that(%v)", this.CpuOptions, that1.CpuOptions)
	}
	if !this.GpuOptions.Equal(that1.GpuOptions) {
		return fmt.Errorf("GpuOptions this(%v) Not Equal that(%v)", this.GpuOptions, that1.GpuOptions)
	}
	return nil
}
func (this *ExecutionOptions) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ExecutionOptions)
	if !ok {
		that2, ok := that.(ExecutionOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.TraceLevel != that1.TraceLevel {
		return false
	}
	if this.TimeoutInMs != that1.TimeoutInMs {
		return false
	}
	if len(this.DeviceCount) != len(that1.DeviceCount) {
		return false
	}
	for i := range this.DeviceCount {
		if this.DeviceCount[i] != that1.DeviceCount[i] {
			return false
		}
	}
	if !this.CpuOptions.Equal(that1.CpuOptions) {
		return false
	}
	if !this.GpuOptions.Equal(that1.GpuOptions) {
		return false
	}
	return true
}
func (this *PredictionOptions) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PredictionOptions)
	if !ok {
		that2, ok := that.(PredictionOptions)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PredictionOptions")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PredictionOptions but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PredictionOptions but is not nil && this == nil")
	}
	if this.RequestID != that1.RequestID {
		return fmt.Errorf("RequestID this(%v) Not Equal that(%v)", this.RequestID, that1.RequestID)
	}
	if this.FeatureLimit != that1.FeatureLimit {
		return fmt.Errorf("FeatureLimit this(%v) Not Equal that(%v)", this.FeatureLimit, that1.FeatureLimit)
	}
	if this.BatchSize != that1.BatchSize {
		return fmt.Errorf("BatchSize this(%v) Not Equal that(%v)", this.BatchSize, that1.BatchSize)
	}
	if !this.ExecutionOptions.Equal(that1.ExecutionOptions) {
		return fmt.Errorf("ExecutionOptions this(%v) Not Equal that(%v)", this.ExecutionOptions, that1.ExecutionOptions)
	}
	return nil
}
func (this *PredictionOptions) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PredictionOptions)
	if !ok {
		that2, ok := that.(PredictionOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.FeatureLimit != that1.FeatureLimit {
		return false
	}
	if this.BatchSize != that1.BatchSize {
		return false
	}
	if !this.ExecutionOptions.Equal(that1.ExecutionOptions) {
		return false
	}
	return true
}
func (this *PredictorOpenRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PredictorOpenRequest)
	if !ok {
		that2, ok := that.(PredictorOpenRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PredictorOpenRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PredictorOpenRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PredictorOpenRequest but is not nil && this == nil")
	}
	if this.ModelName != that1.ModelName {
		return fmt.Errorf("ModelName this(%v) Not Equal that(%v)", this.ModelName, that1.ModelName)
	}
	if this.ModelVersion != that1.ModelVersion {
		return fmt.Errorf("ModelVersion this(%v) Not Equal that(%v)", this.ModelVersion, that1.ModelVersion)
	}
	if this.FrameworkName != that1.FrameworkName {
		return fmt.Errorf("FrameworkName this(%v) Not Equal that(%v)", this.FrameworkName, that1.FrameworkName)
	}
	if this.FrameworkVersion != that1.FrameworkVersion {
		return fmt.Errorf("FrameworkVersion this(%v) Not Equal that(%v)", this.FrameworkVersion, that1.FrameworkVersion)
	}
	if !this.Options.Equal(that1.Options) {
		return fmt.Errorf("Options this(%v) Not Equal that(%v)", this.Options, that1.Options)
	}
	return nil
}
func (this *PredictorOpenRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PredictorOpenRequest)
	if !ok {
		that2, ok := that.(PredictorOpenRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ModelName != that1.ModelName {
		return false
	}
	if this.ModelVersion != that1.ModelVersion {
		return false
	}
	if this.FrameworkName != that1.FrameworkName {
		return false
	}
	if this.FrameworkVersion != that1.FrameworkVersion {
		return false
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *PredictorCloseResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PredictorCloseResponse)
	if !ok {
		that2, ok := that.(PredictorCloseResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PredictorCloseResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PredictorCloseResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PredictorCloseResponse but is not nil && this == nil")
	}
	return nil
}
func (this *PredictorCloseResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PredictorCloseResponse)
	if !ok {
		that2, ok := that.(PredictorCloseResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *Predictor) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Predictor)
	if !ok {
		that2, ok := that.(Predictor)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Predictor")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Predictor but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Predictor but is not nil && this == nil")
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	return nil
}
func (this *Predictor) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Predictor)
	if !ok {
		that2, ok := that.(Predictor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	return true
}
func (this *URLsRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*URLsRequest)
	if !ok {
		that2, ok := that.(URLsRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *URLsRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *URLsRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *URLsRequest but is not nil && this == nil")
	}
	if !this.Predictor.Equal(that1.Predictor) {
		return fmt.Errorf("Predictor this(%v) Not Equal that(%v)", this.Predictor, that1.Predictor)
	}
	if len(this.Urls) != len(that1.Urls) {
		return fmt.Errorf("Urls this(%v) Not Equal that(%v)", len(this.Urls), len(that1.Urls))
	}
	for i := range this.Urls {
		if !this.Urls[i].Equal(that1.Urls[i]) {
			return fmt.Errorf("Urls this[%v](%v) Not Equal that[%v](%v)", i, this.Urls[i], i, that1.Urls[i])
		}
	}
	if !this.Options.Equal(that1.Options) {
		return fmt.Errorf("Options this(%v) Not Equal that(%v)", this.Options, that1.Options)
	}
	return nil
}
func (this *URLsRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*URLsRequest)
	if !ok {
		that2, ok := that.(URLsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Predictor.Equal(that1.Predictor) {
		return false
	}
	if len(this.Urls) != len(that1.Urls) {
		return false
	}
	for i := range this.Urls {
		if !this.Urls[i].Equal(that1.Urls[i]) {
			return false
		}
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *URLsRequest_URL) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*URLsRequest_URL)
	if !ok {
		that2, ok := that.(URLsRequest_URL)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *URLsRequest_URL")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *URLsRequest_URL but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *URLsRequest_URL but is not nil && this == nil")
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if this.Data != that1.Data {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	return nil
}
func (this *URLsRequest_URL) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*URLsRequest_URL)
	if !ok {
		that2, ok := that.(URLsRequest_URL)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.Data != that1.Data {
		return false
	}
	return true
}
func (this *ImagesRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ImagesRequest)
	if !ok {
		that2, ok := that.(ImagesRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ImagesRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ImagesRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ImagesRequest but is not nil && this == nil")
	}
	if !this.Predictor.Equal(that1.Predictor) {
		return fmt.Errorf("Predictor this(%v) Not Equal that(%v)", this.Predictor, that1.Predictor)
	}
	if len(this.Images) != len(that1.Images) {
		return fmt.Errorf("Images this(%v) Not Equal that(%v)", len(this.Images), len(that1.Images))
	}
	for i := range this.Images {
		if !this.Images[i].Equal(that1.Images[i]) {
			return fmt.Errorf("Images this[%v](%v) Not Equal that[%v](%v)", i, this.Images[i], i, that1.Images[i])
		}
	}
	if !this.Options.Equal(that1.Options) {
		return fmt.Errorf("Options this(%v) Not Equal that(%v)", this.Options, that1.Options)
	}
	return nil
}
func (this *ImagesRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ImagesRequest)
	if !ok {
		that2, ok := that.(ImagesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Predictor.Equal(that1.Predictor) {
		return false
	}
	if len(this.Images) != len(that1.Images) {
		return false
	}
	for i := range this.Images {
		if !this.Images[i].Equal(that1.Images[i]) {
			return false
		}
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *ImagesRequest_Image) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ImagesRequest_Image)
	if !ok {
		that2, ok := that.(ImagesRequest_Image)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ImagesRequest_Image")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ImagesRequest_Image but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ImagesRequest_Image but is not nil && this == nil")
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	return nil
}
func (this *ImagesRequest_Image) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ImagesRequest_Image)
	if !ok {
		that2, ok := that.(ImagesRequest_Image)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *DatasetRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DatasetRequest)
	if !ok {
		that2, ok := that.(DatasetRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DatasetRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DatasetRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DatasetRequest but is not nil && this == nil")
	}
	if !this.Predictor.Equal(that1.Predictor) {
		return fmt.Errorf("Predictor this(%v) Not Equal that(%v)", this.Predictor, that1.Predictor)
	}
	if !this.Dataset.Equal(that1.Dataset) {
		return fmt.Errorf("Dataset this(%v) Not Equal that(%v)", this.Dataset, that1.Dataset)
	}
	if !this.Options.Equal(that1.Options) {
		return fmt.Errorf("Options this(%v) Not Equal that(%v)", this.Options, that1.Options)
	}
	return nil
}
func (this *DatasetRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DatasetRequest)
	if !ok {
		that2, ok := that.(DatasetRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Predictor.Equal(that1.Predictor) {
		return false
	}
	if !this.Dataset.Equal(that1.Dataset) {
		return false
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *DatasetRequest_Dataset) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DatasetRequest_Dataset)
	if !ok {
		that2, ok := that.(DatasetRequest_Dataset)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DatasetRequest_Dataset")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DatasetRequest_Dataset but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DatasetRequest_Dataset but is not nil && this == nil")
	}
	if this.Category != that1.Category {
		return fmt.Errorf("Category this(%v) Not Equal that(%v)", this.Category, that1.Category)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	return nil
}
func (this *DatasetRequest_Dataset) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DatasetRequest_Dataset)
	if !ok {
		that2, ok := that.(DatasetRequest_Dataset)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Category != that1.Category {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Feature) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Feature)
	if !ok {
		that2, ok := that.(Feature)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Feature")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Feature but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Feature but is not nil && this == nil")
	}
	if this.Index != that1.Index {
		return fmt.Errorf("Index this(%v) Not Equal that(%v)", this.Index, that1.Index)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Probability != that1.Probability {
		return fmt.Errorf("Probability this(%v) Not Equal that(%v)", this.Probability, that1.Probability)
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return fmt.Errorf("Metadata this(%v) Not Equal that(%v)", len(this.Metadata), len(that1.Metadata))
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return fmt.Errorf("Metadata this[%v](%v) Not Equal that[%v](%v)", i, this.Metadata[i], i, that1.Metadata[i])
		}
	}
	return nil
}
func (this *Feature) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Feature)
	if !ok {
		that2, ok := that.(Feature)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Probability != that1.Probability {
		return false
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return false
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return false
		}
	}
	return true
}
func (this *FeatureResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FeatureResponse)
	if !ok {
		that2, ok := that.(FeatureResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FeatureResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FeatureResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FeatureResponse but is not nil && this == nil")
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if this.RequestID != that1.RequestID {
		return fmt.Errorf("RequestID this(%v) Not Equal that(%v)", this.RequestID, that1.RequestID)
	}
	if this.InputID != that1.InputID {
		return fmt.Errorf("InputID this(%v) Not Equal that(%v)", this.InputID, that1.InputID)
	}
	if len(this.Features) != len(that1.Features) {
		return fmt.Errorf("Features this(%v) Not Equal that(%v)", len(this.Features), len(that1.Features))
	}
	for i := range this.Features {
		if !this.Features[i].Equal(that1.Features[i]) {
			return fmt.Errorf("Features this[%v](%v) Not Equal that[%v](%v)", i, this.Features[i], i, that1.Features[i])
		}
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return fmt.Errorf("Metadata this(%v) Not Equal that(%v)", len(this.Metadata), len(that1.Metadata))
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return fmt.Errorf("Metadata this[%v](%v) Not Equal that[%v](%v)", i, this.Metadata[i], i, that1.Metadata[i])
		}
	}
	return nil
}
func (this *FeatureResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FeatureResponse)
	if !ok {
		that2, ok := that.(FeatureResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.InputID != that1.InputID {
		return false
	}
	if len(this.Features) != len(that1.Features) {
		return false
	}
	for i := range this.Features {
		if !this.Features[i].Equal(that1.Features[i]) {
			return false
		}
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return false
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return false
		}
	}
	return true
}
func (this *FeaturesResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FeaturesResponse)
	if !ok {
		that2, ok := that.(FeaturesResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FeaturesResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FeaturesResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FeaturesResponse but is not nil && this == nil")
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if len(this.Responses) != len(that1.Responses) {
		return fmt.Errorf("Responses this(%v) Not Equal that(%v)", len(this.Responses), len(that1.Responses))
	}
	for i := range this.Responses {
		if !this.Responses[i].Equal(that1.Responses[i]) {
			return fmt.Errorf("Responses this[%v](%v) Not Equal that[%v](%v)", i, this.Responses[i], i, that1.Responses[i])
		}
	}
	return nil
}
func (this *FeaturesResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FeaturesResponse)
	if !ok {
		that2, ok := that.(FeaturesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if len(this.Responses) != len(that1.Responses) {
		return false
	}
	for i := range this.Responses {
		if !this.Responses[i].Equal(that1.Responses[i]) {
			return false
		}
	}
	return true
}
func (this *ResetRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ResetRequest)
	if !ok {
		that2, ok := that.(ResetRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ResetRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ResetRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ResetRequest but is not nil && this == nil")
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if !this.Predictor.Equal(that1.Predictor) {
		return fmt.Errorf("Predictor this(%v) Not Equal that(%v)", this.Predictor, that1.Predictor)
	}
	return nil
}
func (this *ResetRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResetRequest)
	if !ok {
		that2, ok := that.(ResetRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if !this.Predictor.Equal(that1.Predictor) {
		return false
	}
	return true
}
func (this *ResetResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ResetResponse)
	if !ok {
		that2, ok := that.(ResetResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ResetResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ResetResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ResetResponse but is not nil && this == nil")
	}
	if !this.Predictor.Equal(that1.Predictor) {
		return fmt.Errorf("Predictor this(%v) Not Equal that(%v)", this.Predictor, that1.Predictor)
	}
	return nil
}
func (this *ResetResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResetResponse)
	if !ok {
		that2, ok := that.(ResetResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Predictor.Equal(that1.Predictor) {
		return false
	}
	return true
}
func (this *CPUOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&dlframework.CPUOptions{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GPUOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dlframework.GPUOptions{")
	s = append(s, "PerProcessGpuMemoryFraction: "+fmt.Sprintf("%#v", this.PerProcessGpuMemoryFraction)+",\n")
	s = append(s, "AllocatorType: "+fmt.Sprintf("%#v", this.AllocatorType)+",\n")
	s = append(s, "VisibleDeviceList: "+fmt.Sprintf("%#v", this.VisibleDeviceList)+",\n")
	s = append(s, "ForceGpuCompatible: "+fmt.Sprintf("%#v", this.ForceGpuCompatible)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecutionOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dlframework.ExecutionOptions{")
	s = append(s, "TraceLevel: "+fmt.Sprintf("%#v", this.TraceLevel)+",\n")
	s = append(s, "TimeoutInMs: "+fmt.Sprintf("%#v", this.TimeoutInMs)+",\n")
	keysForDeviceCount := make([]string, 0, len(this.DeviceCount))
	for k := range this.DeviceCount {
		keysForDeviceCount = append(keysForDeviceCount, k)
	}
	sortkeys.Strings(keysForDeviceCount)
	mapStringForDeviceCount := "map[string]int32{"
	for _, k := range keysForDeviceCount {
		mapStringForDeviceCount += fmt.Sprintf("%#v: %#v,", k, this.DeviceCount[k])
	}
	mapStringForDeviceCount += "}"
	if this.DeviceCount != nil {
		s = append(s, "DeviceCount: "+mapStringForDeviceCount+",\n")
	}
	if this.CpuOptions != nil {
		s = append(s, "CpuOptions: "+fmt.Sprintf("%#v", this.CpuOptions)+",\n")
	}
	if this.GpuOptions != nil {
		s = append(s, "GpuOptions: "+fmt.Sprintf("%#v", this.GpuOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PredictionOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dlframework.PredictionOptions{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "FeatureLimit: "+fmt.Sprintf("%#v", this.FeatureLimit)+",\n")
	s = append(s, "BatchSize: "+fmt.Sprintf("%#v", this.BatchSize)+",\n")
	if this.ExecutionOptions != nil {
		s = append(s, "ExecutionOptions: "+fmt.Sprintf("%#v", this.ExecutionOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PredictorOpenRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dlframework.PredictorOpenRequest{")
	s = append(s, "ModelName: "+fmt.Sprintf("%#v", this.ModelName)+",\n")
	s = append(s, "ModelVersion: "+fmt.Sprintf("%#v", this.ModelVersion)+",\n")
	s = append(s, "FrameworkName: "+fmt.Sprintf("%#v", this.FrameworkName)+",\n")
	s = append(s, "FrameworkVersion: "+fmt.Sprintf("%#v", this.FrameworkVersion)+",\n")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PredictorCloseResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&dlframework.PredictorCloseResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Predictor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dlframework.Predictor{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *URLsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dlframework.URLsRequest{")
	if this.Predictor != nil {
		s = append(s, "Predictor: "+fmt.Sprintf("%#v", this.Predictor)+",\n")
	}
	if this.Urls != nil {
		s = append(s, "Urls: "+fmt.Sprintf("%#v", this.Urls)+",\n")
	}
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *URLsRequest_URL) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dlframework.URLsRequest_URL{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImagesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dlframework.ImagesRequest{")
	if this.Predictor != nil {
		s = append(s, "Predictor: "+fmt.Sprintf("%#v", this.Predictor)+",\n")
	}
	if this.Images != nil {
		s = append(s, "Images: "+fmt.Sprintf("%#v", this.Images)+",\n")
	}
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImagesRequest_Image) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dlframework.ImagesRequest_Image{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DatasetRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dlframework.DatasetRequest{")
	if this.Predictor != nil {
		s = append(s, "Predictor: "+fmt.Sprintf("%#v", this.Predictor)+",\n")
	}
	if this.Dataset != nil {
		s = append(s, "Dataset: "+fmt.Sprintf("%#v", this.Dataset)+",\n")
	}
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DatasetRequest_Dataset) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dlframework.DatasetRequest_Dataset{")
	s = append(s, "Category: "+fmt.Sprintf("%#v", this.Category)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Feature) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dlframework.Feature{")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Probability: "+fmt.Sprintf("%#v", this.Probability)+",\n")
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%#v: %#v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	if this.Metadata != nil {
		s = append(s, "Metadata: "+mapStringForMetadata+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FeatureResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dlframework.FeatureResponse{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "InputID: "+fmt.Sprintf("%#v", this.InputID)+",\n")
	if this.Features != nil {
		s = append(s, "Features: "+fmt.Sprintf("%#v", this.Features)+",\n")
	}
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%#v: %#v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	if this.Metadata != nil {
		s = append(s, "Metadata: "+mapStringForMetadata+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FeaturesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dlframework.FeaturesResponse{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	if this.Responses != nil {
		s = append(s, "Responses: "+fmt.Sprintf("%#v", this.Responses)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResetRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dlframework.ResetRequest{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	if this.Predictor != nil {
		s = append(s, "Predictor: "+fmt.Sprintf("%#v", this.Predictor)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResetResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dlframework.ResetResponse{")
	if this.Predictor != nil {
		s = append(s, "Predictor: "+fmt.Sprintf("%#v", this.Predictor)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPredictor(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Predict service

type PredictClient interface {
	// Opens a predictor and returns an id where the predictor
	// is accessible. The id can be used to perform inference
	// requests.
	Open(ctx context.Context, in *PredictorOpenRequest, opts ...grpc.CallOption) (*Predictor, error)
	// Close a predictor clear it's memory.
	Close(ctx context.Context, in *Predictor, opts ...grpc.CallOption) (*PredictorCloseResponse, error)
	// Image method receives a stream of urls and runs
	// the predictor on all the urls. The
	//
	// The result is a prediction feature stream for each url.
	URLs(ctx context.Context, in *URLsRequest, opts ...grpc.CallOption) (*FeaturesResponse, error)
	// Image method receives a stream of urls and runs
	// the predictor on all the urls. The
	//
	// The result is a prediction feature stream for each url.
	URLsStream(ctx context.Context, in *URLsRequest, opts ...grpc.CallOption) (Predict_URLsStreamClient, error)
	// Image method receives a list base64 encoded images and runs
	// the predictor on all the images.
	//
	// The result is a prediction feature list for each image.
	Images(ctx context.Context, in *ImagesRequest, opts ...grpc.CallOption) (*FeaturesResponse, error)
	// Image method receives a list base64 encoded images and runs
	// the predictor on all the images.
	//
	// The result is a prediction feature stream for each image.
	ImagesStream(ctx context.Context, in *ImagesRequest, opts ...grpc.CallOption) (Predict_ImagesStreamClient, error)
	// Dataset method receives a single dataset and runs
	// the predictor on all elements of the dataset.
	//
	// The result is a prediction feature list.
	Dataset(ctx context.Context, in *DatasetRequest, opts ...grpc.CallOption) (*FeaturesResponse, error)
	// Dataset method receives a single dataset and runs
	// the predictor on all elements of the dataset.
	//
	// The result is a prediction feature stream.
	DatasetStream(ctx context.Context, in *DatasetRequest, opts ...grpc.CallOption) (Predict_DatasetStreamClient, error)
	// Clear method clears the internal cache of the predictors
	Reset(ctx context.Context, in *ResetRequest, opts ...grpc.CallOption) (*ResetResponse, error)
}

type predictClient struct {
	cc *grpc.ClientConn
}

func NewPredictClient(cc *grpc.ClientConn) PredictClient {
	return &predictClient{cc}
}

func (c *predictClient) Open(ctx context.Context, in *PredictorOpenRequest, opts ...grpc.CallOption) (*Predictor, error) {
	out := new(Predictor)
	err := grpc.Invoke(ctx, "/carml.org.dlframework.Predict/Open", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *predictClient) Close(ctx context.Context, in *Predictor, opts ...grpc.CallOption) (*PredictorCloseResponse, error) {
	out := new(PredictorCloseResponse)
	err := grpc.Invoke(ctx, "/carml.org.dlframework.Predict/Close", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *predictClient) URLs(ctx context.Context, in *URLsRequest, opts ...grpc.CallOption) (*FeaturesResponse, error) {
	out := new(FeaturesResponse)
	err := grpc.Invoke(ctx, "/carml.org.dlframework.Predict/URLs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *predictClient) URLsStream(ctx context.Context, in *URLsRequest, opts ...grpc.CallOption) (Predict_URLsStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Predict_serviceDesc.Streams[0], c.cc, "/carml.org.dlframework.Predict/URLsStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &predictURLsStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Predict_URLsStreamClient interface {
	Recv() (*FeatureResponse, error)
	grpc.ClientStream
}

type predictURLsStreamClient struct {
	grpc.ClientStream
}

func (x *predictURLsStreamClient) Recv() (*FeatureResponse, error) {
	m := new(FeatureResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *predictClient) Images(ctx context.Context, in *ImagesRequest, opts ...grpc.CallOption) (*FeaturesResponse, error) {
	out := new(FeaturesResponse)
	err := grpc.Invoke(ctx, "/carml.org.dlframework.Predict/Images", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *predictClient) ImagesStream(ctx context.Context, in *ImagesRequest, opts ...grpc.CallOption) (Predict_ImagesStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Predict_serviceDesc.Streams[1], c.cc, "/carml.org.dlframework.Predict/ImagesStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &predictImagesStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Predict_ImagesStreamClient interface {
	Recv() (*FeatureResponse, error)
	grpc.ClientStream
}

type predictImagesStreamClient struct {
	grpc.ClientStream
}

func (x *predictImagesStreamClient) Recv() (*FeatureResponse, error) {
	m := new(FeatureResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *predictClient) Dataset(ctx context.Context, in *DatasetRequest, opts ...grpc.CallOption) (*FeaturesResponse, error) {
	out := new(FeaturesResponse)
	err := grpc.Invoke(ctx, "/carml.org.dlframework.Predict/Dataset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *predictClient) DatasetStream(ctx context.Context, in *DatasetRequest, opts ...grpc.CallOption) (Predict_DatasetStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Predict_serviceDesc.Streams[2], c.cc, "/carml.org.dlframework.Predict/DatasetStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &predictDatasetStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Predict_DatasetStreamClient interface {
	Recv() (*FeatureResponse, error)
	grpc.ClientStream
}

type predictDatasetStreamClient struct {
	grpc.ClientStream
}

func (x *predictDatasetStreamClient) Recv() (*FeatureResponse, error) {
	m := new(FeatureResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *predictClient) Reset(ctx context.Context, in *ResetRequest, opts ...grpc.CallOption) (*ResetResponse, error) {
	out := new(ResetResponse)
	err := grpc.Invoke(ctx, "/carml.org.dlframework.Predict/Reset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Predict service

type PredictServer interface {
	// Opens a predictor and returns an id where the predictor
	// is accessible. The id can be used to perform inference
	// requests.
	Open(context.Context, *PredictorOpenRequest) (*Predictor, error)
	// Close a predictor clear it's memory.
	Close(context.Context, *Predictor) (*PredictorCloseResponse, error)
	// Image method receives a stream of urls and runs
	// the predictor on all the urls. The
	//
	// The result is a prediction feature stream for each url.
	URLs(context.Context, *URLsRequest) (*FeaturesResponse, error)
	// Image method receives a stream of urls and runs
	// the predictor on all the urls. The
	//
	// The result is a prediction feature stream for each url.
	URLsStream(*URLsRequest, Predict_URLsStreamServer) error
	// Image method receives a list base64 encoded images and runs
	// the predictor on all the images.
	//
	// The result is a prediction feature list for each image.
	Images(context.Context, *ImagesRequest) (*FeaturesResponse, error)
	// Image method receives a list base64 encoded images and runs
	// the predictor on all the images.
	//
	// The result is a prediction feature stream for each image.
	ImagesStream(*ImagesRequest, Predict_ImagesStreamServer) error
	// Dataset method receives a single dataset and runs
	// the predictor on all elements of the dataset.
	//
	// The result is a prediction feature list.
	Dataset(context.Context, *DatasetRequest) (*FeaturesResponse, error)
	// Dataset method receives a single dataset and runs
	// the predictor on all elements of the dataset.
	//
	// The result is a prediction feature stream.
	DatasetStream(*DatasetRequest, Predict_DatasetStreamServer) error
	// Clear method clears the internal cache of the predictors
	Reset(context.Context, *ResetRequest) (*ResetResponse, error)
}

func RegisterPredictServer(s *grpc.Server, srv PredictServer) {
	s.RegisterService(&_Predict_serviceDesc, srv)
}

func _Predict_Open_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PredictorOpenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PredictServer).Open(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/carml.org.dlframework.Predict/Open",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PredictServer).Open(ctx, req.(*PredictorOpenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Predict_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Predictor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PredictServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/carml.org.dlframework.Predict/Close",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PredictServer).Close(ctx, req.(*Predictor))
	}
	return interceptor(ctx, in, info, handler)
}

func _Predict_URLs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(URLsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PredictServer).URLs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/carml.org.dlframework.Predict/URLs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PredictServer).URLs(ctx, req.(*URLsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Predict_URLsStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(URLsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PredictServer).URLsStream(m, &predictURLsStreamServer{stream})
}

type Predict_URLsStreamServer interface {
	Send(*FeatureResponse) error
	grpc.ServerStream
}

type predictURLsStreamServer struct {
	grpc.ServerStream
}

func (x *predictURLsStreamServer) Send(m *FeatureResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Predict_Images_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PredictServer).Images(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/carml.org.dlframework.Predict/Images",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PredictServer).Images(ctx, req.(*ImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Predict_ImagesStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImagesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PredictServer).ImagesStream(m, &predictImagesStreamServer{stream})
}

type Predict_ImagesStreamServer interface {
	Send(*FeatureResponse) error
	grpc.ServerStream
}

type predictImagesStreamServer struct {
	grpc.ServerStream
}

func (x *predictImagesStreamServer) Send(m *FeatureResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Predict_Dataset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatasetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PredictServer).Dataset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/carml.org.dlframework.Predict/Dataset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PredictServer).Dataset(ctx, req.(*DatasetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Predict_DatasetStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DatasetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PredictServer).DatasetStream(m, &predictDatasetStreamServer{stream})
}

type Predict_DatasetStreamServer interface {
	Send(*FeatureResponse) error
	grpc.ServerStream
}

type predictDatasetStreamServer struct {
	grpc.ServerStream
}

func (x *predictDatasetStreamServer) Send(m *FeatureResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Predict_Reset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PredictServer).Reset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/carml.org.dlframework.Predict/Reset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PredictServer).Reset(ctx, req.(*ResetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Predict_serviceDesc = grpc.ServiceDesc{
	ServiceName: "carml.org.dlframework.Predict",
	HandlerType: (*PredictServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Open",
			Handler:    _Predict_Open_Handler,
		},
		{
			MethodName: "Close",
			Handler:    _Predict_Close_Handler,
		},
		{
			MethodName: "URLs",
			Handler:    _Predict_URLs_Handler,
		},
		{
			MethodName: "Images",
			Handler:    _Predict_Images_Handler,
		},
		{
			MethodName: "Dataset",
			Handler:    _Predict_Dataset_Handler,
		},
		{
			MethodName: "Reset",
			Handler:    _Predict_Reset_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "URLsStream",
			Handler:       _Predict_URLsStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ImagesStream",
			Handler:       _Predict_ImagesStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DatasetStream",
			Handler:       _Predict_DatasetStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "predictor.proto",
}

func (m *CPUOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GPUOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PerProcessGpuMemoryFraction != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PerProcessGpuMemoryFraction))))
		i += 8
	}
	if len(m.AllocatorType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.AllocatorType)))
		i += copy(dAtA[i:], m.AllocatorType)
	}
	if len(m.VisibleDeviceList) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.VisibleDeviceList)))
		i += copy(dAtA[i:], m.VisibleDeviceList)
	}
	if m.ForceGpuCompatible {
		dAtA[i] = 0x40
		i++
		if m.ForceGpuCompatible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ExecutionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TraceLevel != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.TraceLevel))
	}
	if m.TimeoutInMs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.TimeoutInMs))
	}
	if len(m.DeviceCount) > 0 {
		for k := range m.DeviceCount {
			dAtA[i] = 0x1a
			i++
			v := m.DeviceCount[k]
			mapSize := 1 + len(k) + sovPredictor(uint64(len(k))) + 1 + sovPredictor(uint64(v))
			i = encodeVarintPredictor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPredictor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintPredictor(dAtA, i, uint64(v))
		}
	}
	if m.CpuOptions != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.CpuOptions.Size()))
		n1, err := m.CpuOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.GpuOptions != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.GpuOptions.Size()))
		n2, err := m.GpuOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *PredictionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredictionOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.FeatureLimit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.FeatureLimit))
	}
	if m.BatchSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.BatchSize))
	}
	if m.ExecutionOptions != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.ExecutionOptions.Size()))
		n3, err := m.ExecutionOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *PredictorOpenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredictorOpenRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ModelName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.ModelName)))
		i += copy(dAtA[i:], m.ModelName)
	}
	if len(m.ModelVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.ModelVersion)))
		i += copy(dAtA[i:], m.ModelVersion)
	}
	if len(m.FrameworkName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.FrameworkName)))
		i += copy(dAtA[i:], m.FrameworkName)
	}
	if len(m.FrameworkVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.FrameworkVersion)))
		i += copy(dAtA[i:], m.FrameworkVersion)
	}
	if m.Options != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.Options.Size()))
		n4, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *PredictorCloseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredictorCloseResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Predictor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Predictor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	return i, nil
}

func (m *URLsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Predictor != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.Predictor.Size()))
		n5, err := m.Predictor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Urls) > 0 {
		for _, msg := range m.Urls {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPredictor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Options != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.Options.Size()))
		n6, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *URLsRequest_URL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLsRequest_URL) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ImagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Predictor != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.Predictor.Size()))
		n7, err := m.Predictor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Images) > 0 {
		for _, msg := range m.Images {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPredictor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Options != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.Options.Size()))
		n8, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *ImagesRequest_Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImagesRequest_Image) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *DatasetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Predictor != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.Predictor.Size()))
		n9, err := m.Predictor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Dataset != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.Dataset.Size()))
		n10, err := m.Dataset.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Options != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.Options.Size()))
		n11, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *DatasetRequest_Dataset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatasetRequest_Dataset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Category) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.Category)))
		i += copy(dAtA[i:], m.Category)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *Feature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Feature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.Index))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Probability != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Probability))))
		i += 4
	}
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			dAtA[i] = 0x22
			i++
			v := m.Metadata[k]
			mapSize := 1 + len(k) + sovPredictor(uint64(len(k))) + 1 + len(v) + sovPredictor(uint64(len(v)))
			i = encodeVarintPredictor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPredictor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPredictor(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *FeatureResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.RequestID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.InputID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.InputID)))
		i += copy(dAtA[i:], m.InputID)
	}
	if len(m.Features) > 0 {
		for _, msg := range m.Features {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPredictor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			dAtA[i] = 0x2a
			i++
			v := m.Metadata[k]
			mapSize := 1 + len(k) + sovPredictor(uint64(len(k))) + 1 + len(v) + sovPredictor(uint64(len(v)))
			i = encodeVarintPredictor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPredictor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPredictor(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *FeaturesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeaturesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Responses) > 0 {
		for _, msg := range m.Responses {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPredictor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ResetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Predictor != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.Predictor.Size()))
		n12, err := m.Predictor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	return i, nil
}

func (m *ResetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Predictor != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredictor(dAtA, i, uint64(m.Predictor.Size()))
		n13, err := m.Predictor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func encodeVarintPredictor(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedCPUOptions(r randyPredictor, easy bool) *CPUOptions {
	this := &CPUOptions{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGPUOptions(r randyPredictor, easy bool) *GPUOptions {
	this := &GPUOptions{}
	this.PerProcessGpuMemoryFraction = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.PerProcessGpuMemoryFraction *= -1
	}
	this.AllocatorType = string(randStringPredictor(r))
	this.VisibleDeviceList = string(randStringPredictor(r))
	this.ForceGpuCompatible = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedExecutionOptions(r randyPredictor, easy bool) *ExecutionOptions {
	this := &ExecutionOptions{}
	this.TraceLevel = ExecutionOptions_TraceLevel([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	this.TimeoutInMs = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.TimeoutInMs *= -1
	}
	if r.Intn(10) != 0 {
		v1 := r.Intn(10)
		this.DeviceCount = make(map[string]int32)
		for i := 0; i < v1; i++ {
			v2 := randStringPredictor(r)
			this.DeviceCount[v2] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.DeviceCount[v2] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		this.CpuOptions = NewPopulatedCPUOptions(r, easy)
	}
	if r.Intn(10) != 0 {
		this.GpuOptions = NewPopulatedGPUOptions(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPredictionOptions(r randyPredictor, easy bool) *PredictionOptions {
	this := &PredictionOptions{}
	this.RequestID = string(randStringPredictor(r))
	this.FeatureLimit = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.FeatureLimit *= -1
	}
	this.BatchSize = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		this.ExecutionOptions = NewPopulatedExecutionOptions(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPredictorOpenRequest(r randyPredictor, easy bool) *PredictorOpenRequest {
	this := &PredictorOpenRequest{}
	this.ModelName = string(randStringPredictor(r))
	this.ModelVersion = string(randStringPredictor(r))
	this.FrameworkName = string(randStringPredictor(r))
	this.FrameworkVersion = string(randStringPredictor(r))
	if r.Intn(10) != 0 {
		this.Options = NewPopulatedPredictionOptions(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPredictorCloseResponse(r randyPredictor, easy bool) *PredictorCloseResponse {
	this := &PredictorCloseResponse{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPredictor(r randyPredictor, easy bool) *Predictor {
	this := &Predictor{}
	this.ID = string(randStringPredictor(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedURLsRequest(r randyPredictor, easy bool) *URLsRequest {
	this := &URLsRequest{}
	if r.Intn(10) != 0 {
		this.Predictor = NewPopulatedPredictor(r, easy)
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Urls = make([]*URLsRequest_URL, v3)
		for i := 0; i < v3; i++ {
			this.Urls[i] = NewPopulatedURLsRequest_URL(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Options = NewPopulatedPredictionOptions(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedURLsRequest_URL(r randyPredictor, easy bool) *URLsRequest_URL {
	this := &URLsRequest_URL{}
	this.ID = string(randStringPredictor(r))
	this.Data = string(randStringPredictor(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedImagesRequest(r randyPredictor, easy bool) *ImagesRequest {
	this := &ImagesRequest{}
	if r.Intn(10) != 0 {
		this.Predictor = NewPopulatedPredictor(r, easy)
	}
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.Images = make([]*ImagesRequest_Image, v4)
		for i := 0; i < v4; i++ {
			this.Images[i] = NewPopulatedImagesRequest_Image(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Options = NewPopulatedPredictionOptions(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedImagesRequest_Image(r randyPredictor, easy bool) *ImagesRequest_Image {
	this := &ImagesRequest_Image{}
	this.ID = string(randStringPredictor(r))
	v5 := r.Intn(100)
	this.Data = make([]byte, v5)
	for i := 0; i < v5; i++ {
		this.Data[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDatasetRequest(r randyPredictor, easy bool) *DatasetRequest {
	this := &DatasetRequest{}
	if r.Intn(10) != 0 {
		this.Predictor = NewPopulatedPredictor(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Dataset = NewPopulatedDatasetRequest_Dataset(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Options = NewPopulatedPredictionOptions(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDatasetRequest_Dataset(r randyPredictor, easy bool) *DatasetRequest_Dataset {
	this := &DatasetRequest_Dataset{}
	this.Category = string(randStringPredictor(r))
	this.Name = string(randStringPredictor(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFeature(r randyPredictor, easy bool) *Feature {
	this := &Feature{}
	this.Index = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Index *= -1
	}
	this.Name = string(randStringPredictor(r))
	this.Probability = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Probability *= -1
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(10)
		this.Metadata = make(map[string]string)
		for i := 0; i < v6; i++ {
			this.Metadata[randStringPredictor(r)] = randStringPredictor(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFeatureResponse(r randyPredictor, easy bool) *FeatureResponse {
	this := &FeatureResponse{}
	this.ID = string(randStringPredictor(r))
	this.RequestID = string(randStringPredictor(r))
	this.InputID = string(randStringPredictor(r))
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.Features = make([]*Feature, v7)
		for i := 0; i < v7; i++ {
			this.Features[i] = NewPopulatedFeature(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(10)
		this.Metadata = make(map[string]string)
		for i := 0; i < v8; i++ {
			this.Metadata[randStringPredictor(r)] = randStringPredictor(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFeaturesResponse(r randyPredictor, easy bool) *FeaturesResponse {
	this := &FeaturesResponse{}
	this.ID = string(randStringPredictor(r))
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.Responses = make([]*FeatureResponse, v9)
		for i := 0; i < v9; i++ {
			this.Responses[i] = NewPopulatedFeatureResponse(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResetRequest(r randyPredictor, easy bool) *ResetRequest {
	this := &ResetRequest{}
	if r.Intn(10) != 0 {
		this.Predictor = NewPopulatedPredictor(r, easy)
	}
	this.ID = string(randStringPredictor(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResetResponse(r randyPredictor, easy bool) *ResetResponse {
	this := &ResetResponse{}
	if r.Intn(10) != 0 {
		this.Predictor = NewPopulatedPredictor(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyPredictor interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RunePredictor(r randyPredictor) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringPredictor(r randyPredictor) string {
	v10 := r.Intn(100)
	tmps := make([]rune, v10)
	for i := 0; i < v10; i++ {
		tmps[i] = randUTF8RunePredictor(r)
	}
	return string(tmps)
}
func randUnrecognizedPredictor(r randyPredictor, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldPredictor(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldPredictor(dAtA []byte, r randyPredictor, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulatePredictor(dAtA, uint64(key))
		v11 := r.Int63()
		if r.Intn(2) == 0 {
			v11 *= -1
		}
		dAtA = encodeVarintPopulatePredictor(dAtA, uint64(v11))
	case 1:
		dAtA = encodeVarintPopulatePredictor(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulatePredictor(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulatePredictor(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulatePredictor(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulatePredictor(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *CPUOptions) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GPUOptions) Size() (n int) {
	var l int
	_ = l
	if m.PerProcessGpuMemoryFraction != 0 {
		n += 9
	}
	l = len(m.AllocatorType)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	l = len(m.VisibleDeviceList)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	if m.ForceGpuCompatible {
		n += 2
	}
	return n
}

func (m *ExecutionOptions) Size() (n int) {
	var l int
	_ = l
	if m.TraceLevel != 0 {
		n += 1 + sovPredictor(uint64(m.TraceLevel))
	}
	if m.TimeoutInMs != 0 {
		n += 1 + sovPredictor(uint64(m.TimeoutInMs))
	}
	if len(m.DeviceCount) > 0 {
		for k, v := range m.DeviceCount {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPredictor(uint64(len(k))) + 1 + sovPredictor(uint64(v))
			n += mapEntrySize + 1 + sovPredictor(uint64(mapEntrySize))
		}
	}
	if m.CpuOptions != nil {
		l = m.CpuOptions.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	if m.GpuOptions != nil {
		l = m.GpuOptions.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	return n
}

func (m *PredictionOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	if m.FeatureLimit != 0 {
		n += 1 + sovPredictor(uint64(m.FeatureLimit))
	}
	if m.BatchSize != 0 {
		n += 1 + sovPredictor(uint64(m.BatchSize))
	}
	if m.ExecutionOptions != nil {
		l = m.ExecutionOptions.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	return n
}

func (m *PredictorOpenRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ModelName)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	l = len(m.FrameworkName)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	l = len(m.FrameworkVersion)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	return n
}

func (m *PredictorCloseResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Predictor) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	return n
}

func (m *URLsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Predictor != nil {
		l = m.Predictor.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	if len(m.Urls) > 0 {
		for _, e := range m.Urls {
			l = e.Size()
			n += 1 + l + sovPredictor(uint64(l))
		}
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	return n
}

func (m *URLsRequest_URL) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	return n
}

func (m *ImagesRequest) Size() (n int) {
	var l int
	_ = l
	if m.Predictor != nil {
		l = m.Predictor.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	if len(m.Images) > 0 {
		for _, e := range m.Images {
			l = e.Size()
			n += 1 + l + sovPredictor(uint64(l))
		}
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	return n
}

func (m *ImagesRequest_Image) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	return n
}

func (m *DatasetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Predictor != nil {
		l = m.Predictor.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	if m.Dataset != nil {
		l = m.Dataset.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	return n
}

func (m *DatasetRequest_Dataset) Size() (n int) {
	var l int
	_ = l
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	return n
}

func (m *Feature) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovPredictor(uint64(m.Index))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	if m.Probability != 0 {
		n += 5
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPredictor(uint64(len(k))) + 1 + len(v) + sovPredictor(uint64(len(v)))
			n += mapEntrySize + 1 + sovPredictor(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FeatureResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	l = len(m.InputID)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	if len(m.Features) > 0 {
		for _, e := range m.Features {
			l = e.Size()
			n += 1 + l + sovPredictor(uint64(l))
		}
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPredictor(uint64(len(k))) + 1 + len(v) + sovPredictor(uint64(len(v)))
			n += mapEntrySize + 1 + sovPredictor(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FeaturesResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovPredictor(uint64(l))
		}
	}
	return n
}

func (m *ResetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Predictor != nil {
		l = m.Predictor.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPredictor(uint64(l))
	}
	return n
}

func (m *ResetResponse) Size() (n int) {
	var l int
	_ = l
	if m.Predictor != nil {
		l = m.Predictor.Size()
		n += 1 + l + sovPredictor(uint64(l))
	}
	return n
}

func sovPredictor(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPredictor(x uint64) (n int) {
	return sovPredictor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CPUOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CPUOptions{`,
		`}`,
	}, "")
	return s
}
func (this *GPUOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GPUOptions{`,
		`PerProcessGpuMemoryFraction:` + fmt.Sprintf("%v", this.PerProcessGpuMemoryFraction) + `,`,
		`AllocatorType:` + fmt.Sprintf("%v", this.AllocatorType) + `,`,
		`VisibleDeviceList:` + fmt.Sprintf("%v", this.VisibleDeviceList) + `,`,
		`ForceGpuCompatible:` + fmt.Sprintf("%v", this.ForceGpuCompatible) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecutionOptions) String() string {
	if this == nil {
		return "nil"
	}
	keysForDeviceCount := make([]string, 0, len(this.DeviceCount))
	for k := range this.DeviceCount {
		keysForDeviceCount = append(keysForDeviceCount, k)
	}
	sortkeys.Strings(keysForDeviceCount)
	mapStringForDeviceCount := "map[string]int32{"
	for _, k := range keysForDeviceCount {
		mapStringForDeviceCount += fmt.Sprintf("%v: %v,", k, this.DeviceCount[k])
	}
	mapStringForDeviceCount += "}"
	s := strings.Join([]string{`&ExecutionOptions{`,
		`TraceLevel:` + fmt.Sprintf("%v", this.TraceLevel) + `,`,
		`TimeoutInMs:` + fmt.Sprintf("%v", this.TimeoutInMs) + `,`,
		`DeviceCount:` + mapStringForDeviceCount + `,`,
		`CpuOptions:` + strings.Replace(fmt.Sprintf("%v", this.CpuOptions), "CPUOptions", "CPUOptions", 1) + `,`,
		`GpuOptions:` + strings.Replace(fmt.Sprintf("%v", this.GpuOptions), "GPUOptions", "GPUOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PredictionOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PredictionOptions{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`FeatureLimit:` + fmt.Sprintf("%v", this.FeatureLimit) + `,`,
		`BatchSize:` + fmt.Sprintf("%v", this.BatchSize) + `,`,
		`ExecutionOptions:` + strings.Replace(fmt.Sprintf("%v", this.ExecutionOptions), "ExecutionOptions", "ExecutionOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PredictorOpenRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PredictorOpenRequest{`,
		`ModelName:` + fmt.Sprintf("%v", this.ModelName) + `,`,
		`ModelVersion:` + fmt.Sprintf("%v", this.ModelVersion) + `,`,
		`FrameworkName:` + fmt.Sprintf("%v", this.FrameworkName) + `,`,
		`FrameworkVersion:` + fmt.Sprintf("%v", this.FrameworkVersion) + `,`,
		`Options:` + strings.Replace(fmt.Sprintf("%v", this.Options), "PredictionOptions", "PredictionOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PredictorCloseResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PredictorCloseResponse{`,
		`}`,
	}, "")
	return s
}
func (this *Predictor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Predictor{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLsRequest{`,
		`Predictor:` + strings.Replace(fmt.Sprintf("%v", this.Predictor), "Predictor", "Predictor", 1) + `,`,
		`Urls:` + strings.Replace(fmt.Sprintf("%v", this.Urls), "URLsRequest_URL", "URLsRequest_URL", 1) + `,`,
		`Options:` + strings.Replace(fmt.Sprintf("%v", this.Options), "PredictionOptions", "PredictionOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLsRequest_URL) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLsRequest_URL{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImagesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImagesRequest{`,
		`Predictor:` + strings.Replace(fmt.Sprintf("%v", this.Predictor), "Predictor", "Predictor", 1) + `,`,
		`Images:` + strings.Replace(fmt.Sprintf("%v", this.Images), "ImagesRequest_Image", "ImagesRequest_Image", 1) + `,`,
		`Options:` + strings.Replace(fmt.Sprintf("%v", this.Options), "PredictionOptions", "PredictionOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImagesRequest_Image) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImagesRequest_Image{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DatasetRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DatasetRequest{`,
		`Predictor:` + strings.Replace(fmt.Sprintf("%v", this.Predictor), "Predictor", "Predictor", 1) + `,`,
		`Dataset:` + strings.Replace(fmt.Sprintf("%v", this.Dataset), "DatasetRequest_Dataset", "DatasetRequest_Dataset", 1) + `,`,
		`Options:` + strings.Replace(fmt.Sprintf("%v", this.Options), "PredictionOptions", "PredictionOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DatasetRequest_Dataset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DatasetRequest_Dataset{`,
		`Category:` + fmt.Sprintf("%v", this.Category) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Feature) String() string {
	if this == nil {
		return "nil"
	}
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%v: %v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	s := strings.Join([]string{`&Feature{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Probability:` + fmt.Sprintf("%v", this.Probability) + `,`,
		`Metadata:` + mapStringForMetadata + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeatureResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%v: %v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	s := strings.Join([]string{`&FeatureResponse{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`InputID:` + fmt.Sprintf("%v", this.InputID) + `,`,
		`Features:` + strings.Replace(fmt.Sprintf("%v", this.Features), "Feature", "Feature", 1) + `,`,
		`Metadata:` + mapStringForMetadata + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeaturesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeaturesResponse{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Responses:` + strings.Replace(fmt.Sprintf("%v", this.Responses), "FeatureResponse", "FeatureResponse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResetRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResetRequest{`,
		`Predictor:` + strings.Replace(fmt.Sprintf("%v", this.Predictor), "Predictor", "Predictor", 1) + `,`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResetResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResetResponse{`,
		`Predictor:` + strings.Replace(fmt.Sprintf("%v", this.Predictor), "Predictor", "Predictor", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPredictor(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CPUOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerProcessGpuMemoryFraction", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PerProcessGpuMemoryFraction = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocatorType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisibleDeviceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VisibleDeviceList = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceGpuCompatible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceGpuCompatible = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLevel", wireType)
			}
			m.TraceLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceLevel |= (ExecutionOptions_TraceLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutInMs", wireType)
			}
			m.TimeoutInMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutInMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceCount == nil {
				m.DeviceCount = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPredictor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPredictor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPredictor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPredictor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPredictor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPredictor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DeviceCount[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CpuOptions == nil {
				m.CpuOptions = &CPUOptions{}
			}
			if err := m.CpuOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpuOptions == nil {
				m.GpuOptions = &GPUOptions{}
			}
			if err := m.GpuOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredictionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredictionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredictionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureLimit", wireType)
			}
			m.FeatureLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeatureLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecutionOptions == nil {
				m.ExecutionOptions = &ExecutionOptions{}
			}
			if err := m.ExecutionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredictorOpenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredictorOpenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredictorOpenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrameworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameworkVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrameworkVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &PredictionOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredictorCloseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredictorCloseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredictorCloseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Predictor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Predictor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Predictor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predictor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Predictor == nil {
				m.Predictor = &Predictor{}
			}
			if err := m.Predictor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Urls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Urls = append(m.Urls, &URLsRequest_URL{})
			if err := m.Urls[len(m.Urls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &PredictionOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLsRequest_URL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predictor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Predictor == nil {
				m.Predictor = &Predictor{}
			}
			if err := m.Predictor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, &ImagesRequest_Image{})
			if err := m.Images[len(m.Images)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &PredictionOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImagesRequest_Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatasetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatasetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatasetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predictor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Predictor == nil {
				m.Predictor = &Predictor{}
			}
			if err := m.Predictor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dataset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dataset == nil {
				m.Dataset = &DatasetRequest_Dataset{}
			}
			if err := m.Dataset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &PredictionOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatasetRequest_Dataset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dataset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dataset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Feature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Feature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Feature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Probability", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Probability = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPredictor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPredictor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPredictor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPredictor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPredictor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPredictor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPredictor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Features = append(m.Features, &Feature{})
			if err := m.Features[len(m.Features)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPredictor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPredictor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPredictor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPredictor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPredictor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPredictor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPredictor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeaturesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeaturesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeaturesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, &FeatureResponse{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predictor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Predictor == nil {
				m.Predictor = &Predictor{}
			}
			if err := m.Predictor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predictor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredictor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Predictor == nil {
				m.Predictor = &Predictor{}
			}
			if err := m.Predictor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredictor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredictor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPredictor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPredictor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPredictor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPredictor
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPredictor
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPredictor(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPredictor = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPredictor   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("predictor.proto", fileDescriptorPredictor) }
func init() { golang_proto.RegisterFile("predictor.proto", fileDescriptorPredictor) }

var fileDescriptorPredictor = []byte{
	// 1760 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xcd, 0x6f, 0x23, 0x67,
	0x19, 0xdf, 0xf1, 0xd8, 0x9b, 0xe4, 0x71, 0x9c, 0xcd, 0xbe, 0x9b, 0xdd, 0x3a, 0xce, 0x76, 0xc6,
	0x3b, 0xdd, 0xb6, 0xa6, 0x34, 0x4e, 0x14, 0x7a, 0x28, 0x8b, 0x58, 0x29, 0x93, 0x2f, 0x02, 0xde,
	0x4d, 0xe4, 0xdd, 0x50, 0x0a, 0x12, 0xc3, 0x78, 0xfc, 0xc6, 0x1d, 0xd5, 0xe3, 0x19, 0xe6, 0x23,
	0xad, 0x17, 0x84, 0x00, 0xc1, 0x89, 0x0b, 0x12, 0x7f, 0x00, 0x70, 0xeb, 0x8d, 0x03, 0x1c, 0xb8,
	0x20, 0x55, 0x9c, 0x38, 0x56, 0x42, 0x42, 0x88, 0xc3, 0xa8, 0xeb, 0x72, 0xe2, 0x54, 0xf9, 0xc4,
	0x11, 0xbd, 0x1f, 0x33, 0x7e, 0xc7, 0x1b, 0xc7, 0x86, 0x6d, 0xc3, 0xcd, 0xef, 0xf3, 0x3c, 0xef,
	0xef, 0xf7, 0x7c, 0xce, 0xfb, 0x24, 0x70, 0xcd, 0xf3, 0x71, 0xdb, 0xb6, 0x42, 0xd7, 0xaf, 0x7b,
	0xbe, 0x1b, 0xba, 0xe8, 0xa6, 0x65, 0xfa, 0x4e, 0xb7, 0xee, 0xfa, 0x9d, 0x7a, 0xbb, 0x7b, 0xea,
	0x9b, 0x0e, 0x7e, 0xcf, 0xf5, 0xdf, 0xad, 0xdc, 0xee, 0xb8, 0x6e, 0xa7, 0x8b, 0x37, 0x4c, 0xcf,
	0xde, 0x30, 0x7b, 0x3d, 0x37, 0x34, 0x43, 0xdb, 0xed, 0x05, 0xec, 0x52, 0x65, 0xbd, 0x63, 0x87,
	0xef, 0x44, 0xad, 0xba, 0xe5, 0x3a, 0x1b, 0x1d, 0xb7, 0xe3, 0x6e, 0x50, 0x71, 0x2b, 0x3a, 0xa5,
	0x27, 0x7a, 0xa0, 0xbf, 0x98, 0xb9, 0xb6, 0x08, 0xb0, 0x73, 0x7c, 0x72, 0xe4, 0x51, 0x08, 0xed,
	0x17, 0x32, 0xc0, 0x41, 0x7a, 0x44, 0x4f, 0x40, 0xf5, 0xb0, 0x6f, 0x78, 0xbe, 0x6b, 0xe1, 0x20,
	0x30, 0x3a, 0x5e, 0x64, 0x38, 0xd8, 0x71, 0xfd, 0xbe, 0x71, 0xea, 0x9b, 0x16, 0xb1, 0x29, 0x4b,
	0x55, 0xa9, 0x26, 0xe9, 0x6f, 0x0c, 0x63, 0x75, 0xb3, 0x6f, 0x3a, 0xdd, 0x7b, 0xda, 0x94, 0x0b,
	0xaf, 0xbb, 0x8e, 0x1d, 0x62, 0xc7, 0x0b, 0xfb, 0x5a, 0x73, 0xcd, 0xc3, 0xfe, 0x31, 0x33, 0x3d,
	0xf0, 0xa2, 0x07, 0xd4, 0x70, 0x9f, 0xdb, 0xa1, 0xaf, 0xc3, 0x92, 0xd9, 0xed, 0xba, 0x96, 0x19,
	0xba, 0xbe, 0x11, 0xf6, 0x3d, 0x5c, 0xce, 0x55, 0xa5, 0xda, 0x82, 0xfe, 0xd2, 0x30, 0x56, 0x55,
	0x46, 0x95, 0xd5, 0x8b, 0xc8, 0xa5, 0x54, 0xf5, 0xb8, 0xef, 0x61, 0xf4, 0x2d, 0xb8, 0x71, 0x66,
	0x07, 0x76, 0xab, 0x8b, 0x8d, 0x36, 0x3e, 0xb3, 0x2d, 0x6c, 0x74, 0xed, 0x20, 0x2c, 0x17, 0x28,
	0x60, 0x6d, 0x18, 0xab, 0x77, 0x19, 0xe0, 0x39, 0x46, 0x22, 0xea, 0x75, 0xae, 0xdf, 0xa5, 0xea,
	0x86, 0x1d, 0x84, 0xe8, 0x3b, 0xb0, 0x72, 0xea, 0xfa, 0x16, 0xa6, 0xa1, 0x5a, 0xae, 0xe3, 0x99,
	0x21, 0xb1, 0x28, 0xcf, 0x57, 0xa5, 0xda, 0xbc, 0xfe, 0x85, 0x61, 0xac, 0xbe, 0xcc, 0xa0, 0xcf,
	0xb3, 0x12, 0xb1, 0x11, 0x35, 0x38, 0xf0, 0xa2, 0x9d, 0x54, 0xad, 0xfd, 0xad, 0x00, 0xcb, 0x7b,
	0xef, 0x63, 0x2b, 0x22, 0x09, 0x49, 0x6a, 0x12, 0x41, 0x31, 0xf4, 0x4d, 0xe2, 0x1d, 0x3e, 0xc3,
	0x5d, 0x9a, 0xff, 0xa5, 0xad, 0xad, 0xfa, 0xb9, 0xad, 0x52, 0x1f, 0xbf, 0x5d, 0x7f, 0x4c, 0xae,
	0x36, 0xc8, 0x4d, 0xbd, 0x3a, 0x8c, 0xd5, 0xdb, 0xcc, 0x39, 0x01, 0x50, 0xf4, 0x09, 0xc2, 0xd4,
	0x1a, 0xed, 0x43, 0x29, 0xb4, 0x1d, 0xec, 0x46, 0xa1, 0x61, 0xf7, 0x0c, 0x27, 0xa0, 0xd5, 0x90,
	0x75, 0x6d, 0x18, 0xab, 0x0a, 0x07, 0x11, 0xd5, 0x22, 0x4c, 0x91, 0x6b, 0x0e, 0x7b, 0x0f, 0x02,
	0xf4, 0x23, 0x58, 0xe4, 0xd9, 0xb5, 0xdc, 0xa8, 0x17, 0x96, 0xe5, 0xaa, 0x5c, 0x2b, 0x6e, 0xbd,
	0x39, 0xab, 0xff, 0x2c, 0xf5, 0x3b, 0xe4, 0xea, 0x5e, 0x2f, 0xf4, 0xfb, 0xfa, 0x9d, 0x61, 0xac,
	0xbe, 0xc8, 0x1c, 0x10, 0x71, 0x33, 0xfc, 0xed, 0xd1, 0x25, 0xd4, 0x86, 0xa2, 0xe5, 0x45, 0x86,
	0xcb, 0xf0, 0xca, 0xf9, 0xaa, 0x54, 0x2b, 0x6e, 0xdd, 0x99, 0x40, 0x3f, 0x9a, 0x0c, 0x31, 0x5b,
	0xc2, 0xfd, 0x4c, 0xb6, 0x2c, 0x2f, 0x4a, 0x8a, 0xd4, 0x86, 0x62, 0x47, 0x60, 0x29, 0x5c, 0xc8,
	0x72, 0x70, 0x2e, 0x4b, 0x67, 0x02, 0x4b, 0x27, 0x65, 0xa9, 0xdc, 0x87, 0xe5, 0xf1, 0x7c, 0xa0,
	0x65, 0x90, 0xdf, 0xc5, 0x7d, 0xda, 0x16, 0x0b, 0x4d, 0xf2, 0x13, 0xad, 0x40, 0xe1, 0xcc, 0xec,
	0x46, 0x6c, 0x7e, 0x0a, 0x4d, 0x76, 0xb8, 0x97, 0x7b, 0x53, 0xd2, 0xde, 0x03, 0x18, 0xf5, 0x03,
	0x5a, 0x84, 0xf9, 0x87, 0x47, 0xc6, 0xe3, 0xe6, 0xf6, 0xce, 0xde, 0xf2, 0x15, 0xb4, 0x04, 0xf0,
	0xe8, 0xf1, 0xde, 0x31, 0x3f, 0x4b, 0xe8, 0x06, 0x5c, 0xdb, 0x6f, 0x6e, 0x3f, 0xd8, 0x7b, 0xeb,
	0xa8, 0xf9, 0x0d, 0x2e, 0xcc, 0x21, 0x04, 0x4b, 0x3b, 0xc7, 0x27, 0xc6, 0xd1, 0xc3, 0xc6, 0xdb,
	0x5c, 0x26, 0x13, 0xd9, 0xd7, 0xb6, 0x9b, 0xbb, 0x6f, 0x6d, 0x37, 0xf7, 0xb8, 0x2c, 0x4f, 0xc0,
	0xf6, 0x4f, 0x1a, 0x0d, 0x7e, 0x2e, 0x68, 0x3f, 0x97, 0xe1, 0xfa, 0x31, 0xfb, 0xd8, 0x09, 0x9d,
	0x6d, 0x01, 0xf8, 0xf8, 0xfb, 0x11, 0x0e, 0x42, 0xc3, 0x6e, 0xb3, 0x08, 0xf4, 0xdd, 0x41, 0xac,
	0x2e, 0x34, 0x99, 0xf4, 0x70, 0xf7, 0x5f, 0xb1, 0xba, 0x32, 0x32, 0x19, 0xa5, 0x65, 0x18, 0xab,
	0x6b, 0x2c, 0x6b, 0xe7, 0x69, 0xb5, 0xe6, 0x02, 0x17, 0x1f, 0xb6, 0xd1, 0x01, 0x94, 0x4e, 0xb1,
	0x19, 0x46, 0x3e, 0x19, 0x6f, 0xc7, 0x0e, 0x59, 0x56, 0xc4, 0x3e, 0xce, 0xa8, 0x45, 0x94, 0x45,
	0xae, 0x69, 0x10, 0x05, 0xba, 0x0f, 0xd0, 0x32, 0x43, 0xeb, 0x1d, 0x23, 0xb0, 0x9f, 0xe0, 0xb2,
	0x5c, 0x95, 0x6a, 0x25, 0x5d, 0x1d, 0x39, 0x32, 0xd2, 0x65, 0x1c, 0xa1, 0xe2, 0x47, 0xf6, 0x13,
	0x8c, 0x7e, 0x08, 0xd7, 0x71, 0xd2, 0xdd, 0x63, 0xed, 0xf8, 0xea, 0x8c, 0xd3, 0xa0, 0xbf, 0x32,
	0x8c, 0x55, 0x8d, 0xf1, 0x3d, 0x83, 0x25, 0xd2, 0x2e, 0xe3, 0xb1, 0x9b, 0xf7, 0xf2, 0x9f, 0xfe,
	0x46, 0x95, 0xb4, 0x0f, 0x64, 0x58, 0x39, 0x4e, 0x1e, 0x9d, 0x23, 0x0f, 0xf7, 0x78, 0xa6, 0x49,
	0x70, 0x8e, 0xdb, 0xc6, 0x5d, 0xa3, 0x67, 0x3a, 0x98, 0x97, 0x42, 0x08, 0x6e, 0xa4, 0xcb, 0x04,
	0x47, 0xc5, 0x0f, 0x4d, 0x07, 0x93, 0x2c, 0x33, 0x9b, 0x33, 0xec, 0x07, 0xe4, 0x99, 0x60, 0xdf,
	0x6e, 0x21, 0xcb, 0x19, 0x75, 0x26, 0xcb, 0x54, 0xf3, 0x4d, 0xa6, 0x20, 0xaf, 0x40, 0x1a, 0x3f,
	0x73, 0x46, 0x1e, 0x7f, 0x05, 0xb2, 0xfa, 0xcc, 0x2b, 0x90, 0xaa, 0xa8, 0x53, 0x8f, 0xe0, 0xfa,
	0xc8, 0x36, 0x71, 0x2c, 0x4f, 0xe1, 0x84, 0x44, 0x3e, 0x63, 0x92, 0x49, 0x64, 0xaa, 0x4d, 0x1c,
	0xfc, 0x1e, 0xcc, 0x65, 0xa7, 0xbc, 0x36, 0xa1, 0x78, 0xcf, 0xf4, 0xbb, 0x7e, 0x7b, 0x18, 0xab,
	0x65, 0x46, 0x7a, 0x4e, 0xcd, 0x12, 0x58, 0x5e, 0xaa, 0x32, 0xdc, 0x4a, 0x2b, 0xb5, 0xd3, 0x75,
	0x03, 0xdc, 0xc4, 0x81, 0xe7, 0xf6, 0x02, 0xac, 0x1d, 0xc3, 0x42, 0xaa, 0x41, 0x5f, 0x85, 0x5c,
	0x3a, 0x3b, 0xeb, 0x83, 0x58, 0xcd, 0xd1, 0xa1, 0x59, 0x1c, 0x1b, 0x96, 0x1b, 0x8c, 0x35, 0x3b,
	0x24, 0x39, 0xbb, 0xcd, 0xb9, 0x7e, 0x2b, 0x43, 0xf1, 0xa4, 0xd9, 0x08, 0x92, 0x6e, 0xf8, 0x2e,
	0x2c, 0xa4, 0xab, 0x09, 0xc5, 0x2e, 0x6e, 0x55, 0x2f, 0x8e, 0xd2, 0xf5, 0x75, 0x65, 0x18, 0xab,
	0x15, 0xbe, 0x12, 0x24, 0xc2, 0x4c, 0xb7, 0xa4, 0x52, 0x74, 0x02, 0xf9, 0xc8, 0xef, 0x92, 0x27,
	0x85, 0xbc, 0x05, 0xaf, 0x4c, 0x80, 0x16, 0x3c, 0x22, 0xbf, 0xf5, 0xd5, 0x61, 0xac, 0xde, 0x64,
	0x04, 0xe4, 0xb6, 0x88, 0x4d, 0xe1, 0xc4, 0xd2, 0xc8, 0x9f, 0x4b, 0x69, 0x2a, 0x01, 0xc8, 0x27,
	0xcd, 0xc6, 0x73, 0x26, 0x1d, 0xad, 0x43, 0xbe, 0x6d, 0x86, 0x26, 0x9f, 0x11, 0x21, 0x2c, 0x22,
	0xcd, 0x84, 0x45, 0x04, 0xbc, 0x46, 0xbf, 0x93, 0xa1, 0x74, 0xe8, 0x98, 0x1d, 0x7c, 0x69, 0x55,
	0x32, 0xe0, 0xaa, 0x4d, 0x09, 0x79, 0x9d, 0x5e, 0x9b, 0x00, 0x9e, 0xf1, 0x8a, 0x9d, 0xf4, 0xb5,
	0x61, 0xac, 0xbe, 0xc0, 0xe3, 0xa7, 0x6a, 0x91, 0x83, 0xc3, 0x5e, 0x42, 0xbd, 0x22, 0x28, 0x50,
	0x7f, 0x3e, 0xcb, 0x8a, 0x2d, 0xce, 0x5a, 0xb1, 0x3f, 0xc8, 0xb0, 0xb4, 0x6b, 0x86, 0x66, 0x80,
	0xc3, 0xcb, 0x2a, 0x19, 0x86, 0xb9, 0x36, 0x63, 0xa4, 0xae, 0x16, 0xb7, 0xd6, 0x27, 0xa0, 0x67,
	0xfd, 0x4a, 0x8e, 0x62, 0x5a, 0x39, 0x4e, 0x26, 0xad, 0x5c, 0x76, 0x29, 0x83, 0x36, 0xc7, 0x7d,
	0x42, 0x5f, 0x86, 0x79, 0xcb, 0x0c, 0x71, 0xc7, 0xf5, 0xf9, 0x96, 0xa3, 0xbf, 0x38, 0x8c, 0xd5,
	0x55, 0xbe, 0x9a, 0x71, 0x8d, 0x08, 0x92, 0x9a, 0x93, 0xb2, 0xd1, 0x27, 0xe4, 0x99, 0x41, 0x1b,
	0x7f, 0x38, 0xa8, 0x19, 0x2f, 0xdb, 0x3f, 0x72, 0x30, 0xb7, 0xcf, 0x1e, 0x7e, 0xb4, 0x09, 0x05,
	0xbb, 0xd7, 0xc6, 0xef, 0x53, 0x62, 0x59, 0xaf, 0x0c, 0x63, 0xf5, 0x16, 0xef, 0x11, 0x22, 0x16,
	0x21, 0x98, 0xe1, 0x7f, 0x49, 0x89, 0x74, 0x28, 0x7a, 0xbe, 0xdb, 0x32, 0x5b, 0x76, 0xd7, 0x0e,
	0xfb, 0x34, 0x9b, 0x39, 0x71, 0x29, 0x14, 0x94, 0x99, 0x0d, 0x57, 0x90, 0xa3, 0x0e, 0xcc, 0x3b,
	0x38, 0x34, 0x69, 0x83, 0xe6, 0xe9, 0xa4, 0xbe, 0x3e, 0xa1, 0x1c, 0x3c, 0xac, 0xfa, 0x03, 0x6e,
	0xce, 0x36, 0x6a, 0x21, 0x9d, 0x09, 0x4e, 0x26, 0x9d, 0x89, 0xb0, 0xf2, 0x15, 0x28, 0x65, 0x6e,
	0x4e, 0xdb, 0x3d, 0x17, 0x84, 0xdd, 0x93, 0x27, 0xf7, 0xd7, 0x79, 0xb8, 0xc6, 0xbd, 0x48, 0xde,
	0xb3, 0xe7, 0x9d, 0xcd, 0xec, 0x16, 0x99, 0xfb, 0x7c, 0xb6, 0xc8, 0xb7, 0x61, 0xde, 0xee, 0x79,
	0x11, 0xa5, 0x60, 0x0b, 0xc9, 0xfd, 0x41, 0xac, 0xce, 0x1d, 0x12, 0x19, 0x25, 0x40, 0x89, 0x3a,
	0x03, 0xbf, 0x9a, 0x34, 0xcb, 0xb8, 0x4e, 0x6b, 0xce, 0x51, 0x21, 0x83, 0xe6, 0x7b, 0x66, 0xc0,
	0xcb, 0xa7, 0x5c, 0x5c, 0x3e, 0xb1, 0x60, 0xc9, 0xcd, 0x4c, 0xc1, 0x12, 0x21, 0x72, 0x85, 0xce,
	0x28, 0x50, 0xe8, 0x37, 0x2e, 0x86, 0x4e, 0x6a, 0xf2, 0x7f, 0xec, 0x90, 0x3f, 0x49, 0xb0, 0xcc,
	0xbd, 0x09, 0x3e, 0xab, 0x16, 0x69, 0xc3, 0x82, 0xcf, 0xa1, 0xa6, 0x2d, 0x1d, 0x63, 0x89, 0x10,
	0x3f, 0xbe, 0x29, 0xc4, 0x58, 0x8f, 0x70, 0x29, 0xf7, 0xff, 0xf7, 0x12, 0x2c, 0x36, 0xf1, 0x25,
	0x7e, 0xf3, 0x59, 0x6e, 0x72, 0xcf, 0xb7, 0x01, 0xf6, 0xa1, 0xc4, 0x9d, 0xe6, 0x19, 0x6f, 0xfd,
	0x2f, 0x5e, 0x6b, 0x1f, 0xc5, 0xaa, 0x34, 0xb3, 0xe7, 0x8c, 0x7a, 0xeb, 0xcf, 0xf3, 0x30, 0xc7,
	0x21, 0x90, 0x0b, 0x79, 0xf2, 0x57, 0x09, 0xfa, 0xe2, 0x34, 0x2a, 0xe1, 0x6f, 0x97, 0xca, 0x54,
	0xbf, 0xb4, 0xf2, 0x4f, 0xff, 0xfa, 0xcf, 0x5f, 0xe5, 0x90, 0x56, 0xda, 0xe0, 0xe4, 0x1b, 0xae,
	0x87, 0x7b, 0xf7, 0xa4, 0xd7, 0x50, 0x00, 0x05, 0xba, 0x5c, 0xa3, 0xa9, 0x20, 0x95, 0xf5, 0x69,
	0x16, 0xd9, 0x2d, 0x7d, 0x95, 0x72, 0xde, 0xd0, 0x96, 0x52, 0x4e, 0x8b, 0xe8, 0x09, 0xa9, 0x03,
	0x79, 0xb2, 0xdb, 0x22, 0x6d, 0xfa, 0xe2, 0x5b, 0x79, 0xf5, 0xe2, 0x3e, 0x4d, 0x47, 0xe4, 0x9c,
	0x18, 0xc9, 0x4e, 0x4c, 0xe8, 0x7e, 0x00, 0x40, 0x10, 0x1f, 0x85, 0x3e, 0x36, 0x9d, 0x99, 0x48,
	0x67, 0x1c, 0x0e, 0x4d, 0xa5, 0x9c, 0xab, 0xda, 0x4a, 0xca, 0x19, 0x50, 0x92, 0x84, 0x7a, 0x53,
	0x42, 0x01, 0x5c, 0x65, 0xfb, 0x21, 0xba, 0x3b, 0xcb, 0xfa, 0x38, 0x7b, 0xbc, 0x15, 0xca, 0xbd,
	0xa2, 0x5d, 0x4b, 0xb9, 0xd9, 0x56, 0x49, 0x22, 0xfe, 0x89, 0x04, 0x8b, 0x0c, 0x96, 0x07, 0x3d,
	0x1b, 0xf7, 0xac, 0x61, 0xdf, 0xa1, 0xd4, 0x6b, 0xda, 0xad, 0xf1, 0xb0, 0x53, 0x0f, 0x36, 0x25,
	0x74, 0x36, 0xda, 0x60, 0x5e, 0x9e, 0x69, 0x09, 0x9b, 0x3d, 0xf4, 0x35, 0xca, 0x7f, 0x53, 0x5b,
	0x4e, 0xf9, 0xf9, 0x62, 0x46, 0x62, 0xff, 0x99, 0x04, 0x25, 0x0e, 0xcc, 0x83, 0x9f, 0x91, 0x7e,
	0xd6, 0xe8, 0x35, 0xca, 0x7e, 0x5b, 0x7b, 0x61, 0x3c, 0xfa, 0x91, 0x13, 0x9b, 0x12, 0x72, 0xa0,
	0x40, 0x3f, 0x28, 0xe8, 0xa5, 0x09, 0xb0, 0xe2, 0x37, 0xb2, 0x72, 0xf7, 0x62, 0xa3, 0x89, 0x23,
	0xe5, 0x63, 0x46, 0xa8, 0x6f, 0xff, 0xfd, 0xa9, 0x72, 0xe5, 0xe3, 0xa7, 0x8a, 0xf4, 0xe9, 0x53,
	0x45, 0xfa, 0xf7, 0x53, 0x45, 0xfa, 0xf1, 0x40, 0x91, 0x3e, 0x18, 0x28, 0xd2, 0x1f, 0x07, 0x8a,
	0xf4, 0xe1, 0x40, 0x91, 0xfe, 0x32, 0x50, 0xa4, 0x8f, 0x06, 0x8a, 0xf4, 0xf1, 0x40, 0x91, 0x7e,
	0xf9, 0x89, 0x72, 0xe5, 0xc3, 0x4f, 0x14, 0xe9, 0xdb, 0x45, 0x81, 0xab, 0x75, 0x95, 0xfe, 0x7f,
	0xfc, 0x4b, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0xcb, 0x96, 0x42, 0x2a, 0x96, 0x17, 0x00, 0x00,
}
