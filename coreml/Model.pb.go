// Code generated by protoc-gen-gogo.
// source: Model.proto
// DO NOT EDIT!

package CoreML

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Ignoring public import of ArrayFeatureExtractor from ArrayFeatureExtractor.proto

// Ignoring public import of CategoricalMapping from CategoricalMapping.proto

// Ignoring public import of DictVectorizer from DictVectorizer.proto

// Ignoring public import of Int64FeatureType from FeatureTypes.proto

// Ignoring public import of DoubleFeatureType from FeatureTypes.proto

// Ignoring public import of StringFeatureType from FeatureTypes.proto

// Ignoring public import of ImageFeatureType from FeatureTypes.proto

// Ignoring public import of ArrayFeatureType from FeatureTypes.proto

// Ignoring public import of DictionaryFeatureType from FeatureTypes.proto

// Ignoring public import of FeatureType from FeatureTypes.proto

// Ignoring public import of ColorSpace from FeatureTypes.proto

// Ignoring public import of ArrayDataType from FeatureTypes.proto

// Ignoring public import of FeatureVectorizer from FeatureVectorizer.proto

// Ignoring public import of InputColumn from FeatureVectorizer.proto

// Ignoring public import of GLMRegressor from GLMRegressor.proto

// Ignoring public import of DoubleArray from GLMRegressor.proto

// Ignoring public import of PostEvaluationTransform from GLMRegressor.proto

// Ignoring public import of GLMClassifier from GLMClassifier.proto

// Ignoring public import of DoubleArray from GLMClassifier.proto

// Ignoring public import of PostEvaluationTransform from GLMClassifier.proto

// Ignoring public import of ClassEncoding from GLMClassifier.proto

// Ignoring public import of Identity from Identity.proto

// Ignoring public import of Imputer from Imputer.proto

// Ignoring public import of NeuralNetwork from NeuralNetwork.proto

// Ignoring public import of NeuralNetworkImageScaler from NeuralNetwork.proto

// Ignoring public import of NeuralNetworkMeanImage from NeuralNetwork.proto

// Ignoring public import of NeuralNetworkPreprocessing from NeuralNetwork.proto

// Ignoring public import of ActivationReLU from NeuralNetwork.proto

// Ignoring public import of ActivationLeakyReLU from NeuralNetwork.proto

// Ignoring public import of ActivationTanh from NeuralNetwork.proto

// Ignoring public import of ActivationScaledTanh from NeuralNetwork.proto

// Ignoring public import of ActivationSigmoid from NeuralNetwork.proto

// Ignoring public import of ActivationLinear from NeuralNetwork.proto

// Ignoring public import of ActivationSigmoidHard from NeuralNetwork.proto

// Ignoring public import of ActivationPReLU from NeuralNetwork.proto

// Ignoring public import of ActivationELU from NeuralNetwork.proto

// Ignoring public import of ActivationThresholdedReLU from NeuralNetwork.proto

// Ignoring public import of ActivationSoftsign from NeuralNetwork.proto

// Ignoring public import of ActivationSoftplus from NeuralNetwork.proto

// Ignoring public import of ActivationParametricSoftplus from NeuralNetwork.proto

// Ignoring public import of ActivationParams from NeuralNetwork.proto

// Ignoring public import of NeuralNetworkLayer from NeuralNetwork.proto

// Ignoring public import of BorderAmounts from NeuralNetwork.proto

// Ignoring public import of EdgeSizes from NeuralNetwork.proto

// Ignoring public import of ValidPadding from NeuralNetwork.proto

// Ignoring public import of SamePadding from NeuralNetwork.proto

// Ignoring public import of WeightParams from NeuralNetwork.proto

// Ignoring public import of ConvolutionLayerParams from NeuralNetwork.proto

// Ignoring public import of InnerProductLayerParams from NeuralNetwork.proto

// Ignoring public import of EmbeddingLayerParams from NeuralNetwork.proto

// Ignoring public import of BatchnormLayerParams from NeuralNetwork.proto

// Ignoring public import of PoolingLayerParams from NeuralNetwork.proto

// Ignoring public import of ValidCompletePadding from NeuralNetwork.proto

// Ignoring public import of PaddingLayerParams from NeuralNetwork.proto

// Ignoring public import of PaddingConstant from NeuralNetwork.proto

// Ignoring public import of PaddingReflection from NeuralNetwork.proto

// Ignoring public import of PaddingReplication from NeuralNetwork.proto

// Ignoring public import of ConcatLayerParams from NeuralNetwork.proto

// Ignoring public import of LRNLayerParams from NeuralNetwork.proto

// Ignoring public import of SoftmaxLayerParams from NeuralNetwork.proto

// Ignoring public import of SplitLayerParams from NeuralNetwork.proto

// Ignoring public import of AddLayerParams from NeuralNetwork.proto

// Ignoring public import of MultiplyLayerParams from NeuralNetwork.proto

// Ignoring public import of UnaryFunctionLayerParams from NeuralNetwork.proto

// Ignoring public import of UpsampleLayerParams from NeuralNetwork.proto

// Ignoring public import of BiasLayerParams from NeuralNetwork.proto

// Ignoring public import of ScaleLayerParams from NeuralNetwork.proto

// Ignoring public import of LoadConstantLayerParams from NeuralNetwork.proto

// Ignoring public import of L2NormalizeLayerParams from NeuralNetwork.proto

// Ignoring public import of FlattenLayerParams from NeuralNetwork.proto

// Ignoring public import of ReshapeLayerParams from NeuralNetwork.proto

// Ignoring public import of PermuteLayerParams from NeuralNetwork.proto

// Ignoring public import of ReduceLayerParams from NeuralNetwork.proto

// Ignoring public import of CropLayerParams from NeuralNetwork.proto

// Ignoring public import of AverageLayerParams from NeuralNetwork.proto

// Ignoring public import of MaxLayerParams from NeuralNetwork.proto

// Ignoring public import of MinLayerParams from NeuralNetwork.proto

// Ignoring public import of DotProductLayerParams from NeuralNetwork.proto

// Ignoring public import of MeanVarianceNormalizeLayerParams from NeuralNetwork.proto

// Ignoring public import of SequenceRepeatLayerParams from NeuralNetwork.proto

// Ignoring public import of SimpleRecurrentLayerParams from NeuralNetwork.proto

// Ignoring public import of GRULayerParams from NeuralNetwork.proto

// Ignoring public import of LSTMParams from NeuralNetwork.proto

// Ignoring public import of LSTMWeightParams from NeuralNetwork.proto

// Ignoring public import of UniDirectionalLSTMLayerParams from NeuralNetwork.proto

// Ignoring public import of BiDirectionalLSTMLayerParams from NeuralNetwork.proto

// Ignoring public import of NeuralNetworkClassifier from NeuralNetwork.proto

// Ignoring public import of NeuralNetworkRegressor from NeuralNetwork.proto

// Ignoring public import of SamePaddingMode from NeuralNetwork.proto

// Ignoring public import of PoolingType from NeuralNetwork.proto

// Ignoring public import of Operation from NeuralNetwork.proto

// Ignoring public import of FlattenOrder from NeuralNetwork.proto

// Ignoring public import of ReshapeOrder from NeuralNetwork.proto

// Ignoring public import of ReduceOperation from NeuralNetwork.proto

// Ignoring public import of Normalizer from Normalizer.proto

// Ignoring public import of NormType from Normalizer.proto

// Ignoring public import of OneHotEncoder from OneHotEncoder.proto

// Ignoring public import of HandleUnknown from OneHotEncoder.proto

// Ignoring public import of Scaler from Scaler.proto

// Ignoring public import of LinearKernel from SVM.proto

// Ignoring public import of RBFKernel from SVM.proto

// Ignoring public import of PolyKernel from SVM.proto

// Ignoring public import of SigmoidKernel from SVM.proto

// Ignoring public import of Kernel from SVM.proto

// Ignoring public import of SparseNode from SVM.proto

// Ignoring public import of SparseVector from SVM.proto

// Ignoring public import of SparseSupportVectors from SVM.proto

// Ignoring public import of DenseVector from SVM.proto

// Ignoring public import of DenseSupportVectors from SVM.proto

// Ignoring public import of Coefficients from SVM.proto

// Ignoring public import of SupportVectorRegressor from SVM.proto

// Ignoring public import of SupportVectorClassifier from SVM.proto

// Ignoring public import of TreeEnsembleParameters from TreeEnsemble.proto

// Ignoring public import of TreeNode from TreeEnsemble.proto

// Ignoring public import of EvaluationInfo from TreeEnsemble.proto

// Ignoring public import of TreeEnsembleClassifier from TreeEnsemble.proto

// Ignoring public import of TreeEnsembleRegressor from TreeEnsemble.proto

// Ignoring public import of TreeEnsemblePostEvaluationTransform from TreeEnsemble.proto

// Ignoring public import of TreeNodeBehavior from TreeEnsemble.proto

// *
// A pipeline consisting of one or more models.
type Pipeline struct {
	Models []*Model `protobuf:"bytes,1,rep,name=models" json:"models,omitempty"`
}

func (m *Pipeline) Reset()                    { *m = Pipeline{} }
func (m *Pipeline) String() string            { return proto.CompactTextString(m) }
func (*Pipeline) ProtoMessage()               {}
func (*Pipeline) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{0} }

func (m *Pipeline) GetModels() []*Model {
	if m != nil {
		return m.Models
	}
	return nil
}

// *
// A classifier pipeline.
type PipelineClassifier struct {
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
	// Required class label mapping
	//
	// Types that are valid to be assigned to ClassLabels:
	//	*PipelineClassifier_StringClassLabels
	//	*PipelineClassifier_Int64ClassLabels
	ClassLabels isPipelineClassifier_ClassLabels `protobuf_oneof:"ClassLabels"`
}

func (m *PipelineClassifier) Reset()                    { *m = PipelineClassifier{} }
func (m *PipelineClassifier) String() string            { return proto.CompactTextString(m) }
func (*PipelineClassifier) ProtoMessage()               {}
func (*PipelineClassifier) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{1} }

type isPipelineClassifier_ClassLabels interface {
	isPipelineClassifier_ClassLabels()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PipelineClassifier_StringClassLabels struct {
	StringClassLabels *StringVector `protobuf:"bytes,100,opt,name=stringClassLabels,oneof"`
}
type PipelineClassifier_Int64ClassLabels struct {
	Int64ClassLabels *Int64Vector `protobuf:"bytes,101,opt,name=int64ClassLabels,oneof"`
}

func (*PipelineClassifier_StringClassLabels) isPipelineClassifier_ClassLabels() {}
func (*PipelineClassifier_Int64ClassLabels) isPipelineClassifier_ClassLabels()  {}

func (m *PipelineClassifier) GetClassLabels() isPipelineClassifier_ClassLabels {
	if m != nil {
		return m.ClassLabels
	}
	return nil
}

func (m *PipelineClassifier) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *PipelineClassifier) GetStringClassLabels() *StringVector {
	if x, ok := m.GetClassLabels().(*PipelineClassifier_StringClassLabels); ok {
		return x.StringClassLabels
	}
	return nil
}

func (m *PipelineClassifier) GetInt64ClassLabels() *Int64Vector {
	if x, ok := m.GetClassLabels().(*PipelineClassifier_Int64ClassLabels); ok {
		return x.Int64ClassLabels
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PipelineClassifier) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PipelineClassifier_OneofMarshaler, _PipelineClassifier_OneofUnmarshaler, _PipelineClassifier_OneofSizer, []interface{}{
		(*PipelineClassifier_StringClassLabels)(nil),
		(*PipelineClassifier_Int64ClassLabels)(nil),
	}
}

func _PipelineClassifier_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PipelineClassifier)
	// ClassLabels
	switch x := m.ClassLabels.(type) {
	case *PipelineClassifier_StringClassLabels:
		_ = b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StringClassLabels); err != nil {
			return err
		}
	case *PipelineClassifier_Int64ClassLabels:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Int64ClassLabels); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PipelineClassifier.ClassLabels has unexpected type %T", x)
	}
	return nil
}

func _PipelineClassifier_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PipelineClassifier)
	switch tag {
	case 100: // ClassLabels.stringClassLabels
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringVector)
		err := b.DecodeMessage(msg)
		m.ClassLabels = &PipelineClassifier_StringClassLabels{msg}
		return true, err
	case 101: // ClassLabels.int64ClassLabels
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Int64Vector)
		err := b.DecodeMessage(msg)
		m.ClassLabels = &PipelineClassifier_Int64ClassLabels{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PipelineClassifier_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PipelineClassifier)
	// ClassLabels
	switch x := m.ClassLabels.(type) {
	case *PipelineClassifier_StringClassLabels:
		s := proto.Size(x.StringClassLabels)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PipelineClassifier_Int64ClassLabels:
		s := proto.Size(x.Int64ClassLabels)
		n += proto.SizeVarint(101<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// A regressor pipeline.
type PipelineRegressor struct {
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
}

func (m *PipelineRegressor) Reset()                    { *m = PipelineRegressor{} }
func (m *PipelineRegressor) String() string            { return proto.CompactTextString(m) }
func (*PipelineRegressor) ProtoMessage()               {}
func (*PipelineRegressor) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{2} }

func (m *PipelineRegressor) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

// *
// A feature description,
// consisting of a name, short description, and type.
type FeatureDescription struct {
	Name             string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ShortDescription string       `protobuf:"bytes,2,opt,name=shortDescription,proto3" json:"shortDescription,omitempty"`
	Type             *FeatureType `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
}

func (m *FeatureDescription) Reset()                    { *m = FeatureDescription{} }
func (m *FeatureDescription) String() string            { return proto.CompactTextString(m) }
func (*FeatureDescription) ProtoMessage()               {}
func (*FeatureDescription) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{3} }

func (m *FeatureDescription) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FeatureDescription) GetShortDescription() string {
	if m != nil {
		return m.ShortDescription
	}
	return ""
}

func (m *FeatureDescription) GetType() *FeatureType {
	if m != nil {
		return m.Type
	}
	return nil
}

// *
// Model metadata,
// consisting of a short description, a version string,
// an author, a license, and any other user defined
// key/value meta data.
type Metadata struct {
	ShortDescription string            `protobuf:"bytes,1,opt,name=shortDescription,proto3" json:"shortDescription,omitempty"`
	VersionString    string            `protobuf:"bytes,2,opt,name=versionString,proto3" json:"versionString,omitempty"`
	Author           string            `protobuf:"bytes,3,opt,name=author,proto3" json:"author,omitempty"`
	License          string            `protobuf:"bytes,4,opt,name=license,proto3" json:"license,omitempty"`
	UserDefined      map[string]string `protobuf:"bytes,100,rep,name=userDefined" json:"userDefined,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{4} }

func (m *Metadata) GetShortDescription() string {
	if m != nil {
		return m.ShortDescription
	}
	return ""
}

func (m *Metadata) GetVersionString() string {
	if m != nil {
		return m.VersionString
	}
	return ""
}

func (m *Metadata) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *Metadata) GetLicense() string {
	if m != nil {
		return m.License
	}
	return ""
}

func (m *Metadata) GetUserDefined() map[string]string {
	if m != nil {
		return m.UserDefined
	}
	return nil
}

// *
// A description of a model,
// consisting of descriptions of its input and output features.
// Both regressor and classifier models require the name of the
// primary predicted output feature (``predictedFeatureName``).
// Classifier models can specify the output feature containing
// probabilities for the predicted classes
// (``predictedProbabilitiesName``).
type ModelDescription struct {
	Input                      []*FeatureDescription `protobuf:"bytes,1,rep,name=input" json:"input,omitempty"`
	Output                     []*FeatureDescription `protobuf:"bytes,10,rep,name=output" json:"output,omitempty"`
	PredictedFeatureName       string                `protobuf:"bytes,11,opt,name=predictedFeatureName,proto3" json:"predictedFeatureName,omitempty"`
	PredictedProbabilitiesName string                `protobuf:"bytes,12,opt,name=predictedProbabilitiesName,proto3" json:"predictedProbabilitiesName,omitempty"`
	Metadata                   *Metadata             `protobuf:"bytes,100,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *ModelDescription) Reset()                    { *m = ModelDescription{} }
func (m *ModelDescription) String() string            { return proto.CompactTextString(m) }
func (*ModelDescription) ProtoMessage()               {}
func (*ModelDescription) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{5} }

func (m *ModelDescription) GetInput() []*FeatureDescription {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *ModelDescription) GetOutput() []*FeatureDescription {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *ModelDescription) GetPredictedFeatureName() string {
	if m != nil {
		return m.PredictedFeatureName
	}
	return ""
}

func (m *ModelDescription) GetPredictedProbabilitiesName() string {
	if m != nil {
		return m.PredictedProbabilitiesName
	}
	return ""
}

func (m *ModelDescription) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// *
// A Core ML model,
// consisting of a specification version,
// a model description, and a model type.
//
// Core ML model compatibility is indicated by
// a monotonically increasing specification version number,
// which is incremented anytime a backward-incompatible change is made
// (this is functionally equivalent to the MAJOR version number
// described by `Semantic Versioning 2.0.0 <http://semver.org/>`_).
// The Core ML framework in macOS currently supports specification version `1`.
type Model struct {
	SpecificationVersion int32             `protobuf:"varint,1,opt,name=specificationVersion,proto3" json:"specificationVersion,omitempty"`
	Description          *ModelDescription `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// start at 200 here
	// model specific parameters:
	//
	// Types that are valid to be assigned to Type:
	//	*Model_PipelineClassifier
	//	*Model_PipelineRegressor
	//	*Model_Pipeline
	//	*Model_GlmRegressor
	//	*Model_SupportVectorRegressor
	//	*Model_TreeEnsembleRegressor
	//	*Model_NeuralNetworkRegressor
	//	*Model_GlmClassifier
	//	*Model_SupportVectorClassifier
	//	*Model_TreeEnsembleClassifier
	//	*Model_NeuralNetworkClassifier
	//	*Model_NeuralNetwork
	//	*Model_OneHotEncoder
	//	*Model_Imputer
	//	*Model_FeatureVectorizer
	//	*Model_DictVectorizer
	//	*Model_Scaler
	//	*Model_CategoricalMapping
	//	*Model_Normalizer
	//	*Model_ArrayFeatureExtractor
	//	*Model_Identity
	Type isModel_Type `protobuf_oneof:"Type"`
}

func (m *Model) Reset()                    { *m = Model{} }
func (m *Model) String() string            { return proto.CompactTextString(m) }
func (*Model) ProtoMessage()               {}
func (*Model) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{6} }

type isModel_Type interface {
	isModel_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Model_PipelineClassifier struct {
	PipelineClassifier *PipelineClassifier `protobuf:"bytes,200,opt,name=pipelineClassifier,oneof"`
}
type Model_PipelineRegressor struct {
	PipelineRegressor *PipelineRegressor `protobuf:"bytes,201,opt,name=pipelineRegressor,oneof"`
}
type Model_Pipeline struct {
	Pipeline *Pipeline `protobuf:"bytes,202,opt,name=pipeline,oneof"`
}
type Model_GlmRegressor struct {
	GlmRegressor *GLMRegressor `protobuf:"bytes,300,opt,name=glmRegressor,oneof"`
}
type Model_SupportVectorRegressor struct {
	SupportVectorRegressor *SupportVectorRegressor `protobuf:"bytes,301,opt,name=supportVectorRegressor,oneof"`
}
type Model_TreeEnsembleRegressor struct {
	TreeEnsembleRegressor *TreeEnsembleRegressor `protobuf:"bytes,302,opt,name=treeEnsembleRegressor,oneof"`
}
type Model_NeuralNetworkRegressor struct {
	NeuralNetworkRegressor *NeuralNetworkRegressor `protobuf:"bytes,303,opt,name=neuralNetworkRegressor,oneof"`
}
type Model_GlmClassifier struct {
	GlmClassifier *GLMClassifier `protobuf:"bytes,400,opt,name=glmClassifier,oneof"`
}
type Model_SupportVectorClassifier struct {
	SupportVectorClassifier *SupportVectorClassifier `protobuf:"bytes,401,opt,name=supportVectorClassifier,oneof"`
}
type Model_TreeEnsembleClassifier struct {
	TreeEnsembleClassifier *TreeEnsembleClassifier `protobuf:"bytes,402,opt,name=treeEnsembleClassifier,oneof"`
}
type Model_NeuralNetworkClassifier struct {
	NeuralNetworkClassifier *NeuralNetworkClassifier `protobuf:"bytes,403,opt,name=neuralNetworkClassifier,oneof"`
}
type Model_NeuralNetwork struct {
	NeuralNetwork *NeuralNetwork `protobuf:"bytes,500,opt,name=neuralNetwork,oneof"`
}
type Model_OneHotEncoder struct {
	OneHotEncoder *OneHotEncoder `protobuf:"bytes,600,opt,name=oneHotEncoder,oneof"`
}
type Model_Imputer struct {
	Imputer *Imputer `protobuf:"bytes,601,opt,name=imputer,oneof"`
}
type Model_FeatureVectorizer struct {
	FeatureVectorizer *FeatureVectorizer `protobuf:"bytes,602,opt,name=featureVectorizer,oneof"`
}
type Model_DictVectorizer struct {
	DictVectorizer *DictVectorizer `protobuf:"bytes,603,opt,name=dictVectorizer,oneof"`
}
type Model_Scaler struct {
	Scaler *Scaler `protobuf:"bytes,604,opt,name=scaler,oneof"`
}
type Model_CategoricalMapping struct {
	CategoricalMapping *CategoricalMapping `protobuf:"bytes,606,opt,name=categoricalMapping,oneof"`
}
type Model_Normalizer struct {
	Normalizer *Normalizer `protobuf:"bytes,607,opt,name=normalizer,oneof"`
}
type Model_ArrayFeatureExtractor struct {
	ArrayFeatureExtractor *ArrayFeatureExtractor `protobuf:"bytes,609,opt,name=arrayFeatureExtractor,oneof"`
}
type Model_Identity struct {
	Identity *Identity `protobuf:"bytes,900,opt,name=identity,oneof"`
}

func (*Model_PipelineClassifier) isModel_Type()      {}
func (*Model_PipelineRegressor) isModel_Type()       {}
func (*Model_Pipeline) isModel_Type()                {}
func (*Model_GlmRegressor) isModel_Type()            {}
func (*Model_SupportVectorRegressor) isModel_Type()  {}
func (*Model_TreeEnsembleRegressor) isModel_Type()   {}
func (*Model_NeuralNetworkRegressor) isModel_Type()  {}
func (*Model_GlmClassifier) isModel_Type()           {}
func (*Model_SupportVectorClassifier) isModel_Type() {}
func (*Model_TreeEnsembleClassifier) isModel_Type()  {}
func (*Model_NeuralNetworkClassifier) isModel_Type() {}
func (*Model_NeuralNetwork) isModel_Type()           {}
func (*Model_OneHotEncoder) isModel_Type()           {}
func (*Model_Imputer) isModel_Type()                 {}
func (*Model_FeatureVectorizer) isModel_Type()       {}
func (*Model_DictVectorizer) isModel_Type()          {}
func (*Model_Scaler) isModel_Type()                  {}
func (*Model_CategoricalMapping) isModel_Type()      {}
func (*Model_Normalizer) isModel_Type()              {}
func (*Model_ArrayFeatureExtractor) isModel_Type()   {}
func (*Model_Identity) isModel_Type()                {}

func (m *Model) GetType() isModel_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Model) GetSpecificationVersion() int32 {
	if m != nil {
		return m.SpecificationVersion
	}
	return 0
}

func (m *Model) GetDescription() *ModelDescription {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *Model) GetPipelineClassifier() *PipelineClassifier {
	if x, ok := m.GetType().(*Model_PipelineClassifier); ok {
		return x.PipelineClassifier
	}
	return nil
}

func (m *Model) GetPipelineRegressor() *PipelineRegressor {
	if x, ok := m.GetType().(*Model_PipelineRegressor); ok {
		return x.PipelineRegressor
	}
	return nil
}

func (m *Model) GetPipeline() *Pipeline {
	if x, ok := m.GetType().(*Model_Pipeline); ok {
		return x.Pipeline
	}
	return nil
}

func (m *Model) GetGlmRegressor() *GLMRegressor {
	if x, ok := m.GetType().(*Model_GlmRegressor); ok {
		return x.GlmRegressor
	}
	return nil
}

func (m *Model) GetSupportVectorRegressor() *SupportVectorRegressor {
	if x, ok := m.GetType().(*Model_SupportVectorRegressor); ok {
		return x.SupportVectorRegressor
	}
	return nil
}

func (m *Model) GetTreeEnsembleRegressor() *TreeEnsembleRegressor {
	if x, ok := m.GetType().(*Model_TreeEnsembleRegressor); ok {
		return x.TreeEnsembleRegressor
	}
	return nil
}

func (m *Model) GetNeuralNetworkRegressor() *NeuralNetworkRegressor {
	if x, ok := m.GetType().(*Model_NeuralNetworkRegressor); ok {
		return x.NeuralNetworkRegressor
	}
	return nil
}

func (m *Model) GetGlmClassifier() *GLMClassifier {
	if x, ok := m.GetType().(*Model_GlmClassifier); ok {
		return x.GlmClassifier
	}
	return nil
}

func (m *Model) GetSupportVectorClassifier() *SupportVectorClassifier {
	if x, ok := m.GetType().(*Model_SupportVectorClassifier); ok {
		return x.SupportVectorClassifier
	}
	return nil
}

func (m *Model) GetTreeEnsembleClassifier() *TreeEnsembleClassifier {
	if x, ok := m.GetType().(*Model_TreeEnsembleClassifier); ok {
		return x.TreeEnsembleClassifier
	}
	return nil
}

func (m *Model) GetNeuralNetworkClassifier() *NeuralNetworkClassifier {
	if x, ok := m.GetType().(*Model_NeuralNetworkClassifier); ok {
		return x.NeuralNetworkClassifier
	}
	return nil
}

func (m *Model) GetNeuralNetwork() *NeuralNetwork {
	if x, ok := m.GetType().(*Model_NeuralNetwork); ok {
		return x.NeuralNetwork
	}
	return nil
}

func (m *Model) GetOneHotEncoder() *OneHotEncoder {
	if x, ok := m.GetType().(*Model_OneHotEncoder); ok {
		return x.OneHotEncoder
	}
	return nil
}

func (m *Model) GetImputer() *Imputer {
	if x, ok := m.GetType().(*Model_Imputer); ok {
		return x.Imputer
	}
	return nil
}

func (m *Model) GetFeatureVectorizer() *FeatureVectorizer {
	if x, ok := m.GetType().(*Model_FeatureVectorizer); ok {
		return x.FeatureVectorizer
	}
	return nil
}

func (m *Model) GetDictVectorizer() *DictVectorizer {
	if x, ok := m.GetType().(*Model_DictVectorizer); ok {
		return x.DictVectorizer
	}
	return nil
}

func (m *Model) GetScaler() *Scaler {
	if x, ok := m.GetType().(*Model_Scaler); ok {
		return x.Scaler
	}
	return nil
}

func (m *Model) GetCategoricalMapping() *CategoricalMapping {
	if x, ok := m.GetType().(*Model_CategoricalMapping); ok {
		return x.CategoricalMapping
	}
	return nil
}

func (m *Model) GetNormalizer() *Normalizer {
	if x, ok := m.GetType().(*Model_Normalizer); ok {
		return x.Normalizer
	}
	return nil
}

func (m *Model) GetArrayFeatureExtractor() *ArrayFeatureExtractor {
	if x, ok := m.GetType().(*Model_ArrayFeatureExtractor); ok {
		return x.ArrayFeatureExtractor
	}
	return nil
}

func (m *Model) GetIdentity() *Identity {
	if x, ok := m.GetType().(*Model_Identity); ok {
		return x.Identity
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Model) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Model_OneofMarshaler, _Model_OneofUnmarshaler, _Model_OneofSizer, []interface{}{
		(*Model_PipelineClassifier)(nil),
		(*Model_PipelineRegressor)(nil),
		(*Model_Pipeline)(nil),
		(*Model_GlmRegressor)(nil),
		(*Model_SupportVectorRegressor)(nil),
		(*Model_TreeEnsembleRegressor)(nil),
		(*Model_NeuralNetworkRegressor)(nil),
		(*Model_GlmClassifier)(nil),
		(*Model_SupportVectorClassifier)(nil),
		(*Model_TreeEnsembleClassifier)(nil),
		(*Model_NeuralNetworkClassifier)(nil),
		(*Model_NeuralNetwork)(nil),
		(*Model_OneHotEncoder)(nil),
		(*Model_Imputer)(nil),
		(*Model_FeatureVectorizer)(nil),
		(*Model_DictVectorizer)(nil),
		(*Model_Scaler)(nil),
		(*Model_CategoricalMapping)(nil),
		(*Model_Normalizer)(nil),
		(*Model_ArrayFeatureExtractor)(nil),
		(*Model_Identity)(nil),
	}
}

func _Model_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Model)
	// Type
	switch x := m.Type.(type) {
	case *Model_PipelineClassifier:
		_ = b.EncodeVarint(200<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PipelineClassifier); err != nil {
			return err
		}
	case *Model_PipelineRegressor:
		_ = b.EncodeVarint(201<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PipelineRegressor); err != nil {
			return err
		}
	case *Model_Pipeline:
		_ = b.EncodeVarint(202<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pipeline); err != nil {
			return err
		}
	case *Model_GlmRegressor:
		_ = b.EncodeVarint(300<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GlmRegressor); err != nil {
			return err
		}
	case *Model_SupportVectorRegressor:
		_ = b.EncodeVarint(301<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SupportVectorRegressor); err != nil {
			return err
		}
	case *Model_TreeEnsembleRegressor:
		_ = b.EncodeVarint(302<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TreeEnsembleRegressor); err != nil {
			return err
		}
	case *Model_NeuralNetworkRegressor:
		_ = b.EncodeVarint(303<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NeuralNetworkRegressor); err != nil {
			return err
		}
	case *Model_GlmClassifier:
		_ = b.EncodeVarint(400<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GlmClassifier); err != nil {
			return err
		}
	case *Model_SupportVectorClassifier:
		_ = b.EncodeVarint(401<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SupportVectorClassifier); err != nil {
			return err
		}
	case *Model_TreeEnsembleClassifier:
		_ = b.EncodeVarint(402<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TreeEnsembleClassifier); err != nil {
			return err
		}
	case *Model_NeuralNetworkClassifier:
		_ = b.EncodeVarint(403<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NeuralNetworkClassifier); err != nil {
			return err
		}
	case *Model_NeuralNetwork:
		_ = b.EncodeVarint(500<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NeuralNetwork); err != nil {
			return err
		}
	case *Model_OneHotEncoder:
		_ = b.EncodeVarint(600<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OneHotEncoder); err != nil {
			return err
		}
	case *Model_Imputer:
		_ = b.EncodeVarint(601<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Imputer); err != nil {
			return err
		}
	case *Model_FeatureVectorizer:
		_ = b.EncodeVarint(602<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FeatureVectorizer); err != nil {
			return err
		}
	case *Model_DictVectorizer:
		_ = b.EncodeVarint(603<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DictVectorizer); err != nil {
			return err
		}
	case *Model_Scaler:
		_ = b.EncodeVarint(604<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Scaler); err != nil {
			return err
		}
	case *Model_CategoricalMapping:
		_ = b.EncodeVarint(606<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CategoricalMapping); err != nil {
			return err
		}
	case *Model_Normalizer:
		_ = b.EncodeVarint(607<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Normalizer); err != nil {
			return err
		}
	case *Model_ArrayFeatureExtractor:
		_ = b.EncodeVarint(609<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ArrayFeatureExtractor); err != nil {
			return err
		}
	case *Model_Identity:
		_ = b.EncodeVarint(900<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Identity); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Model.Type has unexpected type %T", x)
	}
	return nil
}

func _Model_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Model)
	switch tag {
	case 200: // Type.pipelineClassifier
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PipelineClassifier)
		err := b.DecodeMessage(msg)
		m.Type = &Model_PipelineClassifier{msg}
		return true, err
	case 201: // Type.pipelineRegressor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PipelineRegressor)
		err := b.DecodeMessage(msg)
		m.Type = &Model_PipelineRegressor{msg}
		return true, err
	case 202: // Type.pipeline
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Pipeline)
		err := b.DecodeMessage(msg)
		m.Type = &Model_Pipeline{msg}
		return true, err
	case 300: // Type.glmRegressor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GLMRegressor)
		err := b.DecodeMessage(msg)
		m.Type = &Model_GlmRegressor{msg}
		return true, err
	case 301: // Type.supportVectorRegressor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SupportVectorRegressor)
		err := b.DecodeMessage(msg)
		m.Type = &Model_SupportVectorRegressor{msg}
		return true, err
	case 302: // Type.treeEnsembleRegressor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TreeEnsembleRegressor)
		err := b.DecodeMessage(msg)
		m.Type = &Model_TreeEnsembleRegressor{msg}
		return true, err
	case 303: // Type.neuralNetworkRegressor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NeuralNetworkRegressor)
		err := b.DecodeMessage(msg)
		m.Type = &Model_NeuralNetworkRegressor{msg}
		return true, err
	case 400: // Type.glmClassifier
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GLMClassifier)
		err := b.DecodeMessage(msg)
		m.Type = &Model_GlmClassifier{msg}
		return true, err
	case 401: // Type.supportVectorClassifier
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SupportVectorClassifier)
		err := b.DecodeMessage(msg)
		m.Type = &Model_SupportVectorClassifier{msg}
		return true, err
	case 402: // Type.treeEnsembleClassifier
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TreeEnsembleClassifier)
		err := b.DecodeMessage(msg)
		m.Type = &Model_TreeEnsembleClassifier{msg}
		return true, err
	case 403: // Type.neuralNetworkClassifier
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NeuralNetworkClassifier)
		err := b.DecodeMessage(msg)
		m.Type = &Model_NeuralNetworkClassifier{msg}
		return true, err
	case 500: // Type.neuralNetwork
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NeuralNetwork)
		err := b.DecodeMessage(msg)
		m.Type = &Model_NeuralNetwork{msg}
		return true, err
	case 600: // Type.oneHotEncoder
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OneHotEncoder)
		err := b.DecodeMessage(msg)
		m.Type = &Model_OneHotEncoder{msg}
		return true, err
	case 601: // Type.imputer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Imputer)
		err := b.DecodeMessage(msg)
		m.Type = &Model_Imputer{msg}
		return true, err
	case 602: // Type.featureVectorizer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FeatureVectorizer)
		err := b.DecodeMessage(msg)
		m.Type = &Model_FeatureVectorizer{msg}
		return true, err
	case 603: // Type.dictVectorizer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DictVectorizer)
		err := b.DecodeMessage(msg)
		m.Type = &Model_DictVectorizer{msg}
		return true, err
	case 604: // Type.scaler
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Scaler)
		err := b.DecodeMessage(msg)
		m.Type = &Model_Scaler{msg}
		return true, err
	case 606: // Type.categoricalMapping
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CategoricalMapping)
		err := b.DecodeMessage(msg)
		m.Type = &Model_CategoricalMapping{msg}
		return true, err
	case 607: // Type.normalizer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Normalizer)
		err := b.DecodeMessage(msg)
		m.Type = &Model_Normalizer{msg}
		return true, err
	case 609: // Type.arrayFeatureExtractor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ArrayFeatureExtractor)
		err := b.DecodeMessage(msg)
		m.Type = &Model_ArrayFeatureExtractor{msg}
		return true, err
	case 900: // Type.identity
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Identity)
		err := b.DecodeMessage(msg)
		m.Type = &Model_Identity{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Model_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Model)
	// Type
	switch x := m.Type.(type) {
	case *Model_PipelineClassifier:
		s := proto.Size(x.PipelineClassifier)
		n += proto.SizeVarint(200<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_PipelineRegressor:
		s := proto.Size(x.PipelineRegressor)
		n += proto.SizeVarint(201<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_Pipeline:
		s := proto.Size(x.Pipeline)
		n += proto.SizeVarint(202<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_GlmRegressor:
		s := proto.Size(x.GlmRegressor)
		n += proto.SizeVarint(300<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_SupportVectorRegressor:
		s := proto.Size(x.SupportVectorRegressor)
		n += proto.SizeVarint(301<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_TreeEnsembleRegressor:
		s := proto.Size(x.TreeEnsembleRegressor)
		n += proto.SizeVarint(302<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_NeuralNetworkRegressor:
		s := proto.Size(x.NeuralNetworkRegressor)
		n += proto.SizeVarint(303<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_GlmClassifier:
		s := proto.Size(x.GlmClassifier)
		n += proto.SizeVarint(400<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_SupportVectorClassifier:
		s := proto.Size(x.SupportVectorClassifier)
		n += proto.SizeVarint(401<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_TreeEnsembleClassifier:
		s := proto.Size(x.TreeEnsembleClassifier)
		n += proto.SizeVarint(402<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_NeuralNetworkClassifier:
		s := proto.Size(x.NeuralNetworkClassifier)
		n += proto.SizeVarint(403<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_NeuralNetwork:
		s := proto.Size(x.NeuralNetwork)
		n += proto.SizeVarint(500<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_OneHotEncoder:
		s := proto.Size(x.OneHotEncoder)
		n += proto.SizeVarint(600<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_Imputer:
		s := proto.Size(x.Imputer)
		n += proto.SizeVarint(601<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_FeatureVectorizer:
		s := proto.Size(x.FeatureVectorizer)
		n += proto.SizeVarint(602<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_DictVectorizer:
		s := proto.Size(x.DictVectorizer)
		n += proto.SizeVarint(603<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_Scaler:
		s := proto.Size(x.Scaler)
		n += proto.SizeVarint(604<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_CategoricalMapping:
		s := proto.Size(x.CategoricalMapping)
		n += proto.SizeVarint(606<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_Normalizer:
		s := proto.Size(x.Normalizer)
		n += proto.SizeVarint(607<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_ArrayFeatureExtractor:
		s := proto.Size(x.ArrayFeatureExtractor)
		n += proto.SizeVarint(609<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Model_Identity:
		s := proto.Size(x.Identity)
		n += proto.SizeVarint(900<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Pipeline)(nil), "CoreML.Pipeline")
	proto.RegisterType((*PipelineClassifier)(nil), "CoreML.PipelineClassifier")
	proto.RegisterType((*PipelineRegressor)(nil), "CoreML.PipelineRegressor")
	proto.RegisterType((*FeatureDescription)(nil), "CoreML.FeatureDescription")
	proto.RegisterType((*Metadata)(nil), "CoreML.Metadata")
	proto.RegisterType((*ModelDescription)(nil), "CoreML.ModelDescription")
	proto.RegisterType((*Model)(nil), "CoreML.Model")
}
func (m *Pipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pipeline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Models) > 0 {
		for _, msg := range m.Models {
			dAtA[i] = 0xa
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PipelineClassifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineClassifier) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pipeline.Size()))
		n1, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ClassLabels != nil {
		nn2, err := m.ClassLabels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *PipelineClassifier_StringClassLabels) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StringClassLabels != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.StringClassLabels.Size()))
		n3, err := m.StringClassLabels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *PipelineClassifier_Int64ClassLabels) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Int64ClassLabels != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Int64ClassLabels.Size()))
		n4, err := m.Int64ClassLabels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *PipelineRegressor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineRegressor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pipeline.Size()))
		n5, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *FeatureDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureDescription) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.ShortDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.ShortDescription)))
		i += copy(dAtA[i:], m.ShortDescription)
	}
	if m.Type != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Type.Size()))
		n6, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ShortDescription) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.ShortDescription)))
		i += copy(dAtA[i:], m.ShortDescription)
	}
	if len(m.VersionString) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.VersionString)))
		i += copy(dAtA[i:], m.VersionString)
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if len(m.License) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.License)))
		i += copy(dAtA[i:], m.License)
	}
	if len(m.UserDefined) > 0 {
		for k, _ := range m.UserDefined {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			v := m.UserDefined[k]
			mapSize := 1 + len(k) + sovModel(uint64(len(k))) + 1 + len(v) + sovModel(uint64(len(v)))
			i = encodeVarintModel(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModel(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintModel(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *ModelDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelDescription) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Input) > 0 {
		for _, msg := range m.Input {
			dAtA[i] = 0xa
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Output) > 0 {
		for _, msg := range m.Output {
			dAtA[i] = 0x52
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PredictedFeatureName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.PredictedFeatureName)))
		i += copy(dAtA[i:], m.PredictedFeatureName)
	}
	if len(m.PredictedProbabilitiesName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.PredictedProbabilitiesName)))
		i += copy(dAtA[i:], m.PredictedProbabilitiesName)
	}
	if m.Metadata != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Metadata.Size()))
		n7, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *Model) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SpecificationVersion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SpecificationVersion))
	}
	if m.Description != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Description.Size()))
		n8, err := m.Description.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Type != nil {
		nn9, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	return i, nil
}

func (m *Model_PipelineClassifier) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PipelineClassifier != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.PipelineClassifier.Size()))
		n10, err := m.PipelineClassifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Model_PipelineRegressor) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PipelineRegressor != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.PipelineRegressor.Size()))
		n11, err := m.PipelineRegressor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *Model_Pipeline) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Pipeline != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pipeline.Size()))
		n12, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Model_GlmRegressor) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GlmRegressor != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.GlmRegressor.Size()))
		n13, err := m.GlmRegressor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *Model_SupportVectorRegressor) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SupportVectorRegressor != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SupportVectorRegressor.Size()))
		n14, err := m.SupportVectorRegressor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *Model_TreeEnsembleRegressor) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TreeEnsembleRegressor != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.TreeEnsembleRegressor.Size()))
		n15, err := m.TreeEnsembleRegressor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *Model_NeuralNetworkRegressor) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NeuralNetworkRegressor != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.NeuralNetworkRegressor.Size()))
		n16, err := m.NeuralNetworkRegressor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *Model_GlmClassifier) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GlmClassifier != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x19
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.GlmClassifier.Size()))
		n17, err := m.GlmClassifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *Model_SupportVectorClassifier) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SupportVectorClassifier != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x19
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SupportVectorClassifier.Size()))
		n18, err := m.SupportVectorClassifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *Model_TreeEnsembleClassifier) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TreeEnsembleClassifier != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x19
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.TreeEnsembleClassifier.Size()))
		n19, err := m.TreeEnsembleClassifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *Model_NeuralNetworkClassifier) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NeuralNetworkClassifier != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x19
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.NeuralNetworkClassifier.Size()))
		n20, err := m.NeuralNetworkClassifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *Model_NeuralNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NeuralNetwork != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1f
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.NeuralNetwork.Size()))
		n21, err := m.NeuralNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *Model_OneHotEncoder) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OneHotEncoder != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x25
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.OneHotEncoder.Size()))
		n22, err := m.OneHotEncoder.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *Model_Imputer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Imputer != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x25
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Imputer.Size()))
		n23, err := m.Imputer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *Model_FeatureVectorizer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FeatureVectorizer != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x25
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.FeatureVectorizer.Size()))
		n24, err := m.FeatureVectorizer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *Model_DictVectorizer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DictVectorizer != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x25
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.DictVectorizer.Size()))
		n25, err := m.DictVectorizer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *Model_Scaler) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Scaler != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x25
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Scaler.Size()))
		n26, err := m.Scaler.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *Model_CategoricalMapping) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CategoricalMapping != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x25
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.CategoricalMapping.Size()))
		n27, err := m.CategoricalMapping.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *Model_Normalizer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Normalizer != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x25
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Normalizer.Size()))
		n28, err := m.Normalizer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *Model_ArrayFeatureExtractor) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ArrayFeatureExtractor != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x26
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.ArrayFeatureExtractor.Size()))
		n29, err := m.ArrayFeatureExtractor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *Model_Identity) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Identity != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Identity.Size()))
		n30, err := m.Identity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func encodeFixed64Model(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Model(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintModel(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Pipeline) Size() (n int) {
	var l int
	_ = l
	if len(m.Models) > 0 {
		for _, e := range m.Models {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *PipelineClassifier) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.ClassLabels != nil {
		n += m.ClassLabels.Size()
	}
	return n
}

func (m *PipelineClassifier_StringClassLabels) Size() (n int) {
	var l int
	_ = l
	if m.StringClassLabels != nil {
		l = m.StringClassLabels.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *PipelineClassifier_Int64ClassLabels) Size() (n int) {
	var l int
	_ = l
	if m.Int64ClassLabels != nil {
		l = m.Int64ClassLabels.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *PipelineRegressor) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *FeatureDescription) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ShortDescription)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *Metadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.ShortDescription)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.VersionString)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.License)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if len(m.UserDefined) > 0 {
		for k, v := range m.UserDefined {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModel(uint64(len(k))) + 1 + len(v) + sovModel(uint64(len(v)))
			n += mapEntrySize + 2 + sovModel(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ModelDescription) Size() (n int) {
	var l int
	_ = l
	if len(m.Input) > 0 {
		for _, e := range m.Input {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if len(m.Output) > 0 {
		for _, e := range m.Output {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	l = len(m.PredictedFeatureName)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.PredictedProbabilitiesName)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}

func (m *Model) Size() (n int) {
	var l int
	_ = l
	if m.SpecificationVersion != 0 {
		n += 1 + sovModel(uint64(m.SpecificationVersion))
	}
	if m.Description != nil {
		l = m.Description.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *Model_PipelineClassifier) Size() (n int) {
	var l int
	_ = l
	if m.PipelineClassifier != nil {
		l = m.PipelineClassifier.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_PipelineRegressor) Size() (n int) {
	var l int
	_ = l
	if m.PipelineRegressor != nil {
		l = m.PipelineRegressor.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_Pipeline) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_GlmRegressor) Size() (n int) {
	var l int
	_ = l
	if m.GlmRegressor != nil {
		l = m.GlmRegressor.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_SupportVectorRegressor) Size() (n int) {
	var l int
	_ = l
	if m.SupportVectorRegressor != nil {
		l = m.SupportVectorRegressor.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_TreeEnsembleRegressor) Size() (n int) {
	var l int
	_ = l
	if m.TreeEnsembleRegressor != nil {
		l = m.TreeEnsembleRegressor.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_NeuralNetworkRegressor) Size() (n int) {
	var l int
	_ = l
	if m.NeuralNetworkRegressor != nil {
		l = m.NeuralNetworkRegressor.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_GlmClassifier) Size() (n int) {
	var l int
	_ = l
	if m.GlmClassifier != nil {
		l = m.GlmClassifier.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_SupportVectorClassifier) Size() (n int) {
	var l int
	_ = l
	if m.SupportVectorClassifier != nil {
		l = m.SupportVectorClassifier.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_TreeEnsembleClassifier) Size() (n int) {
	var l int
	_ = l
	if m.TreeEnsembleClassifier != nil {
		l = m.TreeEnsembleClassifier.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_NeuralNetworkClassifier) Size() (n int) {
	var l int
	_ = l
	if m.NeuralNetworkClassifier != nil {
		l = m.NeuralNetworkClassifier.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_NeuralNetwork) Size() (n int) {
	var l int
	_ = l
	if m.NeuralNetwork != nil {
		l = m.NeuralNetwork.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_OneHotEncoder) Size() (n int) {
	var l int
	_ = l
	if m.OneHotEncoder != nil {
		l = m.OneHotEncoder.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_Imputer) Size() (n int) {
	var l int
	_ = l
	if m.Imputer != nil {
		l = m.Imputer.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_FeatureVectorizer) Size() (n int) {
	var l int
	_ = l
	if m.FeatureVectorizer != nil {
		l = m.FeatureVectorizer.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_DictVectorizer) Size() (n int) {
	var l int
	_ = l
	if m.DictVectorizer != nil {
		l = m.DictVectorizer.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_Scaler) Size() (n int) {
	var l int
	_ = l
	if m.Scaler != nil {
		l = m.Scaler.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_CategoricalMapping) Size() (n int) {
	var l int
	_ = l
	if m.CategoricalMapping != nil {
		l = m.CategoricalMapping.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_Normalizer) Size() (n int) {
	var l int
	_ = l
	if m.Normalizer != nil {
		l = m.Normalizer.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_ArrayFeatureExtractor) Size() (n int) {
	var l int
	_ = l
	if m.ArrayFeatureExtractor != nil {
		l = m.ArrayFeatureExtractor.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}
func (m *Model_Identity) Size() (n int) {
	var l int
	_ = l
	if m.Identity != nil {
		l = m.Identity.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}

func sovModel(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozModel(x uint64) (n int) {
	return sovModel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Pipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Models", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Models = append(m.Models, &Model{})
			if err := m.Models[len(m.Models)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineClassifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineClassifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineClassifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringClassLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringVector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClassLabels = &PipelineClassifier_StringClassLabels{v}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64ClassLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Int64Vector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClassLabels = &PipelineClassifier_Int64ClassLabels{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineRegressor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineRegressor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineRegressor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &FeatureType{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field License", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.License = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefined", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthModel
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.UserDefined == nil {
				m.UserDefined = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthModel
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.UserDefined[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.UserDefined[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = append(m.Input, &FeatureDescription{})
			if err := m.Input[len(m.Input)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = append(m.Output, &FeatureDescription{})
			if err := m.Output[len(m.Output)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictedFeatureName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredictedFeatureName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictedProbabilitiesName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredictedProbabilitiesName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecificationVersion", wireType)
			}
			m.SpecificationVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpecificationVersion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Description == nil {
				m.Description = &ModelDescription{}
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 200:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineClassifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PipelineClassifier{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_PipelineClassifier{v}
			iNdEx = postIndex
		case 201:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineRegressor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PipelineRegressor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_PipelineRegressor{v}
			iNdEx = postIndex
		case 202:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Pipeline{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_Pipeline{v}
			iNdEx = postIndex
		case 300:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlmRegressor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GLMRegressor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_GlmRegressor{v}
			iNdEx = postIndex
		case 301:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportVectorRegressor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SupportVectorRegressor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_SupportVectorRegressor{v}
			iNdEx = postIndex
		case 302:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeEnsembleRegressor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TreeEnsembleRegressor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_TreeEnsembleRegressor{v}
			iNdEx = postIndex
		case 303:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeuralNetworkRegressor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NeuralNetworkRegressor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_NeuralNetworkRegressor{v}
			iNdEx = postIndex
		case 400:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlmClassifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GLMClassifier{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_GlmClassifier{v}
			iNdEx = postIndex
		case 401:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportVectorClassifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SupportVectorClassifier{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_SupportVectorClassifier{v}
			iNdEx = postIndex
		case 402:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeEnsembleClassifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TreeEnsembleClassifier{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_TreeEnsembleClassifier{v}
			iNdEx = postIndex
		case 403:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeuralNetworkClassifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NeuralNetworkClassifier{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_NeuralNetworkClassifier{v}
			iNdEx = postIndex
		case 500:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeuralNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NeuralNetwork{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_NeuralNetwork{v}
			iNdEx = postIndex
		case 600:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneHotEncoder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OneHotEncoder{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_OneHotEncoder{v}
			iNdEx = postIndex
		case 601:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imputer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Imputer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_Imputer{v}
			iNdEx = postIndex
		case 602:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureVectorizer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FeatureVectorizer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_FeatureVectorizer{v}
			iNdEx = postIndex
		case 603:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DictVectorizer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DictVectorizer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_DictVectorizer{v}
			iNdEx = postIndex
		case 604:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scaler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Scaler{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_Scaler{v}
			iNdEx = postIndex
		case 606:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoricalMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CategoricalMapping{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_CategoricalMapping{v}
			iNdEx = postIndex
		case 607:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Normalizer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Normalizer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_Normalizer{v}
			iNdEx = postIndex
		case 609:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayFeatureExtractor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ArrayFeatureExtractor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_ArrayFeatureExtractor{v}
			iNdEx = postIndex
		case 900:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Identity{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Model_Identity{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthModel
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowModel
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipModel(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthModel = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModel   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("Model.proto", fileDescriptorModel) }

var fileDescriptorModel = []byte{
	// 1126 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x76, 0x7e, 0x9a, 0xb6, 0x27, 0x4d, 0x49, 0xa7, 0xdd, 0xae, 0x09, 0xa2, 0x2c, 0x11, 0x88,
	0x05, 0xad, 0x0a, 0x94, 0x1f, 0xa1, 0x45, 0xaa, 0xd4, 0x3f, 0xd6, 0x45, 0x4d, 0xb0, 0xdc, 0x52,
	0x09, 0x89, 0x1b, 0xd7, 0x9e, 0x66, 0x47, 0xeb, 0xd8, 0xd6, 0x78, 0xb2, 0x10, 0x24, 0xee, 0x78,
	0x80, 0x85, 0xbd, 0xe3, 0x19, 0xf8, 0x79, 0x8d, 0x85, 0x2b, 0x2e, 0x61, 0x41, 0xfc, 0x14, 0x1e,
	0x81, 0x07, 0x40, 0xe3, 0x19, 0x3b, 0x33, 0xb6, 0x03, 0xe2, 0x2e, 0x73, 0xce, 0xf7, 0x7d, 0x73,
	0xe6, 0xe4, 0x9c, 0xe3, 0x03, 0xed, 0x41, 0xe4, 0xe3, 0x60, 0x3b, 0xa6, 0x11, 0x8b, 0x50, 0xeb,
	0x20, 0xa2, 0x78, 0x70, 0xd2, 0x7b, 0x6a, 0x8f, 0x52, 0x77, 0xfa, 0x0e, 0x76, 0xd9, 0x84, 0xe2,
	0xa3, 0x8f, 0x19, 0x75, 0x3d, 0x16, 0x51, 0x01, 0xea, 0x99, 0x07, 0x2e, 0xc3, 0xa3, 0x88, 0x12,
	0xcf, 0x0d, 0x06, 0x6e, 0x1c, 0x93, 0x70, 0x24, 0x3d, 0x1b, 0x87, 0xc4, 0x63, 0xe7, 0x98, 0x63,
	0xc9, 0x27, 0x38, 0xc3, 0x23, 0xa9, 0x73, 0x36, 0x8d, 0x71, 0x22, 0x6d, 0xd7, 0xa5, 0xad, 0x0c,
	0xbe, 0x73, 0x32, 0x70, 0xf0, 0x88, 0xe2, 0x24, 0xc9, 0x2f, 0x5c, 0xbf, 0x73, 0x32, 0x38, 0x08,
	0xdc, 0x24, 0x21, 0x97, 0x24, 0x07, 0xae, 0x1e, 0xfb, 0x38, 0x64, 0x84, 0x4d, 0xe5, 0xb9, 0x73,
	0x3c, 0x8e, 0x27, 0x2c, 0x77, 0xaf, 0x0f, 0xf1, 0x84, 0xba, 0xc1, 0x10, 0xb3, 0x8f, 0x22, 0x7a,
	0x4f, 0x1a, 0xbb, 0xc3, 0x88, 0x8e, 0xdd, 0x40, 0xb9, 0x6e, 0xfd, 0xbd, 0x10, 0x5b, 0x11, 0x3b,
	0x0a, 0xbd, 0xc8, 0xcf, 0x8d, 0x2b, 0xa7, 0x9e, 0x1b, 0xe4, 0xa7, 0xe5, 0xd3, 0xf3, 0x41, 0x16,
	0xdc, 0x19, 0xc5, 0xf8, 0x28, 0x4c, 0xf0, 0xf8, 0x22, 0xc0, 0xc2, 0xd6, 0x7f, 0x15, 0x96, 0x6c,
	0x12, 0xe3, 0x80, 0x84, 0x18, 0x3d, 0x0f, 0xad, 0x31, 0xcf, 0x66, 0x62, 0xd6, 0x6e, 0x34, 0x6e,
	0xb6, 0x77, 0x3a, 0xdb, 0x22, 0x9f, 0xdb, 0x69, 0x8e, 0x1d, 0xe9, 0xec, 0x3f, 0xae, 0x01, 0xca,
	0x38, 0xb3, 0x77, 0xa1, 0x5b, 0xb0, 0x14, 0x4b, 0xab, 0x59, 0xbb, 0x51, 0xbb, 0xd9, 0xde, 0xe9,
	0x66, 0xfc, 0x0c, 0xed, 0xe4, 0x08, 0x74, 0x08, 0x6b, 0x09, 0xa3, 0x24, 0x1c, 0xa5, 0x0a, 0x27,
	0xee, 0x05, 0xbf, 0xd6, 0x4f, 0x69, 0x1b, 0x19, 0xed, 0x34, 0x05, 0x88, 0x1c, 0x5b, 0x86, 0x53,
	0x26, 0xa0, 0x3d, 0xe8, 0x92, 0x90, 0xbd, 0xf9, 0xba, 0x2a, 0x82, 0x53, 0x91, 0xf5, 0x4c, 0xe4,
	0x98, 0xfb, 0x73, 0x8d, 0x12, 0x7c, 0xbf, 0x03, 0x6d, 0xe5, 0xd8, 0xdf, 0x83, 0xb5, 0x3c, 0xda,
	0xec, 0x7f, 0xfc, 0x7f, 0x4f, 0xeb, 0x7f, 0x0a, 0x59, 0xc9, 0x1c, 0xe2, 0xc4, 0xa3, 0x24, 0x66,
	0x24, 0x0a, 0x11, 0x82, 0x66, 0xe8, 0x8e, 0x05, 0x7f, 0xd9, 0x49, 0x7f, 0xa3, 0x97, 0xa0, 0x9b,
	0xdc, 0x8d, 0x28, 0x53, 0x70, 0x66, 0x3d, 0xf5, 0x97, 0xec, 0xe8, 0x05, 0x68, 0xb2, 0x69, 0x8c,
	0xcd, 0x86, 0xfe, 0x3c, 0xa5, 0x38, 0x9d, 0x14, 0xd0, 0x7f, 0x58, 0x87, 0xa5, 0x01, 0x66, 0xae,
	0xef, 0x32, 0xb7, 0xf2, 0x86, 0xda, 0x9c, 0x1b, 0x9e, 0x83, 0xce, 0x7d, 0x4c, 0x13, 0x12, 0x85,
	0x22, 0xf1, 0x32, 0x14, 0xdd, 0x88, 0x36, 0xa1, 0xe5, 0x4e, 0xd8, 0xdd, 0x88, 0xa6, 0x91, 0x2c,
	0x3b, 0xf2, 0x84, 0x4c, 0x58, 0x0c, 0x88, 0x87, 0xc3, 0x04, 0x9b, 0xcd, 0xd4, 0x91, 0x1d, 0xd1,
	0x01, 0xb4, 0x27, 0x09, 0xa6, 0x87, 0xf8, 0x92, 0x84, 0xd8, 0x37, 0xfd, 0xb4, 0xb6, 0x9e, 0xcd,
	0x6b, 0x4b, 0x86, 0xba, 0xfd, 0xfe, 0x0c, 0x73, 0x14, 0x32, 0x3a, 0x75, 0x54, 0x56, 0x6f, 0x17,
	0xba, 0x45, 0x00, 0xea, 0x42, 0xe3, 0x1e, 0x9e, 0xca, 0xf7, 0xf0, 0x9f, 0x68, 0x03, 0x16, 0xee,
	0xbb, 0xc1, 0x04, 0xcb, 0xd0, 0xc5, 0xe1, 0x76, 0xfd, 0xad, 0x5a, 0xff, 0xcb, 0x3a, 0x74, 0xd3,
	0x32, 0x56, 0x5f, 0xfc, 0x0a, 0x2c, 0x90, 0x30, 0x9e, 0x30, 0x59, 0xef, 0xbd, 0x42, 0x52, 0x15,
	0xa8, 0x23, 0x80, 0x68, 0x07, 0x5a, 0xd1, 0x84, 0x71, 0x0a, 0xfc, 0x27, 0x45, 0x22, 0xd1, 0x0e,
	0x6c, 0xc4, 0x14, 0xfb, 0xc4, 0x63, 0xd8, 0x97, 0xb0, 0x21, 0xaf, 0x84, 0x76, 0x1a, 0x63, 0xa5,
	0x0f, 0xed, 0x42, 0x2f, 0xb7, 0xdb, 0x34, 0xba, 0x70, 0x2f, 0x48, 0x40, 0x18, 0xc1, 0x49, 0xca,
	0x5c, 0x49, 0x99, 0xff, 0x82, 0xe0, 0x15, 0x3b, 0x96, 0x89, 0x95, 0x5d, 0xd5, 0x2d, 0x26, 0xdc,
	0xc9, 0x11, 0xfd, 0xbf, 0x56, 0x60, 0x21, 0x4d, 0x0e, 0x8f, 0x35, 0x89, 0xb1, 0x47, 0x2e, 0x89,
	0xe7, 0xf2, 0x47, 0x9c, 0x8b, 0xff, 0x3e, 0xcd, 0xf1, 0x82, 0x53, 0xe9, 0x43, 0xb7, 0xa1, 0xed,
	0x17, 0x0a, 0xb8, 0xbd, 0x63, 0x6a, 0xb3, 0x43, 0x4d, 0x8b, 0x0a, 0x46, 0x03, 0x40, 0x71, 0x69,
	0x94, 0x98, 0x8f, 0x44, 0x93, 0xf5, 0x8a, 0x4d, 0x36, 0x83, 0x58, 0x86, 0x53, 0x41, 0x44, 0xef,
	0xc2, 0x5a, 0x5c, 0xec, 0x5e, 0xf3, 0x3b, 0xa1, 0xf6, 0x64, 0xa9, 0x65, 0x33, 0x04, 0x9f, 0x2d,
	0x25, 0x1a, 0x7a, 0x59, 0x69, 0xfa, 0xef, 0xe7, 0x74, 0xbd, 0x65, 0x28, 0x23, 0xed, 0x6d, 0x58,
	0x19, 0x05, 0xe3, 0xd9, 0xbd, 0x5f, 0xd5, 0xf5, 0x71, 0xa6, 0x7e, 0x1a, 0x2c, 0xc3, 0xd1, 0xc0,
	0xe8, 0x03, 0xd8, 0x4c, 0x26, 0x71, 0x1c, 0x51, 0xf9, 0x01, 0x9a, 0xc9, 0x7c, 0x2d, 0x64, 0xb6,
	0xf2, 0xa9, 0x58, 0x09, 0xb3, 0x0c, 0x67, 0x8e, 0x00, 0x3a, 0x87, 0x6b, 0x4c, 0x19, 0xfc, 0x33,
	0xe5, 0x6f, 0x84, 0xf2, 0xd3, 0x99, 0xf2, 0x59, 0x15, 0xca, 0x32, 0x9c, 0x6a, 0x3a, 0x0f, 0x39,
	0x54, 0xbf, 0x52, 0x33, 0xe1, 0x6f, 0x0b, 0x21, 0x0f, 0x2b, 0x61, 0x3c, 0xe4, 0x6a, 0x01, 0xb4,
	0x0b, 0x9d, 0x51, 0x30, 0x56, 0x2a, 0xe2, 0x81, 0x18, 0x7b, 0xd7, 0x94, 0x5c, 0x6a, 0xc5, 0xa0,
	0xc3, 0xd1, 0x87, 0x70, 0x5d, 0x4b, 0x86, 0xa2, 0xf4, 0xb9, 0x50, 0x7a, 0xa6, 0x32, 0x9d, 0x9a,
	0xe6, 0x3c, 0x09, 0xfe, 0x70, 0x35, 0x23, 0x8a, 0xf8, 0x17, 0x0d, 0xfd, 0xe1, 0x67, 0x95, 0x30,
	0xfe, 0xf0, 0x6a, 0x01, 0x1e, 0xb8, 0x96, 0x12, 0x45, 0xfb, 0x61, 0x21, 0xf0, 0x61, 0x35, 0x8e,
	0x07, 0x3e, 0x47, 0x82, 0xa7, 0x55, 0x73, 0x99, 0x7f, 0x17, 0xd2, 0xaa, 0x69, 0xf2, 0xb4, 0x6a,
	0x70, 0xce, 0x8f, 0xd4, 0x85, 0xc3, 0xfc, 0xb1, 0xa9, 0xf3, 0xb5, 0x75, 0x84, 0xf3, 0x35, 0x38,
	0xba, 0x05, 0x8b, 0x44, 0xac, 0x39, 0xe6, 0x4f, 0x82, 0xf9, 0x44, 0xfe, 0x99, 0x16, 0x76, 0xcb,
	0x70, 0x32, 0x08, 0x6f, 0xe6, 0xcb, 0xe2, 0x9a, 0x65, 0x3e, 0x6e, 0xea, 0xcd, 0x5c, 0x5a, 0xc4,
	0x78, 0x33, 0x97, 0x68, 0x68, 0x0f, 0x56, 0x7d, 0x6d, 0xb9, 0x33, 0x7f, 0x16, 0x42, 0x9b, 0x99,
	0x90, 0xbe, 0xfb, 0x59, 0x86, 0x53, 0x20, 0xa0, 0x17, 0xa1, 0x95, 0xa4, 0x8b, 0x95, 0xf9, 0x8b,
	0xa0, 0xae, 0xe6, 0x25, 0x94, 0x9a, 0x2d, 0xc3, 0x91, 0x00, 0x3e, 0xd5, 0xbc, 0xd2, 0x92, 0x69,
	0xfe, 0xda, 0xd4, 0xa7, 0x5a, 0x79, 0x0f, 0xe5, 0x53, 0xad, 0x4c, 0x44, 0x6f, 0x00, 0x84, 0xf9,
	0xe6, 0x67, 0xfe, 0x26, 0x64, 0x50, 0xfe, 0x9f, 0xe5, 0x2e, 0xcb, 0x70, 0x14, 0x20, 0xef, 0x7b,
	0xb7, 0x6a, 0x0f, 0x36, 0xff, 0x68, 0xea, 0x7d, 0x5f, 0xb9, 0x2d, 0xf3, 0xbe, 0xaf, 0xa4, 0xf3,
	0xc1, 0x48, 0xe4, 0xf2, 0x6a, 0x7e, 0xb6, 0xa8, 0x0f, 0xc6, 0x6c, 0xab, 0xe5, 0x83, 0x31, 0x03,
	0xed, 0xb7, 0xa0, 0xc9, 0xf7, 0x93, 0x7d, 0xf4, 0xe8, 0x6a, 0xab, 0xf6, 0xc3, 0xd5, 0x56, 0xed,
	0xf7, 0xab, 0xad, 0xda, 0x83, 0x3f, 0xb7, 0x0c, 0xab, 0x61, 0x1b, 0x76, 0xcd, 0xae, 0xdb, 0x0d,
	0xbb, 0x69, 0x2f, 0xd8, 0x2d, 0x7b, 0xd1, 0x5e, 0xb2, 0x97, 0x6d, 0xb0, 0xdb, 0xf6, 0x8a, 0xdd,
	0xb1, 0x57, 0x2f, 0x5a, 0xe9, 0x92, 0xfa, 0xda, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xea, 0xf1,
	0x9f, 0x4a, 0xe6, 0x0b, 0x00, 0x00,
}
