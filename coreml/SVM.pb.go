// Code generated by protoc-gen-gogo.
// source: SVM.proto
// DO NOT EDIT!

package CoreML

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Ignoring public import of StringToInt64Map from DataStructures.proto

// Ignoring public import of Int64ToStringMap from DataStructures.proto

// Ignoring public import of StringToDoubleMap from DataStructures.proto

// Ignoring public import of Int64ToDoubleMap from DataStructures.proto

// Ignoring public import of StringVector from DataStructures.proto

// Ignoring public import of Int64Vector from DataStructures.proto

// Ignoring public import of DoubleVector from DataStructures.proto

// *
// A linear kernel.
//
// This function has the following formula:
//
// .. math::
//     K(\boldsymbol{x}, \boldsymbol{x'}) = \boldsymbol{x}^T \boldsymbol{x'}
type LinearKernel struct {
}

func (m *LinearKernel) Reset()                    { *m = LinearKernel{} }
func (m *LinearKernel) String() string            { return proto.CompactTextString(m) }
func (*LinearKernel) ProtoMessage()               {}
func (*LinearKernel) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{0} }

// *
// A Gaussian radial basis function (RBF) kernel.
//
// This function has the following formula:
//
// .. math::
//     K(\boldsymbol{x}, \boldsymbol{x'}) = \
//          \exp(-\gamma || \boldsymbol{x} - \boldsymbol{x'} ||^2 )
//
type RBFKernel struct {
	Gamma float64 `protobuf:"fixed64,1,opt,name=gamma,proto3" json:"gamma,omitempty"`
}

func (m *RBFKernel) Reset()                    { *m = RBFKernel{} }
func (m *RBFKernel) String() string            { return proto.CompactTextString(m) }
func (*RBFKernel) ProtoMessage()               {}
func (*RBFKernel) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{1} }

func (m *RBFKernel) GetGamma() float64 {
	if m != nil {
		return m.Gamma
	}
	return 0
}

// *
// A polynomial kernel.
//
// This function has the following formula:
//
// .. math::
//     K(\boldsymbol{x}, \boldsymbol{x'}) = \
//           (\gamma \boldsymbol{x}^T \boldsymbol{x'} + c)^{degree}
type PolyKernel struct {
	Degree int32   `protobuf:"varint,1,opt,name=degree,proto3" json:"degree,omitempty"`
	C      float64 `protobuf:"fixed64,2,opt,name=c,proto3" json:"c,omitempty"`
	Gamma  float64 `protobuf:"fixed64,3,opt,name=gamma,proto3" json:"gamma,omitempty"`
}

func (m *PolyKernel) Reset()                    { *m = PolyKernel{} }
func (m *PolyKernel) String() string            { return proto.CompactTextString(m) }
func (*PolyKernel) ProtoMessage()               {}
func (*PolyKernel) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{2} }

func (m *PolyKernel) GetDegree() int32 {
	if m != nil {
		return m.Degree
	}
	return 0
}

func (m *PolyKernel) GetC() float64 {
	if m != nil {
		return m.C
	}
	return 0
}

func (m *PolyKernel) GetGamma() float64 {
	if m != nil {
		return m.Gamma
	}
	return 0
}

// *
// A sigmoid kernel.
//
// This function has the following formula:
//
// .. math::
//     K(\boldsymbol{x}, \boldsymbol{x'}) = \
//           \tanh(\gamma \boldsymbol{x}^T \boldsymbol{x'} + c)
type SigmoidKernel struct {
	Gamma float64 `protobuf:"fixed64,1,opt,name=gamma,proto3" json:"gamma,omitempty"`
	C     float64 `protobuf:"fixed64,2,opt,name=c,proto3" json:"c,omitempty"`
}

func (m *SigmoidKernel) Reset()                    { *m = SigmoidKernel{} }
func (m *SigmoidKernel) String() string            { return proto.CompactTextString(m) }
func (*SigmoidKernel) ProtoMessage()               {}
func (*SigmoidKernel) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{3} }

func (m *SigmoidKernel) GetGamma() float64 {
	if m != nil {
		return m.Gamma
	}
	return 0
}

func (m *SigmoidKernel) GetC() float64 {
	if m != nil {
		return m.C
	}
	return 0
}

// *
// A kernel.
type Kernel struct {
	// Types that are valid to be assigned to Kernel:
	//	*Kernel_LinearKernel
	//	*Kernel_RbfKernel
	//	*Kernel_PolyKernel
	//	*Kernel_SigmoidKernel
	Kernel isKernel_Kernel `protobuf_oneof:"kernel"`
}

func (m *Kernel) Reset()                    { *m = Kernel{} }
func (m *Kernel) String() string            { return proto.CompactTextString(m) }
func (*Kernel) ProtoMessage()               {}
func (*Kernel) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{4} }

type isKernel_Kernel interface {
	isKernel_Kernel()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Kernel_LinearKernel struct {
	LinearKernel *LinearKernel `protobuf:"bytes,1,opt,name=linearKernel,oneof"`
}
type Kernel_RbfKernel struct {
	RbfKernel *RBFKernel `protobuf:"bytes,2,opt,name=rbfKernel,oneof"`
}
type Kernel_PolyKernel struct {
	PolyKernel *PolyKernel `protobuf:"bytes,3,opt,name=polyKernel,oneof"`
}
type Kernel_SigmoidKernel struct {
	SigmoidKernel *SigmoidKernel `protobuf:"bytes,4,opt,name=sigmoidKernel,oneof"`
}

func (*Kernel_LinearKernel) isKernel_Kernel()  {}
func (*Kernel_RbfKernel) isKernel_Kernel()     {}
func (*Kernel_PolyKernel) isKernel_Kernel()    {}
func (*Kernel_SigmoidKernel) isKernel_Kernel() {}

func (m *Kernel) GetKernel() isKernel_Kernel {
	if m != nil {
		return m.Kernel
	}
	return nil
}

func (m *Kernel) GetLinearKernel() *LinearKernel {
	if x, ok := m.GetKernel().(*Kernel_LinearKernel); ok {
		return x.LinearKernel
	}
	return nil
}

func (m *Kernel) GetRbfKernel() *RBFKernel {
	if x, ok := m.GetKernel().(*Kernel_RbfKernel); ok {
		return x.RbfKernel
	}
	return nil
}

func (m *Kernel) GetPolyKernel() *PolyKernel {
	if x, ok := m.GetKernel().(*Kernel_PolyKernel); ok {
		return x.PolyKernel
	}
	return nil
}

func (m *Kernel) GetSigmoidKernel() *SigmoidKernel {
	if x, ok := m.GetKernel().(*Kernel_SigmoidKernel); ok {
		return x.SigmoidKernel
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Kernel) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Kernel_OneofMarshaler, _Kernel_OneofUnmarshaler, _Kernel_OneofSizer, []interface{}{
		(*Kernel_LinearKernel)(nil),
		(*Kernel_RbfKernel)(nil),
		(*Kernel_PolyKernel)(nil),
		(*Kernel_SigmoidKernel)(nil),
	}
}

func _Kernel_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Kernel)
	// kernel
	switch x := m.Kernel.(type) {
	case *Kernel_LinearKernel:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LinearKernel); err != nil {
			return err
		}
	case *Kernel_RbfKernel:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RbfKernel); err != nil {
			return err
		}
	case *Kernel_PolyKernel:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PolyKernel); err != nil {
			return err
		}
	case *Kernel_SigmoidKernel:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SigmoidKernel); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Kernel.Kernel has unexpected type %T", x)
	}
	return nil
}

func _Kernel_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Kernel)
	switch tag {
	case 1: // kernel.linearKernel
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LinearKernel)
		err := b.DecodeMessage(msg)
		m.Kernel = &Kernel_LinearKernel{msg}
		return true, err
	case 2: // kernel.rbfKernel
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RBFKernel)
		err := b.DecodeMessage(msg)
		m.Kernel = &Kernel_RbfKernel{msg}
		return true, err
	case 3: // kernel.polyKernel
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PolyKernel)
		err := b.DecodeMessage(msg)
		m.Kernel = &Kernel_PolyKernel{msg}
		return true, err
	case 4: // kernel.sigmoidKernel
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SigmoidKernel)
		err := b.DecodeMessage(msg)
		m.Kernel = &Kernel_SigmoidKernel{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Kernel_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Kernel)
	// kernel
	switch x := m.Kernel.(type) {
	case *Kernel_LinearKernel:
		s := proto.Size(x.LinearKernel)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Kernel_RbfKernel:
		s := proto.Size(x.RbfKernel)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Kernel_PolyKernel:
		s := proto.Size(x.PolyKernel)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Kernel_SigmoidKernel:
		s := proto.Size(x.SigmoidKernel)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// A sparse node.
type SparseNode struct {
	Index int32   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Value float64 `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SparseNode) Reset()                    { *m = SparseNode{} }
func (m *SparseNode) String() string            { return proto.CompactTextString(m) }
func (*SparseNode) ProtoMessage()               {}
func (*SparseNode) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{5} }

func (m *SparseNode) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SparseNode) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// *
// A sparse vector.
type SparseVector struct {
	Nodes []*SparseNode `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *SparseVector) Reset()                    { *m = SparseVector{} }
func (m *SparseVector) String() string            { return proto.CompactTextString(m) }
func (*SparseVector) ProtoMessage()               {}
func (*SparseVector) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{6} }

func (m *SparseVector) GetNodes() []*SparseNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// *
// One or more sparse support vectors.
type SparseSupportVectors struct {
	Vectors []*SparseVector `protobuf:"bytes,1,rep,name=vectors" json:"vectors,omitempty"`
}

func (m *SparseSupportVectors) Reset()                    { *m = SparseSupportVectors{} }
func (m *SparseSupportVectors) String() string            { return proto.CompactTextString(m) }
func (*SparseSupportVectors) ProtoMessage()               {}
func (*SparseSupportVectors) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{7} }

func (m *SparseSupportVectors) GetVectors() []*SparseVector {
	if m != nil {
		return m.Vectors
	}
	return nil
}

// *
// A dense vector.
type DenseVector struct {
	Values []float64 `protobuf:"fixed64,1,rep,packed,name=values" json:"values,omitempty"`
}

func (m *DenseVector) Reset()                    { *m = DenseVector{} }
func (m *DenseVector) String() string            { return proto.CompactTextString(m) }
func (*DenseVector) ProtoMessage()               {}
func (*DenseVector) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{8} }

func (m *DenseVector) GetValues() []float64 {
	if m != nil {
		return m.Values
	}
	return nil
}

// *
// One or more dense support vectors.
type DenseSupportVectors struct {
	Vectors []*DenseVector `protobuf:"bytes,1,rep,name=vectors" json:"vectors,omitempty"`
}

func (m *DenseSupportVectors) Reset()                    { *m = DenseSupportVectors{} }
func (m *DenseSupportVectors) String() string            { return proto.CompactTextString(m) }
func (*DenseSupportVectors) ProtoMessage()               {}
func (*DenseSupportVectors) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{9} }

func (m *DenseSupportVectors) GetVectors() []*DenseVector {
	if m != nil {
		return m.Vectors
	}
	return nil
}

// *
// One or more coefficients.
type Coefficients struct {
	Alpha []float64 `protobuf:"fixed64,1,rep,packed,name=alpha" json:"alpha,omitempty"`
}

func (m *Coefficients) Reset()                    { *m = Coefficients{} }
func (m *Coefficients) String() string            { return proto.CompactTextString(m) }
func (*Coefficients) ProtoMessage()               {}
func (*Coefficients) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{10} }

func (m *Coefficients) GetAlpha() []float64 {
	if m != nil {
		return m.Alpha
	}
	return nil
}

// *
// A support vector regressor.
type SupportVectorRegressor struct {
	Kernel *Kernel `protobuf:"bytes,1,opt,name=kernel" json:"kernel,omitempty"`
	// Support vectors, either sparse or dense format
	//
	// Types that are valid to be assigned to SupportVectors:
	//	*SupportVectorRegressor_SparseSupportVectors
	//	*SupportVectorRegressor_DenseSupportVectors
	SupportVectors isSupportVectorRegressor_SupportVectors `protobuf_oneof:"supportVectors"`
	// Coefficients, one for each support vector
	Coefficients *Coefficients `protobuf:"bytes,4,opt,name=coefficients" json:"coefficients,omitempty"`
	Rho          float64       `protobuf:"fixed64,5,opt,name=rho,proto3" json:"rho,omitempty"`
}

func (m *SupportVectorRegressor) Reset()                    { *m = SupportVectorRegressor{} }
func (m *SupportVectorRegressor) String() string            { return proto.CompactTextString(m) }
func (*SupportVectorRegressor) ProtoMessage()               {}
func (*SupportVectorRegressor) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{11} }

type isSupportVectorRegressor_SupportVectors interface {
	isSupportVectorRegressor_SupportVectors()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SupportVectorRegressor_SparseSupportVectors struct {
	SparseSupportVectors *SparseSupportVectors `protobuf:"bytes,2,opt,name=sparseSupportVectors,oneof"`
}
type SupportVectorRegressor_DenseSupportVectors struct {
	DenseSupportVectors *DenseSupportVectors `protobuf:"bytes,3,opt,name=denseSupportVectors,oneof"`
}

func (*SupportVectorRegressor_SparseSupportVectors) isSupportVectorRegressor_SupportVectors() {}
func (*SupportVectorRegressor_DenseSupportVectors) isSupportVectorRegressor_SupportVectors()  {}

func (m *SupportVectorRegressor) GetSupportVectors() isSupportVectorRegressor_SupportVectors {
	if m != nil {
		return m.SupportVectors
	}
	return nil
}

func (m *SupportVectorRegressor) GetKernel() *Kernel {
	if m != nil {
		return m.Kernel
	}
	return nil
}

func (m *SupportVectorRegressor) GetSparseSupportVectors() *SparseSupportVectors {
	if x, ok := m.GetSupportVectors().(*SupportVectorRegressor_SparseSupportVectors); ok {
		return x.SparseSupportVectors
	}
	return nil
}

func (m *SupportVectorRegressor) GetDenseSupportVectors() *DenseSupportVectors {
	if x, ok := m.GetSupportVectors().(*SupportVectorRegressor_DenseSupportVectors); ok {
		return x.DenseSupportVectors
	}
	return nil
}

func (m *SupportVectorRegressor) GetCoefficients() *Coefficients {
	if m != nil {
		return m.Coefficients
	}
	return nil
}

func (m *SupportVectorRegressor) GetRho() float64 {
	if m != nil {
		return m.Rho
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SupportVectorRegressor) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SupportVectorRegressor_OneofMarshaler, _SupportVectorRegressor_OneofUnmarshaler, _SupportVectorRegressor_OneofSizer, []interface{}{
		(*SupportVectorRegressor_SparseSupportVectors)(nil),
		(*SupportVectorRegressor_DenseSupportVectors)(nil),
	}
}

func _SupportVectorRegressor_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SupportVectorRegressor)
	// supportVectors
	switch x := m.SupportVectors.(type) {
	case *SupportVectorRegressor_SparseSupportVectors:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SparseSupportVectors); err != nil {
			return err
		}
	case *SupportVectorRegressor_DenseSupportVectors:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DenseSupportVectors); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SupportVectorRegressor.SupportVectors has unexpected type %T", x)
	}
	return nil
}

func _SupportVectorRegressor_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SupportVectorRegressor)
	switch tag {
	case 2: // supportVectors.sparseSupportVectors
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SparseSupportVectors)
		err := b.DecodeMessage(msg)
		m.SupportVectors = &SupportVectorRegressor_SparseSupportVectors{msg}
		return true, err
	case 3: // supportVectors.denseSupportVectors
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DenseSupportVectors)
		err := b.DecodeMessage(msg)
		m.SupportVectors = &SupportVectorRegressor_DenseSupportVectors{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SupportVectorRegressor_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SupportVectorRegressor)
	// supportVectors
	switch x := m.SupportVectors.(type) {
	case *SupportVectorRegressor_SparseSupportVectors:
		s := proto.Size(x.SparseSupportVectors)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SupportVectorRegressor_DenseSupportVectors:
		s := proto.Size(x.DenseSupportVectors)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// A support vector classifier
type SupportVectorClassifier struct {
	Kernel *Kernel `protobuf:"bytes,1,opt,name=kernel" json:"kernel,omitempty"`
	// *
	// The number of support vectors for each class.
	NumberOfSupportVectorsPerClass []int32 `protobuf:"varint,2,rep,packed,name=numberOfSupportVectorsPerClass" json:"numberOfSupportVectorsPerClass,omitempty"`
	// *
	// The support vectors, in either sparse or dense format.
	//
	// Types that are valid to be assigned to SupportVectors:
	//	*SupportVectorClassifier_SparseSupportVectors
	//	*SupportVectorClassifier_DenseSupportVectors
	SupportVectors isSupportVectorClassifier_SupportVectors `protobuf_oneof:"supportVectors"`
	// *
	// The coefficients, essentially a two dimensional array of
	// size: (numberOfClasses-1) by (total number of support vectors)
	Coefficients []*Coefficients `protobuf:"bytes,5,rep,name=coefficients" json:"coefficients,omitempty"`
	// *
	// Constants for decision function,
	// with K*(K-1) / 2 elements,
	// where K is the number of classes.
	Rho []float64 `protobuf:"fixed64,6,rep,packed,name=rho" json:"rho,omitempty"`
	// *
	// Pairwise probability information for A vs B classifier.
	// Total of K*(K-1)/2 elements where K is the number of classes.
	// These fields are optional,
	// and only required if you want probabilities or multi class predictions.
	ProbA []float64 `protobuf:"fixed64,7,rep,packed,name=probA" json:"probA,omitempty"`
	ProbB []float64 `protobuf:"fixed64,8,rep,packed,name=probB" json:"probB,omitempty"`
	// *
	// Class label mapping.
	//
	// Types that are valid to be assigned to ClassLabels:
	//	*SupportVectorClassifier_StringClassLabels
	//	*SupportVectorClassifier_Int64ClassLabels
	ClassLabels isSupportVectorClassifier_ClassLabels `protobuf_oneof:"ClassLabels"`
}

func (m *SupportVectorClassifier) Reset()                    { *m = SupportVectorClassifier{} }
func (m *SupportVectorClassifier) String() string            { return proto.CompactTextString(m) }
func (*SupportVectorClassifier) ProtoMessage()               {}
func (*SupportVectorClassifier) Descriptor() ([]byte, []int) { return fileDescriptorSVM, []int{12} }

type isSupportVectorClassifier_SupportVectors interface {
	isSupportVectorClassifier_SupportVectors()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isSupportVectorClassifier_ClassLabels interface {
	isSupportVectorClassifier_ClassLabels()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SupportVectorClassifier_SparseSupportVectors struct {
	SparseSupportVectors *SparseSupportVectors `protobuf:"bytes,3,opt,name=sparseSupportVectors,oneof"`
}
type SupportVectorClassifier_DenseSupportVectors struct {
	DenseSupportVectors *DenseSupportVectors `protobuf:"bytes,4,opt,name=denseSupportVectors,oneof"`
}
type SupportVectorClassifier_StringClassLabels struct {
	StringClassLabels *StringVector `protobuf:"bytes,100,opt,name=stringClassLabels,oneof"`
}
type SupportVectorClassifier_Int64ClassLabels struct {
	Int64ClassLabels *Int64Vector `protobuf:"bytes,101,opt,name=int64ClassLabels,oneof"`
}

func (*SupportVectorClassifier_SparseSupportVectors) isSupportVectorClassifier_SupportVectors() {}
func (*SupportVectorClassifier_DenseSupportVectors) isSupportVectorClassifier_SupportVectors()  {}
func (*SupportVectorClassifier_StringClassLabels) isSupportVectorClassifier_ClassLabels()       {}
func (*SupportVectorClassifier_Int64ClassLabels) isSupportVectorClassifier_ClassLabels()        {}

func (m *SupportVectorClassifier) GetSupportVectors() isSupportVectorClassifier_SupportVectors {
	if m != nil {
		return m.SupportVectors
	}
	return nil
}
func (m *SupportVectorClassifier) GetClassLabels() isSupportVectorClassifier_ClassLabels {
	if m != nil {
		return m.ClassLabels
	}
	return nil
}

func (m *SupportVectorClassifier) GetKernel() *Kernel {
	if m != nil {
		return m.Kernel
	}
	return nil
}

func (m *SupportVectorClassifier) GetNumberOfSupportVectorsPerClass() []int32 {
	if m != nil {
		return m.NumberOfSupportVectorsPerClass
	}
	return nil
}

func (m *SupportVectorClassifier) GetSparseSupportVectors() *SparseSupportVectors {
	if x, ok := m.GetSupportVectors().(*SupportVectorClassifier_SparseSupportVectors); ok {
		return x.SparseSupportVectors
	}
	return nil
}

func (m *SupportVectorClassifier) GetDenseSupportVectors() *DenseSupportVectors {
	if x, ok := m.GetSupportVectors().(*SupportVectorClassifier_DenseSupportVectors); ok {
		return x.DenseSupportVectors
	}
	return nil
}

func (m *SupportVectorClassifier) GetCoefficients() []*Coefficients {
	if m != nil {
		return m.Coefficients
	}
	return nil
}

func (m *SupportVectorClassifier) GetRho() []float64 {
	if m != nil {
		return m.Rho
	}
	return nil
}

func (m *SupportVectorClassifier) GetProbA() []float64 {
	if m != nil {
		return m.ProbA
	}
	return nil
}

func (m *SupportVectorClassifier) GetProbB() []float64 {
	if m != nil {
		return m.ProbB
	}
	return nil
}

func (m *SupportVectorClassifier) GetStringClassLabels() *StringVector {
	if x, ok := m.GetClassLabels().(*SupportVectorClassifier_StringClassLabels); ok {
		return x.StringClassLabels
	}
	return nil
}

func (m *SupportVectorClassifier) GetInt64ClassLabels() *Int64Vector {
	if x, ok := m.GetClassLabels().(*SupportVectorClassifier_Int64ClassLabels); ok {
		return x.Int64ClassLabels
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SupportVectorClassifier) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SupportVectorClassifier_OneofMarshaler, _SupportVectorClassifier_OneofUnmarshaler, _SupportVectorClassifier_OneofSizer, []interface{}{
		(*SupportVectorClassifier_SparseSupportVectors)(nil),
		(*SupportVectorClassifier_DenseSupportVectors)(nil),
		(*SupportVectorClassifier_StringClassLabels)(nil),
		(*SupportVectorClassifier_Int64ClassLabels)(nil),
	}
}

func _SupportVectorClassifier_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SupportVectorClassifier)
	// supportVectors
	switch x := m.SupportVectors.(type) {
	case *SupportVectorClassifier_SparseSupportVectors:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SparseSupportVectors); err != nil {
			return err
		}
	case *SupportVectorClassifier_DenseSupportVectors:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DenseSupportVectors); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SupportVectorClassifier.SupportVectors has unexpected type %T", x)
	}
	// ClassLabels
	switch x := m.ClassLabels.(type) {
	case *SupportVectorClassifier_StringClassLabels:
		_ = b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StringClassLabels); err != nil {
			return err
		}
	case *SupportVectorClassifier_Int64ClassLabels:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Int64ClassLabels); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SupportVectorClassifier.ClassLabels has unexpected type %T", x)
	}
	return nil
}

func _SupportVectorClassifier_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SupportVectorClassifier)
	switch tag {
	case 3: // supportVectors.sparseSupportVectors
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SparseSupportVectors)
		err := b.DecodeMessage(msg)
		m.SupportVectors = &SupportVectorClassifier_SparseSupportVectors{msg}
		return true, err
	case 4: // supportVectors.denseSupportVectors
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DenseSupportVectors)
		err := b.DecodeMessage(msg)
		m.SupportVectors = &SupportVectorClassifier_DenseSupportVectors{msg}
		return true, err
	case 100: // ClassLabels.stringClassLabels
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringVector)
		err := b.DecodeMessage(msg)
		m.ClassLabels = &SupportVectorClassifier_StringClassLabels{msg}
		return true, err
	case 101: // ClassLabels.int64ClassLabels
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Int64Vector)
		err := b.DecodeMessage(msg)
		m.ClassLabels = &SupportVectorClassifier_Int64ClassLabels{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SupportVectorClassifier_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SupportVectorClassifier)
	// supportVectors
	switch x := m.SupportVectors.(type) {
	case *SupportVectorClassifier_SparseSupportVectors:
		s := proto.Size(x.SparseSupportVectors)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SupportVectorClassifier_DenseSupportVectors:
		s := proto.Size(x.DenseSupportVectors)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// ClassLabels
	switch x := m.ClassLabels.(type) {
	case *SupportVectorClassifier_StringClassLabels:
		s := proto.Size(x.StringClassLabels)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SupportVectorClassifier_Int64ClassLabels:
		s := proto.Size(x.Int64ClassLabels)
		n += proto.SizeVarint(101<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*LinearKernel)(nil), "CoreML.LinearKernel")
	proto.RegisterType((*RBFKernel)(nil), "CoreML.RBFKernel")
	proto.RegisterType((*PolyKernel)(nil), "CoreML.PolyKernel")
	proto.RegisterType((*SigmoidKernel)(nil), "CoreML.SigmoidKernel")
	proto.RegisterType((*Kernel)(nil), "CoreML.Kernel")
	proto.RegisterType((*SparseNode)(nil), "CoreML.SparseNode")
	proto.RegisterType((*SparseVector)(nil), "CoreML.SparseVector")
	proto.RegisterType((*SparseSupportVectors)(nil), "CoreML.SparseSupportVectors")
	proto.RegisterType((*DenseVector)(nil), "CoreML.DenseVector")
	proto.RegisterType((*DenseSupportVectors)(nil), "CoreML.DenseSupportVectors")
	proto.RegisterType((*Coefficients)(nil), "CoreML.Coefficients")
	proto.RegisterType((*SupportVectorRegressor)(nil), "CoreML.SupportVectorRegressor")
	proto.RegisterType((*SupportVectorClassifier)(nil), "CoreML.SupportVectorClassifier")
}
func (m *LinearKernel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinearKernel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RBFKernel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RBFKernel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gamma != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64SVM(dAtA, i, uint64(math.Float64bits(float64(m.Gamma))))
	}
	return i, nil
}

func (m *PolyKernel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolyKernel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Degree != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.Degree))
	}
	if m.C != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64SVM(dAtA, i, uint64(math.Float64bits(float64(m.C))))
	}
	if m.Gamma != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64SVM(dAtA, i, uint64(math.Float64bits(float64(m.Gamma))))
	}
	return i, nil
}

func (m *SigmoidKernel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigmoidKernel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gamma != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64SVM(dAtA, i, uint64(math.Float64bits(float64(m.Gamma))))
	}
	if m.C != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64SVM(dAtA, i, uint64(math.Float64bits(float64(m.C))))
	}
	return i, nil
}

func (m *Kernel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kernel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kernel != nil {
		nn1, err := m.Kernel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *Kernel_LinearKernel) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LinearKernel != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.LinearKernel.Size()))
		n2, err := m.LinearKernel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *Kernel_RbfKernel) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RbfKernel != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.RbfKernel.Size()))
		n3, err := m.RbfKernel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Kernel_PolyKernel) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PolyKernel != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.PolyKernel.Size()))
		n4, err := m.PolyKernel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Kernel_SigmoidKernel) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SigmoidKernel != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.SigmoidKernel.Size()))
		n5, err := m.SigmoidKernel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *SparseNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.Index))
	}
	if m.Value != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64SVM(dAtA, i, uint64(math.Float64bits(float64(m.Value))))
	}
	return i, nil
}

func (m *SparseVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseVector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSVM(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SparseSupportVectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseSupportVectors) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vectors) > 0 {
		for _, msg := range m.Vectors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSVM(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DenseVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenseVector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSVM(dAtA, i, uint64(len(m.Values)*8))
		for _, num := range m.Values {
			f6 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f6)
			i++
			dAtA[i] = uint8(f6 >> 8)
			i++
			dAtA[i] = uint8(f6 >> 16)
			i++
			dAtA[i] = uint8(f6 >> 24)
			i++
			dAtA[i] = uint8(f6 >> 32)
			i++
			dAtA[i] = uint8(f6 >> 40)
			i++
			dAtA[i] = uint8(f6 >> 48)
			i++
			dAtA[i] = uint8(f6 >> 56)
			i++
		}
	}
	return i, nil
}

func (m *DenseSupportVectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenseSupportVectors) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vectors) > 0 {
		for _, msg := range m.Vectors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSVM(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Coefficients) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Coefficients) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Alpha) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSVM(dAtA, i, uint64(len(m.Alpha)*8))
		for _, num := range m.Alpha {
			f7 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f7)
			i++
			dAtA[i] = uint8(f7 >> 8)
			i++
			dAtA[i] = uint8(f7 >> 16)
			i++
			dAtA[i] = uint8(f7 >> 24)
			i++
			dAtA[i] = uint8(f7 >> 32)
			i++
			dAtA[i] = uint8(f7 >> 40)
			i++
			dAtA[i] = uint8(f7 >> 48)
			i++
			dAtA[i] = uint8(f7 >> 56)
			i++
		}
	}
	return i, nil
}

func (m *SupportVectorRegressor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportVectorRegressor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kernel != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.Kernel.Size()))
		n8, err := m.Kernel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.SupportVectors != nil {
		nn9, err := m.SupportVectors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	if m.Coefficients != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.Coefficients.Size()))
		n10, err := m.Coefficients.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Rho != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64SVM(dAtA, i, uint64(math.Float64bits(float64(m.Rho))))
	}
	return i, nil
}

func (m *SupportVectorRegressor_SparseSupportVectors) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SparseSupportVectors != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.SparseSupportVectors.Size()))
		n11, err := m.SparseSupportVectors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *SupportVectorRegressor_DenseSupportVectors) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DenseSupportVectors != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.DenseSupportVectors.Size()))
		n12, err := m.DenseSupportVectors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *SupportVectorClassifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportVectorClassifier) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kernel != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.Kernel.Size()))
		n13, err := m.Kernel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.NumberOfSupportVectorsPerClass) > 0 {
		dAtA15 := make([]byte, len(m.NumberOfSupportVectorsPerClass)*10)
		var j14 int
		for _, num1 := range m.NumberOfSupportVectorsPerClass {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintSVM(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if m.SupportVectors != nil {
		nn16, err := m.SupportVectors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	if len(m.Coefficients) > 0 {
		for _, msg := range m.Coefficients {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintSVM(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Rho) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSVM(dAtA, i, uint64(len(m.Rho)*8))
		for _, num := range m.Rho {
			f17 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f17)
			i++
			dAtA[i] = uint8(f17 >> 8)
			i++
			dAtA[i] = uint8(f17 >> 16)
			i++
			dAtA[i] = uint8(f17 >> 24)
			i++
			dAtA[i] = uint8(f17 >> 32)
			i++
			dAtA[i] = uint8(f17 >> 40)
			i++
			dAtA[i] = uint8(f17 >> 48)
			i++
			dAtA[i] = uint8(f17 >> 56)
			i++
		}
	}
	if len(m.ProbA) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSVM(dAtA, i, uint64(len(m.ProbA)*8))
		for _, num := range m.ProbA {
			f18 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f18)
			i++
			dAtA[i] = uint8(f18 >> 8)
			i++
			dAtA[i] = uint8(f18 >> 16)
			i++
			dAtA[i] = uint8(f18 >> 24)
			i++
			dAtA[i] = uint8(f18 >> 32)
			i++
			dAtA[i] = uint8(f18 >> 40)
			i++
			dAtA[i] = uint8(f18 >> 48)
			i++
			dAtA[i] = uint8(f18 >> 56)
			i++
		}
	}
	if len(m.ProbB) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSVM(dAtA, i, uint64(len(m.ProbB)*8))
		for _, num := range m.ProbB {
			f19 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f19)
			i++
			dAtA[i] = uint8(f19 >> 8)
			i++
			dAtA[i] = uint8(f19 >> 16)
			i++
			dAtA[i] = uint8(f19 >> 24)
			i++
			dAtA[i] = uint8(f19 >> 32)
			i++
			dAtA[i] = uint8(f19 >> 40)
			i++
			dAtA[i] = uint8(f19 >> 48)
			i++
			dAtA[i] = uint8(f19 >> 56)
			i++
		}
	}
	if m.ClassLabels != nil {
		nn20, err := m.ClassLabels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn20
	}
	return i, nil
}

func (m *SupportVectorClassifier_SparseSupportVectors) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SparseSupportVectors != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.SparseSupportVectors.Size()))
		n21, err := m.SparseSupportVectors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *SupportVectorClassifier_DenseSupportVectors) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DenseSupportVectors != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.DenseSupportVectors.Size()))
		n22, err := m.DenseSupportVectors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *SupportVectorClassifier_StringClassLabels) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StringClassLabels != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.StringClassLabels.Size()))
		n23, err := m.StringClassLabels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *SupportVectorClassifier_Int64ClassLabels) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Int64ClassLabels != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintSVM(dAtA, i, uint64(m.Int64ClassLabels.Size()))
		n24, err := m.Int64ClassLabels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func encodeFixed64SVM(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32SVM(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSVM(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LinearKernel) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RBFKernel) Size() (n int) {
	var l int
	_ = l
	if m.Gamma != 0 {
		n += 9
	}
	return n
}

func (m *PolyKernel) Size() (n int) {
	var l int
	_ = l
	if m.Degree != 0 {
		n += 1 + sovSVM(uint64(m.Degree))
	}
	if m.C != 0 {
		n += 9
	}
	if m.Gamma != 0 {
		n += 9
	}
	return n
}

func (m *SigmoidKernel) Size() (n int) {
	var l int
	_ = l
	if m.Gamma != 0 {
		n += 9
	}
	if m.C != 0 {
		n += 9
	}
	return n
}

func (m *Kernel) Size() (n int) {
	var l int
	_ = l
	if m.Kernel != nil {
		n += m.Kernel.Size()
	}
	return n
}

func (m *Kernel_LinearKernel) Size() (n int) {
	var l int
	_ = l
	if m.LinearKernel != nil {
		l = m.LinearKernel.Size()
		n += 1 + l + sovSVM(uint64(l))
	}
	return n
}
func (m *Kernel_RbfKernel) Size() (n int) {
	var l int
	_ = l
	if m.RbfKernel != nil {
		l = m.RbfKernel.Size()
		n += 1 + l + sovSVM(uint64(l))
	}
	return n
}
func (m *Kernel_PolyKernel) Size() (n int) {
	var l int
	_ = l
	if m.PolyKernel != nil {
		l = m.PolyKernel.Size()
		n += 1 + l + sovSVM(uint64(l))
	}
	return n
}
func (m *Kernel_SigmoidKernel) Size() (n int) {
	var l int
	_ = l
	if m.SigmoidKernel != nil {
		l = m.SigmoidKernel.Size()
		n += 1 + l + sovSVM(uint64(l))
	}
	return n
}
func (m *SparseNode) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovSVM(uint64(m.Index))
	}
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *SparseVector) Size() (n int) {
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovSVM(uint64(l))
		}
	}
	return n
}

func (m *SparseSupportVectors) Size() (n int) {
	var l int
	_ = l
	if len(m.Vectors) > 0 {
		for _, e := range m.Vectors {
			l = e.Size()
			n += 1 + l + sovSVM(uint64(l))
		}
	}
	return n
}

func (m *DenseVector) Size() (n int) {
	var l int
	_ = l
	if len(m.Values) > 0 {
		n += 1 + sovSVM(uint64(len(m.Values)*8)) + len(m.Values)*8
	}
	return n
}

func (m *DenseSupportVectors) Size() (n int) {
	var l int
	_ = l
	if len(m.Vectors) > 0 {
		for _, e := range m.Vectors {
			l = e.Size()
			n += 1 + l + sovSVM(uint64(l))
		}
	}
	return n
}

func (m *Coefficients) Size() (n int) {
	var l int
	_ = l
	if len(m.Alpha) > 0 {
		n += 1 + sovSVM(uint64(len(m.Alpha)*8)) + len(m.Alpha)*8
	}
	return n
}

func (m *SupportVectorRegressor) Size() (n int) {
	var l int
	_ = l
	if m.Kernel != nil {
		l = m.Kernel.Size()
		n += 1 + l + sovSVM(uint64(l))
	}
	if m.SupportVectors != nil {
		n += m.SupportVectors.Size()
	}
	if m.Coefficients != nil {
		l = m.Coefficients.Size()
		n += 1 + l + sovSVM(uint64(l))
	}
	if m.Rho != 0 {
		n += 9
	}
	return n
}

func (m *SupportVectorRegressor_SparseSupportVectors) Size() (n int) {
	var l int
	_ = l
	if m.SparseSupportVectors != nil {
		l = m.SparseSupportVectors.Size()
		n += 1 + l + sovSVM(uint64(l))
	}
	return n
}
func (m *SupportVectorRegressor_DenseSupportVectors) Size() (n int) {
	var l int
	_ = l
	if m.DenseSupportVectors != nil {
		l = m.DenseSupportVectors.Size()
		n += 1 + l + sovSVM(uint64(l))
	}
	return n
}
func (m *SupportVectorClassifier) Size() (n int) {
	var l int
	_ = l
	if m.Kernel != nil {
		l = m.Kernel.Size()
		n += 1 + l + sovSVM(uint64(l))
	}
	if len(m.NumberOfSupportVectorsPerClass) > 0 {
		l = 0
		for _, e := range m.NumberOfSupportVectorsPerClass {
			l += sovSVM(uint64(e))
		}
		n += 1 + sovSVM(uint64(l)) + l
	}
	if m.SupportVectors != nil {
		n += m.SupportVectors.Size()
	}
	if len(m.Coefficients) > 0 {
		for _, e := range m.Coefficients {
			l = e.Size()
			n += 1 + l + sovSVM(uint64(l))
		}
	}
	if len(m.Rho) > 0 {
		n += 1 + sovSVM(uint64(len(m.Rho)*8)) + len(m.Rho)*8
	}
	if len(m.ProbA) > 0 {
		n += 1 + sovSVM(uint64(len(m.ProbA)*8)) + len(m.ProbA)*8
	}
	if len(m.ProbB) > 0 {
		n += 1 + sovSVM(uint64(len(m.ProbB)*8)) + len(m.ProbB)*8
	}
	if m.ClassLabels != nil {
		n += m.ClassLabels.Size()
	}
	return n
}

func (m *SupportVectorClassifier_SparseSupportVectors) Size() (n int) {
	var l int
	_ = l
	if m.SparseSupportVectors != nil {
		l = m.SparseSupportVectors.Size()
		n += 1 + l + sovSVM(uint64(l))
	}
	return n
}
func (m *SupportVectorClassifier_DenseSupportVectors) Size() (n int) {
	var l int
	_ = l
	if m.DenseSupportVectors != nil {
		l = m.DenseSupportVectors.Size()
		n += 1 + l + sovSVM(uint64(l))
	}
	return n
}
func (m *SupportVectorClassifier_StringClassLabels) Size() (n int) {
	var l int
	_ = l
	if m.StringClassLabels != nil {
		l = m.StringClassLabels.Size()
		n += 2 + l + sovSVM(uint64(l))
	}
	return n
}
func (m *SupportVectorClassifier_Int64ClassLabels) Size() (n int) {
	var l int
	_ = l
	if m.Int64ClassLabels != nil {
		l = m.Int64ClassLabels.Size()
		n += 2 + l + sovSVM(uint64(l))
	}
	return n
}

func sovSVM(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSVM(x uint64) (n int) {
	return sovSVM(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LinearKernel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinearKernel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinearKernel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RBFKernel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RBFKernel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RBFKernel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gamma", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Gamma = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolyKernel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolyKernel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolyKernel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Degree", wireType)
			}
			m.Degree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Degree |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.C = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gamma", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Gamma = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigmoidKernel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigmoidKernel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigmoidKernel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gamma", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Gamma = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.C = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kernel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kernel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kernel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinearKernel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LinearKernel{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kernel = &Kernel_LinearKernel{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RbfKernel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RBFKernel{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kernel = &Kernel_RbfKernel{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolyKernel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PolyKernel{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kernel = &Kernel_PolyKernel{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigmoidKernel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SigmoidKernel{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kernel = &Kernel_SigmoidKernel{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &SparseNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseSupportVectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseSupportVectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseSupportVectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vectors = append(m.Vectors, &SparseVector{})
			if err := m.Vectors[len(m.Vectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Values = append(m.Values, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSVM
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSVM
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Values = append(m.Values, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseSupportVectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseSupportVectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseSupportVectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vectors = append(m.Vectors, &DenseVector{})
			if err := m.Vectors[len(m.Vectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Coefficients) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Coefficients: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Coefficients: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Alpha = append(m.Alpha, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSVM
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSVM
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Alpha = append(m.Alpha, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Alpha", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportVectorRegressor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportVectorRegressor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportVectorRegressor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kernel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kernel == nil {
				m.Kernel = &Kernel{}
			}
			if err := m.Kernel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparseSupportVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SparseSupportVectors{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SupportVectors = &SupportVectorRegressor_SparseSupportVectors{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseSupportVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DenseSupportVectors{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SupportVectors = &SupportVectorRegressor_DenseSupportVectors{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coefficients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coefficients == nil {
				m.Coefficients = &Coefficients{}
			}
			if err := m.Coefficients.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rho", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Rho = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportVectorClassifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportVectorClassifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportVectorClassifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kernel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kernel == nil {
				m.Kernel = &Kernel{}
			}
			if err := m.Kernel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSVM
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NumberOfSupportVectorsPerClass = append(m.NumberOfSupportVectorsPerClass, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSVM
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSVM
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSVM
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NumberOfSupportVectorsPerClass = append(m.NumberOfSupportVectorsPerClass, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfSupportVectorsPerClass", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparseSupportVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SparseSupportVectors{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SupportVectors = &SupportVectorClassifier_SparseSupportVectors{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseSupportVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DenseSupportVectors{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SupportVectors = &SupportVectorClassifier_DenseSupportVectors{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coefficients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coefficients = append(m.Coefficients, &Coefficients{})
			if err := m.Coefficients[len(m.Coefficients)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Rho = append(m.Rho, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSVM
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSVM
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Rho = append(m.Rho, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Rho", wireType)
			}
		case 7:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.ProbA = append(m.ProbA, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSVM
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSVM
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.ProbA = append(m.ProbA, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbA", wireType)
			}
		case 8:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.ProbB = append(m.ProbB, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSVM
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSVM
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.ProbB = append(m.ProbB, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbB", wireType)
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringClassLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringVector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClassLabels = &SupportVectorClassifier_StringClassLabels{v}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64ClassLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSVM
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Int64Vector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClassLabels = &SupportVectorClassifier_Int64ClassLabels{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSVM(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSVM
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSVM(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSVM
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSVM
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSVM
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSVM
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSVM(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSVM = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSVM   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("SVM.proto", fileDescriptorSVM) }

var fileDescriptorSVM = []byte{
	// 663 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x5d, 0x4f, 0x13, 0x41,
	0x14, 0xdd, 0x69, 0xe9, 0x02, 0xb7, 0x85, 0xc0, 0x50, 0x71, 0xa3, 0xa6, 0xc1, 0x8d, 0x1a, 0x5e,
	0x6c, 0x22, 0x10, 0x43, 0x4c, 0x7c, 0xa0, 0x34, 0x64, 0x8d, 0x20, 0x64, 0x9a, 0xf0, 0xbe, 0xed,
	0x4e, 0xcb, 0xc6, 0xed, 0xce, 0x66, 0x66, 0x4b, 0xf4, 0x5f, 0xf8, 0x9f, 0x7c, 0xf1, 0x91, 0x9f,
	0x60, 0xf0, 0x3f, 0xf8, 0x6c, 0x76, 0x66, 0xf6, 0x63, 0x68, 0x15, 0x1f, 0x78, 0xdb, 0x3b, 0x73,
	0xce, 0xb9, 0x73, 0xcf, 0x3d, 0x4d, 0x61, 0x75, 0x70, 0x79, 0xd6, 0x4d, 0x38, 0x4b, 0x19, 0xb6,
	0x8f, 0x19, 0xa7, 0x67, 0xa7, 0x4f, 0xda, 0x7d, 0x3f, 0xf5, 0x07, 0x29, 0x9f, 0x8d, 0xd2, 0x19,
	0xa7, 0x42, 0xdd, 0xba, 0xeb, 0xd0, 0x3a, 0x0d, 0x63, 0xea, 0xf3, 0x8f, 0x94, 0xc7, 0x34, 0x72,
	0x9f, 0xc3, 0x2a, 0xe9, 0x9d, 0xa8, 0x02, 0xb7, 0xa1, 0x31, 0xf1, 0xa7, 0x53, 0xdf, 0x41, 0x3b,
	0x68, 0x17, 0x11, 0x55, 0xb8, 0x1e, 0xc0, 0x05, 0x8b, 0xbe, 0x6a, 0xcc, 0x36, 0xd8, 0x01, 0x9d,
	0x70, 0x4a, 0x25, 0xa8, 0x41, 0x74, 0x85, 0x5b, 0x80, 0x46, 0x4e, 0x4d, 0xf2, 0xd0, 0xa8, 0x54,
	0xaa, 0x57, 0x95, 0xf6, 0x61, 0x6d, 0x10, 0x4e, 0xa6, 0x2c, 0x0c, 0xfe, 0xd5, 0xd0, 0x94, 0x72,
	0x7f, 0x23, 0xb0, 0x35, 0xfc, 0x1d, 0xb4, 0xa2, 0xca, 0xe3, 0x25, 0xab, 0xb9, 0xd7, 0xee, 0xaa,
	0x89, 0xbb, 0xd5, 0xc1, 0x3c, 0x8b, 0x18, 0x58, 0xfc, 0x06, 0x56, 0xf9, 0x70, 0xac, 0x89, 0x35,
	0x49, 0xdc, 0xcc, 0x89, 0x85, 0x03, 0x9e, 0x45, 0x4a, 0x14, 0x3e, 0x00, 0x48, 0x8a, 0xc1, 0xe5,
	0x24, 0xcd, 0x3d, 0x9c, 0x73, 0x4a, 0x4b, 0x3c, 0x8b, 0x54, 0x70, 0xf8, 0x3d, 0xac, 0x89, 0xea,
	0x90, 0xce, 0x92, 0x24, 0x3e, 0xca, 0x89, 0x86, 0x03, 0x9e, 0x45, 0x4c, 0x74, 0x6f, 0x05, 0xec,
	0xcf, 0x6a, 0x35, 0x87, 0x00, 0x83, 0xc4, 0xe7, 0x82, 0x7e, 0x62, 0x01, 0xcd, 0xac, 0x0a, 0xe3,
	0x80, 0x7e, 0xd1, 0xb6, 0xab, 0x22, 0x3b, 0xbd, 0xf6, 0xa3, 0x19, 0xd5, 0x76, 0xa9, 0xc2, 0x3d,
	0x84, 0x96, 0x62, 0x5e, 0xd2, 0x51, 0xca, 0x38, 0xde, 0x85, 0x46, 0xcc, 0x02, 0x2a, 0x1c, 0xb4,
	0x53, 0xaf, 0xce, 0x50, 0xca, 0x13, 0x05, 0x70, 0x4f, 0xa0, 0xad, 0x0e, 0x07, 0xb3, 0x24, 0x61,
	0x3c, 0x55, 0x02, 0x02, 0x77, 0x61, 0xf9, 0x5a, 0x7d, 0x6a, 0x8d, 0xb6, 0xa9, 0xa1, 0x70, 0x24,
	0x07, 0xb9, 0x2f, 0xa1, 0xd9, 0xa7, 0x71, 0xf1, 0x80, 0x6d, 0xb0, 0xe5, 0xcb, 0x14, 0x1b, 0x11,
	0x5d, 0xb9, 0x7d, 0xd8, 0x92, 0xb0, 0x3b, 0xdd, 0x5e, 0xdf, 0xed, 0xb6, 0x95, 0x77, 0xab, 0x88,
	0x96, 0xcd, 0x5e, 0x40, 0xeb, 0x98, 0xd1, 0xf1, 0x38, 0x1c, 0x85, 0x34, 0x4e, 0x45, 0x66, 0x8a,
	0x1f, 0x25, 0x57, 0xbe, 0x6e, 0xa6, 0x0a, 0xf7, 0x7b, 0x0d, 0xb6, 0x8d, 0x3e, 0x24, 0x0b, 0xae,
	0x10, 0x8c, 0xe3, 0x57, 0xb9, 0xe7, 0x3a, 0x51, 0xeb, 0x79, 0x3b, 0xb5, 0x13, 0xa2, 0x6f, 0x31,
	0x81, 0xb6, 0x58, 0xe0, 0x8e, 0x8e, 0xd3, 0x33, 0xd3, 0x12, 0x13, 0xe3, 0x59, 0x64, 0x21, 0x17,
	0x9f, 0xc3, 0x56, 0x30, 0x6f, 0x81, 0x4e, 0xdb, 0x53, 0x63, 0xee, 0x39, 0xc5, 0x45, 0x4c, 0x7c,
	0x08, 0xad, 0x51, 0xc5, 0x0d, 0x1d, 0xbf, 0x62, 0x5f, 0x55, 0xa7, 0x88, 0x81, 0xc4, 0x1b, 0x50,
	0xe7, 0x57, 0xcc, 0x69, 0xc8, 0x28, 0x65, 0x9f, 0xbd, 0x0d, 0x58, 0x17, 0x86, 0xba, 0x7b, 0xb3,
	0x04, 0x8f, 0x8d, 0x86, 0xc7, 0x91, 0x2f, 0x44, 0x38, 0x0e, 0xe9, 0xff, 0xdb, 0x78, 0x02, 0x9d,
	0x78, 0x36, 0x1d, 0x52, 0x7e, 0x3e, 0x36, 0xdf, 0x7e, 0x41, 0x95, 0x9c, 0x53, 0xdb, 0xa9, 0xef,
	0x36, 0xc8, 0x3d, 0xa8, 0xbf, 0xae, 0xa3, 0xfe, 0xf0, 0xeb, 0x58, 0x7a, 0xb0, 0x75, 0x34, 0xcc,
	0x9f, 0xcf, 0xfd, 0xeb, 0xb0, 0x65, 0x88, 0xb3, 0xcf, 0x2c, 0xd8, 0x09, 0x67, 0xc3, 0x23, 0x67,
	0x59, 0x05, 0x5b, 0x16, 0xf9, 0x69, 0xcf, 0x59, 0x29, 0x4f, 0x7b, 0xb8, 0x0f, 0x9b, 0x22, 0xe5,
	0x61, 0x3c, 0x91, 0x5e, 0x9d, 0xfa, 0x43, 0x1a, 0x09, 0x27, 0x30, 0xb3, 0x30, 0x90, 0x00, 0xf5,
	0x52, 0x0f, 0x91, 0x79, 0x02, 0x3e, 0x82, 0x8d, 0x30, 0x4e, 0xdf, 0x1e, 0x54, 0x45, 0xa8, 0x14,
	0x29, 0x7e, 0x92, 0x1f, 0xb2, 0xfb, 0x42, 0x63, 0x0e, 0x3e, 0x9f, 0xa1, 0xde, 0x1a, 0x34, 0xab,
	0x00, 0xfc, 0xe3, 0xb6, 0x83, 0x6e, 0x6e, 0x3b, 0xe8, 0xe7, 0x6d, 0x07, 0x7d, 0xfb, 0xd5, 0xb1,
	0xbc, 0xfa, 0x85, 0x35, 0xb4, 0xe5, 0xff, 0xd5, 0xfe, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x30,
	0xfe, 0x81, 0x7d, 0xda, 0x06, 0x00, 0x00,
}
