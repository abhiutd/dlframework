// Code generated by protoc-gen-gogo.
// source: ArrayFeatureExtractor.proto
// DO NOT EDIT!

/*
Package CoreML is a generated protocol buffer package.

It is generated from these files:
	ArrayFeatureExtractor.proto
	CategoricalMapping.proto
	DataStructures.proto
	DictVectorizer.proto
	FeatureTypes.proto
	FeatureVectorizer.proto
	GLMClassifier.proto
	GLMRegressor.proto
	Identity.proto
	Imputer.proto
	Model.proto
	NeuralNetwork.proto
	Normalizer.proto
	OneHotEncoder.proto
	Scaler.proto
	SVM.proto
	TreeEnsemble.proto

It has these top-level messages:
	ArrayFeatureExtractor
	CategoricalMapping
	StringToInt64Map
	Int64ToStringMap
	StringToDoubleMap
	Int64ToDoubleMap
	StringVector
	Int64Vector
	DoubleVector
	DictVectorizer
	Int64FeatureType
	DoubleFeatureType
	StringFeatureType
	ImageFeatureType
	ArrayFeatureType
	DictionaryFeatureType
	FeatureType
	FeatureVectorizer
	GLMClassifier
	GLMRegressor
	Identity
	Imputer
	Pipeline
	PipelineClassifier
	PipelineRegressor
	FeatureDescription
	Metadata
	ModelDescription
	Model
	NeuralNetwork
	NeuralNetworkImageScaler
	NeuralNetworkMeanImage
	NeuralNetworkPreprocessing
	ActivationReLU
	ActivationLeakyReLU
	ActivationTanh
	ActivationScaledTanh
	ActivationSigmoid
	ActivationLinear
	ActivationSigmoidHard
	ActivationPReLU
	ActivationELU
	ActivationThresholdedReLU
	ActivationSoftsign
	ActivationSoftplus
	ActivationParametricSoftplus
	ActivationParams
	NeuralNetworkLayer
	BorderAmounts
	ValidPadding
	SamePadding
	WeightParams
	ConvolutionLayerParams
	InnerProductLayerParams
	EmbeddingLayerParams
	BatchnormLayerParams
	PoolingLayerParams
	PaddingLayerParams
	ConcatLayerParams
	LRNLayerParams
	SoftmaxLayerParams
	SplitLayerParams
	AddLayerParams
	MultiplyLayerParams
	UnaryFunctionLayerParams
	UpsampleLayerParams
	BiasLayerParams
	ScaleLayerParams
	LoadConstantLayerParams
	L2NormalizeLayerParams
	FlattenLayerParams
	ReshapeLayerParams
	PermuteLayerParams
	ReduceLayerParams
	CropLayerParams
	AverageLayerParams
	MaxLayerParams
	MinLayerParams
	DotProductLayerParams
	MeanVarianceNormalizeLayerParams
	SequenceRepeatLayerParams
	SimpleRecurrentLayerParams
	GRULayerParams
	LSTMParams
	LSTMWeightParams
	UniDirectionalLSTMLayerParams
	BiDirectionalLSTMLayerParams
	NeuralNetworkClassifier
	NeuralNetworkRegressor
	Normalizer
	OneHotEncoder
	Scaler
	LinearKernel
	RBFKernel
	PolyKernel
	SigmoidKernel
	Kernel
	SparseNode
	SparseVector
	SparseSupportVectors
	DenseVector
	DenseSupportVectors
	Coefficients
	SupportVectorRegressor
	SupportVectorClassifier
	TreeEnsembleParameters
	TreeEnsembleClassifier
	TreeEnsembleRegressor
*/
package CoreML

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// *
// An array feature extractor.
//
// Given an index, extracts the value at that index from its array input.
// Indexes are zero-based.
type ArrayFeatureExtractor struct {
	ExtractIndex []uint64 `protobuf:"varint,1,rep,packed,name=extractIndex" json:"extractIndex,omitempty"`
}

func (m *ArrayFeatureExtractor) Reset()         { *m = ArrayFeatureExtractor{} }
func (m *ArrayFeatureExtractor) String() string { return proto.CompactTextString(m) }
func (*ArrayFeatureExtractor) ProtoMessage()    {}
func (*ArrayFeatureExtractor) Descriptor() ([]byte, []int) {
	return fileDescriptorArrayFeatureExtractor, []int{0}
}

func (m *ArrayFeatureExtractor) GetExtractIndex() []uint64 {
	if m != nil {
		return m.ExtractIndex
	}
	return nil
}

func init() {
	proto.RegisterType((*ArrayFeatureExtractor)(nil), "CoreML.ArrayFeatureExtractor")
}
func (m *ArrayFeatureExtractor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArrayFeatureExtractor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExtractIndex) > 0 {
		dAtA2 := make([]byte, len(m.ExtractIndex)*10)
		var j1 int
		for _, num := range m.ExtractIndex {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintArrayFeatureExtractor(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func encodeFixed64ArrayFeatureExtractor(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32ArrayFeatureExtractor(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintArrayFeatureExtractor(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ArrayFeatureExtractor) Size() (n int) {
	var l int
	_ = l
	if len(m.ExtractIndex) > 0 {
		l = 0
		for _, e := range m.ExtractIndex {
			l += sovArrayFeatureExtractor(uint64(e))
		}
		n += 1 + sovArrayFeatureExtractor(uint64(l)) + l
	}
	return n
}

func sovArrayFeatureExtractor(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozArrayFeatureExtractor(x uint64) (n int) {
	return sovArrayFeatureExtractor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ArrayFeatureExtractor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArrayFeatureExtractor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArrayFeatureExtractor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArrayFeatureExtractor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArrayFeatureExtractor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExtractIndex = append(m.ExtractIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArrayFeatureExtractor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArrayFeatureExtractor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArrayFeatureExtractor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExtractIndex = append(m.ExtractIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtractIndex", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArrayFeatureExtractor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArrayFeatureExtractor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipArrayFeatureExtractor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowArrayFeatureExtractor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArrayFeatureExtractor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArrayFeatureExtractor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthArrayFeatureExtractor
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowArrayFeatureExtractor
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipArrayFeatureExtractor(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthArrayFeatureExtractor = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowArrayFeatureExtractor   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ArrayFeatureExtractor.proto", fileDescriptorArrayFeatureExtractor) }

var fileDescriptorArrayFeatureExtractor = []byte{
	// 114 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0x76, 0x2c, 0x2a, 0x4a,
	0xac, 0x74, 0x4b, 0x4d, 0x2c, 0x29, 0x2d, 0x4a, 0x75, 0xad, 0x28, 0x29, 0x4a, 0x4c, 0x2e, 0xc9,
	0x2f, 0xd2, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x73, 0xce, 0x2f, 0x4a, 0xf5, 0xf5, 0x51,
	0xb2, 0xe6, 0x12, 0xc5, 0xaa, 0x4c, 0x48, 0x89, 0x8b, 0x27, 0x15, 0xc2, 0xf1, 0xcc, 0x4b, 0x49,
	0xad, 0x90, 0x60, 0x54, 0x60, 0xd6, 0x60, 0x09, 0x42, 0x11, 0x73, 0x12, 0x3a, 0xf1, 0x48, 0x8e,
	0xf1, 0xc2, 0x23, 0x39, 0xc6, 0x07, 0x8f, 0xe4, 0x18, 0x27, 0x3c, 0x96, 0x63, 0xf0, 0x60, 0x4e,
	0x62, 0x03, 0x9b, 0x6f, 0x0c, 0x08, 0x00, 0x00, 0xff, 0xff, 0x46, 0xad, 0xa3, 0xf0, 0x7e, 0x00,
	0x00, 0x00,
}
