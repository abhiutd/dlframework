// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 07 Jun 2017 16:53:37 BST.
// By https://git.io/c-for-go. DO NOT EDIT.

package gomxnet

/*
#cgo LDFLAGS: -lmxnet
#cgo CFLAGS: -I..
#include "c_api.h"
#include "c_predict_api.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

func (x MXGenericCallback) PassRef() (ref *C.MXGenericCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if mXGenericCallback2BC28855Func == nil {
		mXGenericCallback2BC28855Func = x
	}
	return (*C.MXGenericCallback)(C.MXGenericCallback_2bc28855), nil
}

func (x MXGenericCallback) PassValue() (ref C.MXGenericCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if mXGenericCallback2BC28855Func == nil {
		mXGenericCallback2BC28855Func = x
	}
	return (C.MXGenericCallback)(C.MXGenericCallback_2bc28855), nil
}

func NewMXGenericCallbackRef(ref unsafe.Pointer) *MXGenericCallback {
	return (*MXGenericCallback)(ref)
}

//export mXGenericCallback2BC28855
func mXGenericCallback2BC28855() C.int {
	if mXGenericCallback2BC28855Func != nil {
		ret2bc28855 := mXGenericCallback2BC28855Func()
		ret, _ := (C.int)(ret2bc28855), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var mXGenericCallback2BC28855Func MXGenericCallback

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

func (x CustomOpFBFunc) PassRef() (ref *C.CustomOpFBFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpFBFuncFF3016A2Func == nil {
		customOpFBFuncFF3016A2Func = x
	}
	return (*C.CustomOpFBFunc)(C.CustomOpFBFunc_ff3016a2), nil
}

func (x CustomOpFBFunc) PassValue() (ref C.CustomOpFBFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpFBFuncFF3016A2Func == nil {
		customOpFBFuncFF3016A2Func = x
	}
	return (C.CustomOpFBFunc)(C.CustomOpFBFunc_ff3016a2), nil
}

func NewCustomOpFBFuncRef(ref unsafe.Pointer) *CustomOpFBFunc {
	return (*CustomOpFBFunc)(ref)
}

//export customOpFBFuncFF3016A2
func customOpFBFuncFF3016A2(carg0 C.int, carg1 *unsafe.Pointer, carg2 *C.int, carg3 *C.int, carg4 C.int, carg5 unsafe.Pointer) C.int {
	if customOpFBFuncFF3016A2Func != nil {
		arg0ff3016a2 := (int32)(carg0)
		var arg1ff3016a2 []unsafe.Pointer
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&arg1ff3016a2))
		hxfc4425b.Data = uintptr(unsafe.Pointer(carg1))
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?

		var arg2ff3016a2 []int32
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&arg2ff3016a2))
		hxf95e7c8.Data = uintptr(unsafe.Pointer(carg2))
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?

		var arg3ff3016a2 []int32
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&arg3ff3016a2))
		hxff2234b.Data = uintptr(unsafe.Pointer(carg3))
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?

		arg4ff3016a2 := (int32)(carg4)
		arg5ff3016a2 := (unsafe.Pointer)(unsafe.Pointer(carg5))
		retff3016a2 := customOpFBFuncFF3016A2Func(arg0ff3016a2, arg1ff3016a2, arg2ff3016a2, arg3ff3016a2, arg4ff3016a2, arg5ff3016a2)
		ret, _ := (C.int)(retff3016a2), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var customOpFBFuncFF3016A2Func CustomOpFBFunc

func (x CustomOpDelFunc) PassRef() (ref *C.CustomOpDelFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpDelFunc7F9A5B2CFunc == nil {
		customOpDelFunc7F9A5B2CFunc = x
	}
	return (*C.CustomOpDelFunc)(C.CustomOpDelFunc_7f9a5b2c), nil
}

func (x CustomOpDelFunc) PassValue() (ref C.CustomOpDelFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpDelFunc7F9A5B2CFunc == nil {
		customOpDelFunc7F9A5B2CFunc = x
	}
	return (C.CustomOpDelFunc)(C.CustomOpDelFunc_7f9a5b2c), nil
}

func NewCustomOpDelFuncRef(ref unsafe.Pointer) *CustomOpDelFunc {
	return (*CustomOpDelFunc)(ref)
}

//export customOpDelFunc7F9A5B2C
func customOpDelFunc7F9A5B2C(carg0 unsafe.Pointer) C.int {
	if customOpDelFunc7F9A5B2CFunc != nil {
		arg07f9a5b2c := (unsafe.Pointer)(unsafe.Pointer(carg0))
		ret7f9a5b2c := customOpDelFunc7F9A5B2CFunc(arg07f9a5b2c)
		ret, _ := (C.int)(ret7f9a5b2c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var customOpDelFunc7F9A5B2CFunc CustomOpDelFunc

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// packSSSByte reads sliced Go data structure out from plain C format.
func packSSSByte(v [][][]byte, ptr0 ***C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]**C.char)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr1)))[i1]
			hxff73280 := (*sliceHeader)(unsafe.Pointer(&v[i0][i1]))
			hxff73280.Data = uintptr(unsafe.Pointer(ptr2))
			hxff73280.Cap = 0x7fffffff
			// hxff73280.Len = ?
		}
	}
}

func (x CustomOpListFunc) PassRef() (ref *C.CustomOpListFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpListFunc4E79662DFunc == nil {
		customOpListFunc4E79662DFunc = x
	}
	return (*C.CustomOpListFunc)(C.CustomOpListFunc_4e79662d), nil
}

func (x CustomOpListFunc) PassValue() (ref C.CustomOpListFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpListFunc4E79662DFunc == nil {
		customOpListFunc4E79662DFunc = x
	}
	return (C.CustomOpListFunc)(C.CustomOpListFunc_4e79662d), nil
}

func NewCustomOpListFuncRef(ref unsafe.Pointer) *CustomOpListFunc {
	return (*CustomOpListFunc)(ref)
}

//export customOpListFunc4E79662D
func customOpListFunc4E79662D(carg0 ***C.char, carg1 unsafe.Pointer) C.int {
	if customOpListFunc4E79662DFunc != nil {
		var arg04e79662d [][][]byte
		packSSSByte(arg04e79662d, carg0)
		arg14e79662d := (unsafe.Pointer)(unsafe.Pointer(carg1))
		ret4e79662d := customOpListFunc4E79662DFunc(arg04e79662d, arg14e79662d)
		ret, _ := (C.int)(ret4e79662d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var customOpListFunc4E79662DFunc CustomOpListFunc

// packSSUUint32 reads sliced Go data structure out from plain C format.
func packSSUUint32(v [][]uint32, ptr0 **C.uint) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uint)(unsafe.Pointer(ptr0)))[i0]
		hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfa3f05c.Data = uintptr(unsafe.Pointer(ptr1))
		hxfa3f05c.Cap = 0x7fffffff
		// hxfa3f05c.Len = ?
	}
}

func (x CustomOpInferShapeFunc) PassRef() (ref *C.CustomOpInferShapeFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpInferShapeFunc2AD17C00Func == nil {
		customOpInferShapeFunc2AD17C00Func = x
	}
	return (*C.CustomOpInferShapeFunc)(C.CustomOpInferShapeFunc_2ad17c00), nil
}

func (x CustomOpInferShapeFunc) PassValue() (ref C.CustomOpInferShapeFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpInferShapeFunc2AD17C00Func == nil {
		customOpInferShapeFunc2AD17C00Func = x
	}
	return (C.CustomOpInferShapeFunc)(C.CustomOpInferShapeFunc_2ad17c00), nil
}

func NewCustomOpInferShapeFuncRef(ref unsafe.Pointer) *CustomOpInferShapeFunc {
	return (*CustomOpInferShapeFunc)(ref)
}

//export customOpInferShapeFunc2AD17C00
func customOpInferShapeFunc2AD17C00(carg0 C.int, carg1 *C.int, carg2 **C.uint, carg3 unsafe.Pointer) C.int {
	if customOpInferShapeFunc2AD17C00Func != nil {
		arg02ad17c00 := (int32)(carg0)
		var arg12ad17c00 []int32
		hxfa9955c := (*sliceHeader)(unsafe.Pointer(&arg12ad17c00))
		hxfa9955c.Data = uintptr(unsafe.Pointer(carg1))
		hxfa9955c.Cap = 0x7fffffff
		// hxfa9955c.Len = ?

		var arg22ad17c00 [][]uint32
		packSSUUint32(arg22ad17c00, carg2)
		arg32ad17c00 := (unsafe.Pointer)(unsafe.Pointer(carg3))
		ret2ad17c00 := customOpInferShapeFunc2AD17C00Func(arg02ad17c00, arg12ad17c00, arg22ad17c00, arg32ad17c00)
		ret, _ := (C.int)(ret2ad17c00), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var customOpInferShapeFunc2AD17C00Func CustomOpInferShapeFunc

func (x CustomOpInferTypeFunc) PassRef() (ref *C.CustomOpInferTypeFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpInferTypeFunc59F65F2FFunc == nil {
		customOpInferTypeFunc59F65F2FFunc = x
	}
	return (*C.CustomOpInferTypeFunc)(C.CustomOpInferTypeFunc_59f65f2f), nil
}

func (x CustomOpInferTypeFunc) PassValue() (ref C.CustomOpInferTypeFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpInferTypeFunc59F65F2FFunc == nil {
		customOpInferTypeFunc59F65F2FFunc = x
	}
	return (C.CustomOpInferTypeFunc)(C.CustomOpInferTypeFunc_59f65f2f), nil
}

func NewCustomOpInferTypeFuncRef(ref unsafe.Pointer) *CustomOpInferTypeFunc {
	return (*CustomOpInferTypeFunc)(ref)
}

//export customOpInferTypeFunc59F65F2F
func customOpInferTypeFunc59F65F2F(carg0 C.int, carg1 *C.int, carg2 unsafe.Pointer) C.int {
	if customOpInferTypeFunc59F65F2FFunc != nil {
		arg059f65f2f := (int32)(carg0)
		var arg159f65f2f []int32
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&arg159f65f2f))
		hxf0d18b7.Data = uintptr(unsafe.Pointer(carg1))
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?

		arg259f65f2f := (unsafe.Pointer)(unsafe.Pointer(carg2))
		ret59f65f2f := customOpInferTypeFunc59F65F2FFunc(arg059f65f2f, arg159f65f2f, arg259f65f2f)
		ret, _ := (C.int)(ret59f65f2f), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var customOpInferTypeFunc59F65F2FFunc CustomOpInferTypeFunc

// packSSInt32 reads sliced Go data structure out from plain C format.
func packSSInt32(v [][]int32, ptr0 **C.int) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.int)(unsafe.Pointer(ptr0)))[i0]
		hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf7a6dff.Data = uintptr(unsafe.Pointer(ptr1))
		hxf7a6dff.Cap = 0x7fffffff
		// hxf7a6dff.Len = ?
	}
}

func (x CustomOpBwdDepFunc) PassRef() (ref *C.CustomOpBwdDepFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpBwdDepFunc7AC42004Func == nil {
		customOpBwdDepFunc7AC42004Func = x
	}
	return (*C.CustomOpBwdDepFunc)(C.CustomOpBwdDepFunc_7ac42004), nil
}

func (x CustomOpBwdDepFunc) PassValue() (ref C.CustomOpBwdDepFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpBwdDepFunc7AC42004Func == nil {
		customOpBwdDepFunc7AC42004Func = x
	}
	return (C.CustomOpBwdDepFunc)(C.CustomOpBwdDepFunc_7ac42004), nil
}

func NewCustomOpBwdDepFuncRef(ref unsafe.Pointer) *CustomOpBwdDepFunc {
	return (*CustomOpBwdDepFunc)(ref)
}

//export customOpBwdDepFunc7AC42004
func customOpBwdDepFunc7AC42004(carg0 *C.int, carg1 *C.int, carg2 *C.int, carg3 *C.int, carg4 **C.int, carg5 unsafe.Pointer) C.int {
	if customOpBwdDepFunc7AC42004Func != nil {
		var arg07ac42004 []int32
		hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&arg07ac42004))
		hxf2fab0d.Data = uintptr(unsafe.Pointer(carg0))
		hxf2fab0d.Cap = 0x7fffffff
		// hxf2fab0d.Len = ?

		var arg17ac42004 []int32
		hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&arg17ac42004))
		hxf69fe70.Data = uintptr(unsafe.Pointer(carg1))
		hxf69fe70.Cap = 0x7fffffff
		// hxf69fe70.Len = ?

		var arg27ac42004 []int32
		hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&arg27ac42004))
		hxf65bf54.Data = uintptr(unsafe.Pointer(carg2))
		hxf65bf54.Cap = 0x7fffffff
		// hxf65bf54.Len = ?

		var arg37ac42004 []int32
		hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&arg37ac42004))
		hxf3b8dbd.Data = uintptr(unsafe.Pointer(carg3))
		hxf3b8dbd.Cap = 0x7fffffff
		// hxf3b8dbd.Len = ?

		var arg47ac42004 [][]int32
		packSSInt32(arg47ac42004, carg4)
		arg57ac42004 := (unsafe.Pointer)(unsafe.Pointer(carg5))
		ret7ac42004 := customOpBwdDepFunc7AC42004Func(arg07ac42004, arg17ac42004, arg27ac42004, arg37ac42004, arg47ac42004, arg57ac42004)
		ret, _ := (C.int)(ret7ac42004), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var customOpBwdDepFunc7AC42004Func CustomOpBwdDepFunc

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

// packSMXCallbackList reads sliced Go data structure out from plain C format.
func packSMXCallbackList(v []MXCallbackList, ptr0 *C.struct_MXCallbackList) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructMXCallbackListValue]C.struct_MXCallbackList)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMXCallbackListRef(unsafe.Pointer(&ptr1))
	}
}

func (x CustomOpCreateFunc) PassRef() (ref *C.CustomOpCreateFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpCreateFuncEE34D11CFunc == nil {
		customOpCreateFuncEE34D11CFunc = x
	}
	return (*C.CustomOpCreateFunc)(C.CustomOpCreateFunc_ee34d11c), nil
}

func (x CustomOpCreateFunc) PassValue() (ref C.CustomOpCreateFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpCreateFuncEE34D11CFunc == nil {
		customOpCreateFuncEE34D11CFunc = x
	}
	return (C.CustomOpCreateFunc)(C.CustomOpCreateFunc_ee34d11c), nil
}

func NewCustomOpCreateFuncRef(ref unsafe.Pointer) *CustomOpCreateFunc {
	return (*CustomOpCreateFunc)(ref)
}

//export customOpCreateFuncEE34D11C
func customOpCreateFuncEE34D11C(carg0 *C.char, carg1 C.int, carg2 **C.uint, carg3 *C.int, carg4 *C.int, carg5 *C.struct_MXCallbackList, carg6 unsafe.Pointer) C.int {
	if customOpCreateFuncEE34D11CFunc != nil {
		arg0ee34d11c := packPCharString(carg0)
		arg1ee34d11c := (int32)(carg1)
		var arg2ee34d11c [][]uint32
		packSSUUint32(arg2ee34d11c, carg2)
		var arg3ee34d11c []int32
		hxf4171bf := (*sliceHeader)(unsafe.Pointer(&arg3ee34d11c))
		hxf4171bf.Data = uintptr(unsafe.Pointer(carg3))
		hxf4171bf.Cap = 0x7fffffff
		// hxf4171bf.Len = ?

		var arg4ee34d11c []int32
		hxf058b18 := (*sliceHeader)(unsafe.Pointer(&arg4ee34d11c))
		hxf058b18.Data = uintptr(unsafe.Pointer(carg4))
		hxf058b18.Cap = 0x7fffffff
		// hxf058b18.Len = ?

		var arg5ee34d11c []MXCallbackList
		packSMXCallbackList(arg5ee34d11c, carg5)
		arg6ee34d11c := (unsafe.Pointer)(unsafe.Pointer(carg6))
		retee34d11c := customOpCreateFuncEE34D11CFunc(arg0ee34d11c, arg1ee34d11c, arg2ee34d11c, arg3ee34d11c, arg4ee34d11c, arg5ee34d11c, arg6ee34d11c)
		ret, _ := (C.int)(retee34d11c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var customOpCreateFuncEE34D11CFunc CustomOpCreateFunc

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

func (x CustomOpPropCreator) PassRef() (ref *C.CustomOpPropCreator, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpPropCreatorFDC4DBABFunc == nil {
		customOpPropCreatorFDC4DBABFunc = x
	}
	return (*C.CustomOpPropCreator)(C.CustomOpPropCreator_fdc4dbab), nil
}

func (x CustomOpPropCreator) PassValue() (ref C.CustomOpPropCreator, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if customOpPropCreatorFDC4DBABFunc == nil {
		customOpPropCreatorFDC4DBABFunc = x
	}
	return (C.CustomOpPropCreator)(C.CustomOpPropCreator_fdc4dbab), nil
}

func NewCustomOpPropCreatorRef(ref unsafe.Pointer) *CustomOpPropCreator {
	return (*CustomOpPropCreator)(ref)
}

//export customOpPropCreatorFDC4DBAB
func customOpPropCreatorFDC4DBAB(carg0 *C.char, carg1 C.int, carg2 **C.char, carg3 **C.char, carg4 *C.struct_MXCallbackList) C.int {
	if customOpPropCreatorFDC4DBABFunc != nil {
		arg0fdc4dbab := packPCharString(carg0)
		arg1fdc4dbab := (int32)(carg1)
		var arg2fdc4dbab []string
		packSString(arg2fdc4dbab, carg2)
		var arg3fdc4dbab []string
		packSString(arg3fdc4dbab, carg3)
		var arg4fdc4dbab []MXCallbackList
		packSMXCallbackList(arg4fdc4dbab, carg4)
		retfdc4dbab := customOpPropCreatorFDC4DBABFunc(arg0fdc4dbab, arg1fdc4dbab, arg2fdc4dbab, arg3fdc4dbab, arg4fdc4dbab)
		ret, _ := (C.int)(retfdc4dbab), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var customOpPropCreatorFDC4DBABFunc CustomOpPropCreator

func (x MXKVStoreUpdater) PassRef() (ref *C.MXKVStoreUpdater, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if mXKVStoreUpdater2E43854BFunc == nil {
		mXKVStoreUpdater2E43854BFunc = x
	}
	return (*C.MXKVStoreUpdater)(C.MXKVStoreUpdater_2e43854b), nil
}

func NewMXKVStoreUpdaterRef(ref unsafe.Pointer) *MXKVStoreUpdater {
	return (*MXKVStoreUpdater)(ref)
}

//export mXKVStoreUpdater2E43854B
func mXKVStoreUpdater2E43854B(ckey C.int, crecv C.NDArrayHandle, clocal C.NDArrayHandle, chandle unsafe.Pointer) {
	if mXKVStoreUpdater2E43854BFunc != nil {
		key2e43854b := (int32)(ckey)
		recv2e43854b := (NDArrayHandle)(crecv)
		local2e43854b := (NDArrayHandle)(clocal)
		handle2e43854b := (unsafe.Pointer)(unsafe.Pointer(chandle))
		mXKVStoreUpdater2E43854BFunc(key2e43854b, recv2e43854b, local2e43854b, handle2e43854b)
		return
	}
	panic("callback func has not been set (race?)")
}

var mXKVStoreUpdater2E43854BFunc MXKVStoreUpdater

func (x MXKVStoreServerController) PassRef() (ref *C.MXKVStoreServerController, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if mXKVStoreServerController98C9BE52Func == nil {
		mXKVStoreServerController98C9BE52Func = x
	}
	return (*C.MXKVStoreServerController)(C.MXKVStoreServerController_98c9be52), nil
}

func NewMXKVStoreServerControllerRef(ref unsafe.Pointer) *MXKVStoreServerController {
	return (*MXKVStoreServerController)(ref)
}

//export mXKVStoreServerController98C9BE52
func mXKVStoreServerController98C9BE52(chead C.int, cbody *C.char, ccontrollerHandle unsafe.Pointer) {
	if mXKVStoreServerController98C9BE52Func != nil {
		head98c9be52 := (int32)(chead)
		body98c9be52 := packPCharString(cbody)
		controllerHandle98c9be52 := (unsafe.Pointer)(unsafe.Pointer(ccontrollerHandle))
		mXKVStoreServerController98C9BE52Func(head98c9be52, body98c9be52, controllerHandle98c9be52)
		return
	}
	panic("callback func has not been set (race?)")
}

var mXKVStoreServerController98C9BE52Func MXKVStoreServerController

// Ref returns a reference to C object as it is.
func (x *MXCallbackList) Ref() *C.struct_MXCallbackList {
	if x == nil {
		return nil
	}
	return (*C.struct_MXCallbackList)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MXCallbackList) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMXCallbackListRef converts the C object reference into a raw struct reference without wrapping.
func NewMXCallbackListRef(ref unsafe.Pointer) *MXCallbackList {
	return (*MXCallbackList)(ref)
}

// NewMXCallbackList allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMXCallbackList() *MXCallbackList {
	return (*MXCallbackList)(allocStructMXCallbackListMemory(1))
}

// allocStructMXCallbackListMemory allocates memory for type C.struct_MXCallbackList in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructMXCallbackListMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructMXCallbackListValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructMXCallbackListValue = unsafe.Sizeof([1]C.struct_MXCallbackList{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MXCallbackList) PassRef() *C.struct_MXCallbackList {
	if x == nil {
		x = (*MXCallbackList)(allocStructMXCallbackListMemory(1))
	}
	return (*C.struct_MXCallbackList)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *NDArrayOpInfo) Ref() *C.struct_NDArrayOpInfo {
	if x == nil {
		return nil
	}
	return (*C.struct_NDArrayOpInfo)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *NDArrayOpInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewNDArrayOpInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewNDArrayOpInfoRef(ref unsafe.Pointer) *NDArrayOpInfo {
	return (*NDArrayOpInfo)(ref)
}

// NewNDArrayOpInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewNDArrayOpInfo() *NDArrayOpInfo {
	return (*NDArrayOpInfo)(allocStructNDArrayOpInfoMemory(1))
}

// allocStructNDArrayOpInfoMemory allocates memory for type C.struct_NDArrayOpInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNDArrayOpInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNDArrayOpInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNDArrayOpInfoValue = unsafe.Sizeof([1]C.struct_NDArrayOpInfo{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *NDArrayOpInfo) PassRef() *C.struct_NDArrayOpInfo {
	if x == nil {
		x = (*NDArrayOpInfo)(allocStructNDArrayOpInfoMemory(1))
	}
	return (*C.struct_NDArrayOpInfo)(unsafe.Pointer(x))
}

// allocStructNativeOpInfoMemory allocates memory for type C.struct_NativeOpInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNativeOpInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNativeOpInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNativeOpInfoValue = unsafe.Sizeof([1]C.struct_NativeOpInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *NativeOpInfo) Ref() *C.struct_NativeOpInfo {
	if x == nil {
		return nil
	}
	return x.ref7ce11869
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *NativeOpInfo) Free() {
	if x != nil && x.allocs7ce11869 != nil {
		x.allocs7ce11869.(*cgoAllocMap).Free()
		x.ref7ce11869 = nil
	}
}

// NewNativeOpInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewNativeOpInfoRef(ref unsafe.Pointer) *NativeOpInfo {
	if ref == nil {
		return nil
	}
	obj := new(NativeOpInfo)
	obj.ref7ce11869 = (*C.struct_NativeOpInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *NativeOpInfo) PassRef() (*C.struct_NativeOpInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ce11869 != nil {
		return x.ref7ce11869, nil
	}
	mem7ce11869 := allocStructNativeOpInfoMemory(1)
	ref7ce11869 := (*C.struct_NativeOpInfo)(mem7ce11869)
	allocs7ce11869 := new(cgoAllocMap)
	var cforward_allocs *cgoAllocMap
	ref7ce11869.forward, cforward_allocs = x.Forward.PassRef()
	allocs7ce11869.Borrow(cforward_allocs)

	var cbackward_allocs *cgoAllocMap
	ref7ce11869.backward, cbackward_allocs = x.Backward.PassRef()
	allocs7ce11869.Borrow(cbackward_allocs)

	var cinfer_shape_allocs *cgoAllocMap
	ref7ce11869.infer_shape, cinfer_shape_allocs = x.InferShape.PassRef()
	allocs7ce11869.Borrow(cinfer_shape_allocs)

	var clist_outputs_allocs *cgoAllocMap
	ref7ce11869.list_outputs, clist_outputs_allocs = x.ListOutputs.PassRef()
	allocs7ce11869.Borrow(clist_outputs_allocs)

	var clist_arguments_allocs *cgoAllocMap
	ref7ce11869.list_arguments, clist_arguments_allocs = x.ListArguments.PassRef()
	allocs7ce11869.Borrow(clist_arguments_allocs)

	var cp_forward_allocs *cgoAllocMap
	ref7ce11869.p_forward, cp_forward_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PForward)), cgoAllocsUnknown
	allocs7ce11869.Borrow(cp_forward_allocs)

	var cp_backward_allocs *cgoAllocMap
	ref7ce11869.p_backward, cp_backward_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PBackward)), cgoAllocsUnknown
	allocs7ce11869.Borrow(cp_backward_allocs)

	var cp_infer_shape_allocs *cgoAllocMap
	ref7ce11869.p_infer_shape, cp_infer_shape_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PInferShape)), cgoAllocsUnknown
	allocs7ce11869.Borrow(cp_infer_shape_allocs)

	var cp_list_outputs_allocs *cgoAllocMap
	ref7ce11869.p_list_outputs, cp_list_outputs_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PListOutputs)), cgoAllocsUnknown
	allocs7ce11869.Borrow(cp_list_outputs_allocs)

	var cp_list_arguments_allocs *cgoAllocMap
	ref7ce11869.p_list_arguments, cp_list_arguments_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PListArguments)), cgoAllocsUnknown
	allocs7ce11869.Borrow(cp_list_arguments_allocs)

	x.ref7ce11869 = ref7ce11869
	x.allocs7ce11869 = allocs7ce11869
	return ref7ce11869, allocs7ce11869

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x NativeOpInfo) PassValue() (C.struct_NativeOpInfo, *cgoAllocMap) {
	if x.ref7ce11869 != nil {
		return *x.ref7ce11869, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *NativeOpInfo) Deref() {
	if x.ref7ce11869 == nil {
		return
	}
	x.Forward = NewRef(unsafe.Pointer(x.ref7ce11869.forward))
	x.Backward = NewRef(unsafe.Pointer(x.ref7ce11869.backward))
	x.InferShape = NewRef(unsafe.Pointer(x.ref7ce11869.infer_shape))
	x.ListOutputs = NewRef(unsafe.Pointer(x.ref7ce11869.list_outputs))
	x.ListArguments = NewRef(unsafe.Pointer(x.ref7ce11869.list_arguments))
	x.PForward = (unsafe.Pointer)(unsafe.Pointer(x.ref7ce11869.p_forward))
	x.PBackward = (unsafe.Pointer)(unsafe.Pointer(x.ref7ce11869.p_backward))
	x.PInferShape = (unsafe.Pointer)(unsafe.Pointer(x.ref7ce11869.p_infer_shape))
	x.PListOutputs = (unsafe.Pointer)(unsafe.Pointer(x.ref7ce11869.p_list_outputs))
	x.PListArguments = (unsafe.Pointer)(unsafe.Pointer(x.ref7ce11869.p_list_arguments))
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// allocPNDArrayHandleMemory allocates memory for type *C.NDArrayHandle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPNDArrayHandleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPNDArrayHandleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPNDArrayHandleValue = unsafe.Sizeof([1]*C.NDArrayHandle{})

// unpackArgSSNDArrayHandle transforms a sliced Go data structure into plain C format.
func unpackArgSSNDArrayHandle(x [][]NDArrayHandle) (unpacked **C.NDArrayHandle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.NDArrayHandle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPNDArrayHandleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.NDArrayHandle)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.NDArrayHandle)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.NDArrayHandle)(unsafe.Pointer(h.Data))
	return
}

// packSSNDArrayHandle reads sliced Go data structure out from plain C format.
func packSSNDArrayHandle(v [][]NDArrayHandle, ptr0 **C.NDArrayHandle) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.NDArrayHandle)(unsafe.Pointer(ptr0)))[i0]
		hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxff6bc57.Data = uintptr(unsafe.Pointer(ptr1))
		hxff6bc57.Cap = 0x7fffffff
		// hxff6bc57.Len = ?
	}
}

// allocPPCharMemory allocates memory for type **C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPPCharValue = unsafe.Sizeof([1]**C.char{})

// unpackArgSSString transforms a sliced Go data structure into plain C format.
func unpackArgSSString(x [][]string) (unpacked ***C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(****C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]**C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocPCharMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: uintptr(mem1),
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]*C.char)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			v1[i1], _ = unpackPCharString(x[i0][i1])
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (**C.char)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (***C.char)(unsafe.Pointer(h.Data))
	return
}

// packSSString reads sliced Go data structure out from plain C format.
func packSSString(v [][]string, ptr0 ***C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]**C.char)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = packPCharString(ptr2)
		}
	}
}

// allocPMxUintMemory allocates memory for type *C.mx_uint in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPMxUintMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPMxUintValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPMxUintValue = unsafe.Sizeof([1]*C.mx_uint{})

// unpackArgSSUUint32 transforms a sliced Go data structure into plain C format.
func unpackArgSSUUint32(x [][]uint32) (unpacked **C.mx_uint, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.mx_uint) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPMxUintMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.mx_uint)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.mx_uint)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.mx_uint)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSSByte transforms a sliced Go data structure into plain C format.
func unpackArgSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.char)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxf21690b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf21690b.Data = uintptr(unsafe.Pointer(ptr1))
		hxf21690b.Cap = 0x7fffffff
		// hxf21690b.Len = ?
	}
}

// allocPPMxUintMemory allocates memory for type **C.mx_uint in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPPMxUintMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPPMxUintValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPPMxUintValue = unsafe.Sizeof([1]**C.mx_uint{})

// unpackArgSSSUUint32 transforms a sliced Go data structure into plain C format.
func unpackArgSSSUUint32(x [][][]uint32) (unpacked ***C.mx_uint, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(****C.mx_uint) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPPMxUintMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]**C.mx_uint)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocPMxUintMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: uintptr(mem1),
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]*C.mx_uint)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			h := (*sliceHeader)(unsafe.Pointer(&x[i0][i1]))
			v1[i1] = (*C.mx_uint)(unsafe.Pointer(h.Data))
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (**C.mx_uint)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (***C.mx_uint)(unsafe.Pointer(h.Data))
	return
}

// packSSSUUint32 reads sliced Go data structure out from plain C format.
func packSSSUUint32(v [][][]uint32, ptr0 ***C.mx_uint) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]**C.mx_uint)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfPtr]*C.mx_uint)(unsafe.Pointer(ptr1)))[i1]
			hxfe53d34 := (*sliceHeader)(unsafe.Pointer(&v[i0][i1]))
			hxfe53d34.Data = uintptr(unsafe.Pointer(ptr2))
			hxfe53d34.Cap = 0x7fffffff
			// hxfe53d34.Len = ?
		}
	}
}

// allocPIntMemory allocates memory for type *C.int in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPIntValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPIntValue = unsafe.Sizeof([1]*C.int{})

// unpackArgSSInt32 transforms a sliced Go data structure into plain C format.
func unpackArgSSInt32(x [][]int32) (unpacked **C.int, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.int) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPIntMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.int)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.int)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.int)(unsafe.Pointer(h.Data))
	return
}

// allocPUint64TMemory allocates memory for type *C.uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUint64TValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPUint64TValue = unsafe.Sizeof([1]*C.uint64_t{})

// unpackArgSSUUint64 transforms a sliced Go data structure into plain C format.
func unpackArgSSUUint64(x [][]uint64) (unpacked **C.uint64_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.uint64_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPUint64TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uint64_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uint64_t)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uint64_t)(unsafe.Pointer(h.Data))
	return
}

// packSSUUint64 reads sliced Go data structure out from plain C format.
func packSSUUint64(v [][]uint64, ptr0 **C.uint64_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uint64_t)(unsafe.Pointer(ptr0)))[i0]
		hxf8e0dd2 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf8e0dd2.Data = uintptr(unsafe.Pointer(ptr1))
		hxf8e0dd2.Cap = 0x7fffffff
		// hxf8e0dd2.Len = ?
	}
}

// allocPMxFloatMemory allocates memory for type *C.mx_float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPMxFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPMxFloatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPMxFloatValue = unsafe.Sizeof([1]*C.mx_float{})

// unpackArgSSFloat32 transforms a sliced Go data structure into plain C format.
func unpackArgSSFloat32(x [][]float32) (unpacked **C.mx_float, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.mx_float) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPMxFloatMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.mx_float)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.mx_float)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.mx_float)(unsafe.Pointer(h.Data))
	return
}

// packSSFloat32 reads sliced Go data structure out from plain C format.
func packSSFloat32(v [][]float32, ptr0 **C.mx_float) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.mx_float)(unsafe.Pointer(ptr0)))[i0]
		hxfeb55cf := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfeb55cf.Data = uintptr(unsafe.Pointer(ptr1))
		hxfeb55cf.Cap = 0x7fffffff
		// hxfeb55cf.Len = ?
	}
}
