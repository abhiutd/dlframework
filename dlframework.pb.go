// Code generated by protoc-gen-gogo.
// source: dlframework.proto
// DO NOT EDIT!

/*
	Package dlframework is a generated protocol buffer package.

	It is generated from these files:
		dlframework.proto

	It has these top-level messages:
		ErrorStatus
		ContainerArchicture
		ModelInformation
		GetModelInformationsResponse
		GetModelInformationRequest
		Null
*/
package dlframework

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ErrorStatus struct {
	Ok      bool   `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty" yaml:"ok,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty" yaml:"message,omitempty"`
}

func (m *ErrorStatus) Reset()                    { *m = ErrorStatus{} }
func (*ErrorStatus) ProtoMessage()               {}
func (*ErrorStatus) Descriptor() ([]byte, []int) { return fileDescriptorDlframework, []int{0} }

func (m *ErrorStatus) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *ErrorStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ContainerArchicture struct {
	Gpu string `protobuf:"bytes,1,opt,name=gpu,proto3" json:"gpu,omitempty" yaml:"gpu,omitempty"`
	Cpu string `protobuf:"bytes,2,opt,name=cpu,proto3" json:"cpu,omitempty" yaml:"cpu,omitempty"`
}

func (m *ContainerArchicture) Reset()                    { *m = ContainerArchicture{} }
func (*ContainerArchicture) ProtoMessage()               {}
func (*ContainerArchicture) Descriptor() ([]byte, []int) { return fileDescriptorDlframework, []int{1} }

func (m *ContainerArchicture) GetGpu() string {
	if m != nil {
		return m.Gpu
	}
	return ""
}

func (m *ContainerArchicture) GetCpu() string {
	if m != nil {
		return m.Cpu
	}
	return ""
}

type ModelInformation struct {
	Name        string                          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" yaml:"name,omitempty"`
	Description string                          `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description,omitempty"`
	Container   map[string]*ContainerArchicture `protobuf:"bytes,3,rep,name=container" json:"container,omitempty" yaml:"container,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Framework   string                          `protobuf:"bytes,4,opt,name=framework,proto3" json:"framework,omitempty" yaml:"framework,omitempty"`
	Version     string                          `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty" yaml:"version,omitempty"`
	Type        string                          `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty" yaml:"type,omitempty"`
	DatasetName string                          `protobuf:"bytes,7,opt,name=dataset_name,json=datasetName,proto3" json:"dataset_name,omitempty" yaml:"dataset_name,omitempty"`
	Input       *ModelInformation_Input         `protobuf:"bytes,8,opt,name=input" json:"input,omitempty" yaml:"input,omitempty"`
	Output      *ModelInformation_Output        `protobuf:"bytes,9,opt,name=output" json:"output,omitempty" yaml:"output,omitempty"`
	References  []string                        `protobuf:"bytes,10,rep,name=references" json:"references,omitempty" yaml:"references,omitempty"`
}

func (m *ModelInformation) Reset()                    { *m = ModelInformation{} }
func (*ModelInformation) ProtoMessage()               {}
func (*ModelInformation) Descriptor() ([]byte, []int) { return fileDescriptorDlframework, []int{2} }

func (m *ModelInformation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelInformation) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ModelInformation) GetContainer() map[string]*ContainerArchicture {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *ModelInformation) GetFramework() string {
	if m != nil {
		return m.Framework
	}
	return ""
}

func (m *ModelInformation) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ModelInformation) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ModelInformation) GetDatasetName() string {
	if m != nil {
		return m.DatasetName
	}
	return ""
}

func (m *ModelInformation) GetInput() *ModelInformation_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *ModelInformation) GetOutput() *ModelInformation_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *ModelInformation) GetReferences() []string {
	if m != nil {
		return m.References
	}
	return nil
}

type ModelInformation_Input struct {
	Type       string    `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty" yaml:"type,omitempty"`
	Dimensions []int64   `protobuf:"varint,2,rep,packed,name=dimensions" json:"dimensions,omitempty" yaml:"dimensions,omitempty"`
	Mean       []float32 `protobuf:"fixed32,3,rep,packed,name=mean" json:"mean,omitempty" yaml:"mean,omitempty"`
}

func (m *ModelInformation_Input) Reset()      { *m = ModelInformation_Input{} }
func (*ModelInformation_Input) ProtoMessage() {}
func (*ModelInformation_Input) Descriptor() ([]byte, []int) {
	return fileDescriptorDlframework, []int{2, 0}
}

func (m *ModelInformation_Input) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ModelInformation_Input) GetDimensions() []int64 {
	if m != nil {
		return m.Dimensions
	}
	return nil
}

func (m *ModelInformation_Input) GetMean() []float32 {
	if m != nil {
		return m.Mean
	}
	return nil
}

type ModelInformation_Output struct {
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty" yaml:"type,omitempty"`
}

func (m *ModelInformation_Output) Reset()      { *m = ModelInformation_Output{} }
func (*ModelInformation_Output) ProtoMessage() {}
func (*ModelInformation_Output) Descriptor() ([]byte, []int) {
	return fileDescriptorDlframework, []int{2, 1}
}

func (m *ModelInformation_Output) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type ModelInformation_Model struct {
	// Types that are valid to be assigned to ModelUrl:
	//	*ModelInformation_Model_GraphWeights_
	//	*ModelInformation_Model_TrainedUrl
	ModelUrl    isModelInformation_Model_ModelUrl `protobuf_oneof:"model_url"`
	FeaturesUrl string                            `protobuf:"bytes,3,opt,name=features_url,json=featuresUrl,proto3" json:"features_url,omitempty" yaml:"features_url,omitempty"`
}

func (m *ModelInformation_Model) Reset()      { *m = ModelInformation_Model{} }
func (*ModelInformation_Model) ProtoMessage() {}
func (*ModelInformation_Model) Descriptor() ([]byte, []int) {
	return fileDescriptorDlframework, []int{2, 2}
}

type isModelInformation_Model_ModelUrl interface {
	isModelInformation_Model_ModelUrl()
	Equal(interface{}) bool
	VerboseEqual(interface{}) error
	MarshalTo([]byte) (int, error)
	Size() int
}

type ModelInformation_Model_GraphWeights_ struct {
	GraphWeights *ModelInformation_Model_GraphWeights `protobuf:"bytes,1,opt,name=graph_weights,json=graphWeights,oneof"`
}
type ModelInformation_Model_TrainedUrl struct {
	TrainedUrl *ModelInformation_Model_GraphWeights `protobuf:"bytes,2,opt,name=trained_url,json=trainedUrl,oneof"`
}

func (*ModelInformation_Model_GraphWeights_) isModelInformation_Model_ModelUrl() {}
func (*ModelInformation_Model_TrainedUrl) isModelInformation_Model_ModelUrl()    {}

func (m *ModelInformation_Model) GetModelUrl() isModelInformation_Model_ModelUrl {
	if m != nil {
		return m.ModelUrl
	}
	return nil
}

func (m *ModelInformation_Model) GetGraphWeights() *ModelInformation_Model_GraphWeights {
	if x, ok := m.GetModelUrl().(*ModelInformation_Model_GraphWeights_); ok {
		return x.GraphWeights
	}
	return nil
}

func (m *ModelInformation_Model) GetTrainedUrl() *ModelInformation_Model_GraphWeights {
	if x, ok := m.GetModelUrl().(*ModelInformation_Model_TrainedUrl); ok {
		return x.TrainedUrl
	}
	return nil
}

func (m *ModelInformation_Model) GetFeaturesUrl() string {
	if m != nil {
		return m.FeaturesUrl
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ModelInformation_Model) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ModelInformation_Model_OneofMarshaler, _ModelInformation_Model_OneofUnmarshaler, _ModelInformation_Model_OneofSizer, []interface{}{
		(*ModelInformation_Model_GraphWeights_)(nil),
		(*ModelInformation_Model_TrainedUrl)(nil),
	}
}

func _ModelInformation_Model_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ModelInformation_Model)
	// model_url
	switch x := m.ModelUrl.(type) {
	case *ModelInformation_Model_GraphWeights_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GraphWeights); err != nil {
			return err
		}
	case *ModelInformation_Model_TrainedUrl:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TrainedUrl); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ModelInformation_Model.ModelUrl has unexpected type %T", x)
	}
	return nil
}

func _ModelInformation_Model_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ModelInformation_Model)
	switch tag {
	case 1: // model_url.graph_weights
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ModelInformation_Model_GraphWeights)
		err := b.DecodeMessage(msg)
		m.ModelUrl = &ModelInformation_Model_GraphWeights_{msg}
		return true, err
	case 2: // model_url.trained_url
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ModelInformation_Model_GraphWeights)
		err := b.DecodeMessage(msg)
		m.ModelUrl = &ModelInformation_Model_TrainedUrl{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ModelInformation_Model_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ModelInformation_Model)
	// model_url
	switch x := m.ModelUrl.(type) {
	case *ModelInformation_Model_GraphWeights_:
		s := proto.Size(x.GraphWeights)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ModelInformation_Model_TrainedUrl:
		s := proto.Size(x.TrainedUrl)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ModelInformation_Model_GraphWeights struct {
	GraphUrl   string `protobuf:"bytes,1,opt,name=graph_url,json=graphUrl,proto3" json:"graph_url,omitempty" yaml:"graph_url,omitempty"`
	WeightsUrl string `protobuf:"bytes,2,opt,name=weights_url,json=weightsUrl,proto3" json:"weights_url,omitempty" yaml:"weights_url,omitempty"`
}

func (m *ModelInformation_Model_GraphWeights) Reset()      { *m = ModelInformation_Model_GraphWeights{} }
func (*ModelInformation_Model_GraphWeights) ProtoMessage() {}
func (*ModelInformation_Model_GraphWeights) Descriptor() ([]byte, []int) {
	return fileDescriptorDlframework, []int{2, 2, 0}
}

func (m *ModelInformation_Model_GraphWeights) GetGraphUrl() string {
	if m != nil {
		return m.GraphUrl
	}
	return ""
}

func (m *ModelInformation_Model_GraphWeights) GetWeightsUrl() string {
	if m != nil {
		return m.WeightsUrl
	}
	return ""
}

type ModelInformation_Model_Trained struct {
	TrainedUrl string `protobuf:"bytes,1,opt,name=trained_url,json=trainedUrl,proto3" json:"trained_url,omitempty" yaml:"trained_url,omitempty"`
}

func (m *ModelInformation_Model_Trained) Reset()      { *m = ModelInformation_Model_Trained{} }
func (*ModelInformation_Model_Trained) ProtoMessage() {}
func (*ModelInformation_Model_Trained) Descriptor() ([]byte, []int) {
	return fileDescriptorDlframework, []int{2, 2, 1}
}

func (m *ModelInformation_Model_Trained) GetTrainedUrl() string {
	if m != nil {
		return m.TrainedUrl
	}
	return ""
}

type GetModelInformationsResponse struct {
	Info []*ModelInformation `protobuf:"bytes,1,rep,name=info" json:"info,omitempty" yaml:"info,omitempty"`
}

func (m *GetModelInformationsResponse) Reset()      { *m = GetModelInformationsResponse{} }
func (*GetModelInformationsResponse) ProtoMessage() {}
func (*GetModelInformationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorDlframework, []int{3}
}

func (m *GetModelInformationsResponse) GetInfo() []*ModelInformation {
	if m != nil {
		return m.Info
	}
	return nil
}

type GetModelInformationRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetModelInformationRequest) Reset()      { *m = GetModelInformationRequest{} }
func (*GetModelInformationRequest) ProtoMessage() {}
func (*GetModelInformationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorDlframework, []int{4}
}

func (m *GetModelInformationRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Null struct {
}

func (m *Null) Reset()                    { *m = Null{} }
func (*Null) ProtoMessage()               {}
func (*Null) Descriptor() ([]byte, []int) { return fileDescriptorDlframework, []int{5} }

func init() {
	proto.RegisterType((*ErrorStatus)(nil), "carml.org.dlframework.ErrorStatus")
	proto.RegisterType((*ContainerArchicture)(nil), "carml.org.dlframework.ContainerArchicture")
	proto.RegisterType((*ModelInformation)(nil), "carml.org.dlframework.ModelInformation")
	proto.RegisterType((*ModelInformation_Input)(nil), "carml.org.dlframework.ModelInformation.Input")
	proto.RegisterType((*ModelInformation_Output)(nil), "carml.org.dlframework.ModelInformation.Output")
	proto.RegisterType((*ModelInformation_Model)(nil), "carml.org.dlframework.ModelInformation.Model")
	proto.RegisterType((*ModelInformation_Model_GraphWeights)(nil), "carml.org.dlframework.ModelInformation.Model.GraphWeights")
	proto.RegisterType((*ModelInformation_Model_Trained)(nil), "carml.org.dlframework.ModelInformation.Model.Trained")
	proto.RegisterType((*GetModelInformationsResponse)(nil), "carml.org.dlframework.GetModelInformationsResponse")
	proto.RegisterType((*GetModelInformationRequest)(nil), "carml.org.dlframework.GetModelInformationRequest")
	proto.RegisterType((*Null)(nil), "carml.org.dlframework.Null")
}
func (this *ErrorStatus) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ErrorStatus)
	if !ok {
		that2, ok := that.(ErrorStatus)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ErrorStatus")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ErrorStatus but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ErrorStatus but is not nil && this == nil")
	}
	if this.Ok != that1.Ok {
		return fmt.Errorf("Ok this(%v) Not Equal that(%v)", this.Ok, that1.Ok)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *ErrorStatus) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ErrorStatus)
	if !ok {
		that2, ok := that.(ErrorStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Ok != that1.Ok {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *ContainerArchicture) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ContainerArchicture)
	if !ok {
		that2, ok := that.(ContainerArchicture)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ContainerArchicture")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ContainerArchicture but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ContainerArchicture but is not nil && this == nil")
	}
	if this.Gpu != that1.Gpu {
		return fmt.Errorf("Gpu this(%v) Not Equal that(%v)", this.Gpu, that1.Gpu)
	}
	if this.Cpu != that1.Cpu {
		return fmt.Errorf("Cpu this(%v) Not Equal that(%v)", this.Cpu, that1.Cpu)
	}
	return nil
}
func (this *ContainerArchicture) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerArchicture)
	if !ok {
		that2, ok := that.(ContainerArchicture)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Gpu != that1.Gpu {
		return false
	}
	if this.Cpu != that1.Cpu {
		return false
	}
	return true
}
func (this *ModelInformation) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ModelInformation)
	if !ok {
		that2, ok := that.(ModelInformation)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ModelInformation")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ModelInformation but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ModelInformation but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Description != that1.Description {
		return fmt.Errorf("Description this(%v) Not Equal that(%v)", this.Description, that1.Description)
	}
	if len(this.Container) != len(that1.Container) {
		return fmt.Errorf("Container this(%v) Not Equal that(%v)", len(this.Container), len(that1.Container))
	}
	for i := range this.Container {
		if !this.Container[i].Equal(that1.Container[i]) {
			return fmt.Errorf("Container this[%v](%v) Not Equal that[%v](%v)", i, this.Container[i], i, that1.Container[i])
		}
	}
	if this.Framework != that1.Framework {
		return fmt.Errorf("Framework this(%v) Not Equal that(%v)", this.Framework, that1.Framework)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.DatasetName != that1.DatasetName {
		return fmt.Errorf("DatasetName this(%v) Not Equal that(%v)", this.DatasetName, that1.DatasetName)
	}
	if !this.Input.Equal(that1.Input) {
		return fmt.Errorf("Input this(%v) Not Equal that(%v)", this.Input, that1.Input)
	}
	if !this.Output.Equal(that1.Output) {
		return fmt.Errorf("Output this(%v) Not Equal that(%v)", this.Output, that1.Output)
	}
	if len(this.References) != len(that1.References) {
		return fmt.Errorf("References this(%v) Not Equal that(%v)", len(this.References), len(that1.References))
	}
	for i := range this.References {
		if this.References[i] != that1.References[i] {
			return fmt.Errorf("References this[%v](%v) Not Equal that[%v](%v)", i, this.References[i], i, that1.References[i])
		}
	}
	return nil
}
func (this *ModelInformation) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ModelInformation)
	if !ok {
		that2, ok := that.(ModelInformation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Container) != len(that1.Container) {
		return false
	}
	for i := range this.Container {
		if !this.Container[i].Equal(that1.Container[i]) {
			return false
		}
	}
	if this.Framework != that1.Framework {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.DatasetName != that1.DatasetName {
		return false
	}
	if !this.Input.Equal(that1.Input) {
		return false
	}
	if !this.Output.Equal(that1.Output) {
		return false
	}
	if len(this.References) != len(that1.References) {
		return false
	}
	for i := range this.References {
		if this.References[i] != that1.References[i] {
			return false
		}
	}
	return true
}
func (this *ModelInformation_Input) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ModelInformation_Input)
	if !ok {
		that2, ok := that.(ModelInformation_Input)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ModelInformation_Input")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ModelInformation_Input but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ModelInformation_Input but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if len(this.Dimensions) != len(that1.Dimensions) {
		return fmt.Errorf("Dimensions this(%v) Not Equal that(%v)", len(this.Dimensions), len(that1.Dimensions))
	}
	for i := range this.Dimensions {
		if this.Dimensions[i] != that1.Dimensions[i] {
			return fmt.Errorf("Dimensions this[%v](%v) Not Equal that[%v](%v)", i, this.Dimensions[i], i, that1.Dimensions[i])
		}
	}
	if len(this.Mean) != len(that1.Mean) {
		return fmt.Errorf("Mean this(%v) Not Equal that(%v)", len(this.Mean), len(that1.Mean))
	}
	for i := range this.Mean {
		if this.Mean[i] != that1.Mean[i] {
			return fmt.Errorf("Mean this[%v](%v) Not Equal that[%v](%v)", i, this.Mean[i], i, that1.Mean[i])
		}
	}
	return nil
}
func (this *ModelInformation_Input) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ModelInformation_Input)
	if !ok {
		that2, ok := that.(ModelInformation_Input)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Dimensions) != len(that1.Dimensions) {
		return false
	}
	for i := range this.Dimensions {
		if this.Dimensions[i] != that1.Dimensions[i] {
			return false
		}
	}
	if len(this.Mean) != len(that1.Mean) {
		return false
	}
	for i := range this.Mean {
		if this.Mean[i] != that1.Mean[i] {
			return false
		}
	}
	return true
}
func (this *ModelInformation_Output) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ModelInformation_Output)
	if !ok {
		that2, ok := that.(ModelInformation_Output)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ModelInformation_Output")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ModelInformation_Output but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ModelInformation_Output but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	return nil
}
func (this *ModelInformation_Output) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ModelInformation_Output)
	if !ok {
		that2, ok := that.(ModelInformation_Output)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *ModelInformation_Model) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ModelInformation_Model)
	if !ok {
		that2, ok := that.(ModelInformation_Model)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ModelInformation_Model")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ModelInformation_Model but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ModelInformation_Model but is not nil && this == nil")
	}
	if that1.ModelUrl == nil {
		if this.ModelUrl != nil {
			return fmt.Errorf("this.ModelUrl != nil && that1.ModelUrl == nil")
		}
	} else if this.ModelUrl == nil {
		return fmt.Errorf("this.ModelUrl == nil && that1.ModelUrl != nil")
	} else if err := this.ModelUrl.VerboseEqual(that1.ModelUrl); err != nil {
		return err
	}
	if this.FeaturesUrl != that1.FeaturesUrl {
		return fmt.Errorf("FeaturesUrl this(%v) Not Equal that(%v)", this.FeaturesUrl, that1.FeaturesUrl)
	}
	return nil
}
func (this *ModelInformation_Model_GraphWeights_) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ModelInformation_Model_GraphWeights_)
	if !ok {
		that2, ok := that.(ModelInformation_Model_GraphWeights_)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ModelInformation_Model_GraphWeights_")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ModelInformation_Model_GraphWeights_ but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ModelInformation_Model_GraphWeights_ but is not nil && this == nil")
	}
	if !this.GraphWeights.Equal(that1.GraphWeights) {
		return fmt.Errorf("GraphWeights this(%v) Not Equal that(%v)", this.GraphWeights, that1.GraphWeights)
	}
	return nil
}
func (this *ModelInformation_Model_TrainedUrl) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ModelInformation_Model_TrainedUrl)
	if !ok {
		that2, ok := that.(ModelInformation_Model_TrainedUrl)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ModelInformation_Model_TrainedUrl")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ModelInformation_Model_TrainedUrl but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ModelInformation_Model_TrainedUrl but is not nil && this == nil")
	}
	if !this.TrainedUrl.Equal(that1.TrainedUrl) {
		return fmt.Errorf("TrainedUrl this(%v) Not Equal that(%v)", this.TrainedUrl, that1.TrainedUrl)
	}
	return nil
}
func (this *ModelInformation_Model) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ModelInformation_Model)
	if !ok {
		that2, ok := that.(ModelInformation_Model)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.ModelUrl == nil {
		if this.ModelUrl != nil {
			return false
		}
	} else if this.ModelUrl == nil {
		return false
	} else if !this.ModelUrl.Equal(that1.ModelUrl) {
		return false
	}
	if this.FeaturesUrl != that1.FeaturesUrl {
		return false
	}
	return true
}
func (this *ModelInformation_Model_GraphWeights_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ModelInformation_Model_GraphWeights_)
	if !ok {
		that2, ok := that.(ModelInformation_Model_GraphWeights_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.GraphWeights.Equal(that1.GraphWeights) {
		return false
	}
	return true
}
func (this *ModelInformation_Model_TrainedUrl) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ModelInformation_Model_TrainedUrl)
	if !ok {
		that2, ok := that.(ModelInformation_Model_TrainedUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.TrainedUrl.Equal(that1.TrainedUrl) {
		return false
	}
	return true
}
func (this *ModelInformation_Model_GraphWeights) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ModelInformation_Model_GraphWeights)
	if !ok {
		that2, ok := that.(ModelInformation_Model_GraphWeights)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ModelInformation_Model_GraphWeights")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ModelInformation_Model_GraphWeights but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ModelInformation_Model_GraphWeights but is not nil && this == nil")
	}
	if this.GraphUrl != that1.GraphUrl {
		return fmt.Errorf("GraphUrl this(%v) Not Equal that(%v)", this.GraphUrl, that1.GraphUrl)
	}
	if this.WeightsUrl != that1.WeightsUrl {
		return fmt.Errorf("WeightsUrl this(%v) Not Equal that(%v)", this.WeightsUrl, that1.WeightsUrl)
	}
	return nil
}
func (this *ModelInformation_Model_GraphWeights) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ModelInformation_Model_GraphWeights)
	if !ok {
		that2, ok := that.(ModelInformation_Model_GraphWeights)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.GraphUrl != that1.GraphUrl {
		return false
	}
	if this.WeightsUrl != that1.WeightsUrl {
		return false
	}
	return true
}
func (this *ModelInformation_Model_Trained) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ModelInformation_Model_Trained)
	if !ok {
		that2, ok := that.(ModelInformation_Model_Trained)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ModelInformation_Model_Trained")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ModelInformation_Model_Trained but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ModelInformation_Model_Trained but is not nil && this == nil")
	}
	if this.TrainedUrl != that1.TrainedUrl {
		return fmt.Errorf("TrainedUrl this(%v) Not Equal that(%v)", this.TrainedUrl, that1.TrainedUrl)
	}
	return nil
}
func (this *ModelInformation_Model_Trained) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ModelInformation_Model_Trained)
	if !ok {
		that2, ok := that.(ModelInformation_Model_Trained)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.TrainedUrl != that1.TrainedUrl {
		return false
	}
	return true
}
func (this *GetModelInformationsResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetModelInformationsResponse)
	if !ok {
		that2, ok := that.(GetModelInformationsResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetModelInformationsResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetModelInformationsResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetModelInformationsResponse but is not nil && this == nil")
	}
	if len(this.Info) != len(that1.Info) {
		return fmt.Errorf("Info this(%v) Not Equal that(%v)", len(this.Info), len(that1.Info))
	}
	for i := range this.Info {
		if !this.Info[i].Equal(that1.Info[i]) {
			return fmt.Errorf("Info this[%v](%v) Not Equal that[%v](%v)", i, this.Info[i], i, that1.Info[i])
		}
	}
	return nil
}
func (this *GetModelInformationsResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetModelInformationsResponse)
	if !ok {
		that2, ok := that.(GetModelInformationsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Info) != len(that1.Info) {
		return false
	}
	for i := range this.Info {
		if !this.Info[i].Equal(that1.Info[i]) {
			return false
		}
	}
	return true
}
func (this *GetModelInformationRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetModelInformationRequest)
	if !ok {
		that2, ok := that.(GetModelInformationRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetModelInformationRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetModelInformationRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetModelInformationRequest but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	return nil
}
func (this *GetModelInformationRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetModelInformationRequest)
	if !ok {
		that2, ok := that.(GetModelInformationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Null) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Null)
	if !ok {
		that2, ok := that.(Null)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Null")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Null but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Null but is not nil && this == nil")
	}
	return nil
}
func (this *Null) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Null)
	if !ok {
		that2, ok := that.(Null)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *ErrorStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dlframework.ErrorStatus{")
	s = append(s, "Ok: "+fmt.Sprintf("%#v", this.Ok)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerArchicture) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dlframework.ContainerArchicture{")
	s = append(s, "Gpu: "+fmt.Sprintf("%#v", this.Gpu)+",\n")
	s = append(s, "Cpu: "+fmt.Sprintf("%#v", this.Cpu)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ModelInformation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&dlframework.ModelInformation{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	keysForContainer := make([]string, 0, len(this.Container))
	for k, _ := range this.Container {
		keysForContainer = append(keysForContainer, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainer)
	mapStringForContainer := "map[string]*ContainerArchicture{"
	for _, k := range keysForContainer {
		mapStringForContainer += fmt.Sprintf("%#v: %#v,", k, this.Container[k])
	}
	mapStringForContainer += "}"
	if this.Container != nil {
		s = append(s, "Container: "+mapStringForContainer+",\n")
	}
	s = append(s, "Framework: "+fmt.Sprintf("%#v", this.Framework)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "DatasetName: "+fmt.Sprintf("%#v", this.DatasetName)+",\n")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	if this.Output != nil {
		s = append(s, "Output: "+fmt.Sprintf("%#v", this.Output)+",\n")
	}
	s = append(s, "References: "+fmt.Sprintf("%#v", this.References)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ModelInformation_Input) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dlframework.ModelInformation_Input{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Dimensions: "+fmt.Sprintf("%#v", this.Dimensions)+",\n")
	s = append(s, "Mean: "+fmt.Sprintf("%#v", this.Mean)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ModelInformation_Output) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dlframework.ModelInformation_Output{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ModelInformation_Model) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dlframework.ModelInformation_Model{")
	if this.ModelUrl != nil {
		s = append(s, "ModelUrl: "+fmt.Sprintf("%#v", this.ModelUrl)+",\n")
	}
	s = append(s, "FeaturesUrl: "+fmt.Sprintf("%#v", this.FeaturesUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ModelInformation_Model_GraphWeights_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dlframework.ModelInformation_Model_GraphWeights_{` +
		`GraphWeights:` + fmt.Sprintf("%#v", this.GraphWeights) + `}`}, ", ")
	return s
}
func (this *ModelInformation_Model_TrainedUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dlframework.ModelInformation_Model_TrainedUrl{` +
		`TrainedUrl:` + fmt.Sprintf("%#v", this.TrainedUrl) + `}`}, ", ")
	return s
}
func (this *ModelInformation_Model_GraphWeights) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dlframework.ModelInformation_Model_GraphWeights{")
	s = append(s, "GraphUrl: "+fmt.Sprintf("%#v", this.GraphUrl)+",\n")
	s = append(s, "WeightsUrl: "+fmt.Sprintf("%#v", this.WeightsUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ModelInformation_Model_Trained) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dlframework.ModelInformation_Model_Trained{")
	s = append(s, "TrainedUrl: "+fmt.Sprintf("%#v", this.TrainedUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetModelInformationsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dlframework.GetModelInformationsResponse{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetModelInformationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dlframework.GetModelInformationRequest{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Null) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&dlframework.Null{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDlframework(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MXNet service

type MXNetClient interface {
	GetModelInformations(ctx context.Context, in *Null, opts ...grpc.CallOption) (*GetModelInformationsResponse, error)
	GetModelInformation(ctx context.Context, in *GetModelInformationRequest, opts ...grpc.CallOption) (*ModelInformation, error)
}

type mXNetClient struct {
	cc *grpc.ClientConn
}

func NewMXNetClient(cc *grpc.ClientConn) MXNetClient {
	return &mXNetClient{cc}
}

func (c *mXNetClient) GetModelInformations(ctx context.Context, in *Null, opts ...grpc.CallOption) (*GetModelInformationsResponse, error) {
	out := new(GetModelInformationsResponse)
	err := grpc.Invoke(ctx, "/carml.org.dlframework.MXNet/GetModelInformations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mXNetClient) GetModelInformation(ctx context.Context, in *GetModelInformationRequest, opts ...grpc.CallOption) (*ModelInformation, error) {
	out := new(ModelInformation)
	err := grpc.Invoke(ctx, "/carml.org.dlframework.MXNet/GetModelInformation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MXNet service

type MXNetServer interface {
	GetModelInformations(context.Context, *Null) (*GetModelInformationsResponse, error)
	GetModelInformation(context.Context, *GetModelInformationRequest) (*ModelInformation, error)
}

func RegisterMXNetServer(s *grpc.Server, srv MXNetServer) {
	s.RegisterService(&_MXNet_serviceDesc, srv)
}

func _MXNet_GetModelInformations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Null)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXNetServer).GetModelInformations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/carml.org.dlframework.MXNet/GetModelInformations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXNetServer).GetModelInformations(ctx, req.(*Null))
	}
	return interceptor(ctx, in, info, handler)
}

func _MXNet_GetModelInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MXNetServer).GetModelInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/carml.org.dlframework.MXNet/GetModelInformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MXNetServer).GetModelInformation(ctx, req.(*GetModelInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MXNet_serviceDesc = grpc.ServiceDesc{
	ServiceName: "carml.org.dlframework.MXNet",
	HandlerType: (*MXNetServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetModelInformations",
			Handler:    _MXNet_GetModelInformations_Handler,
		},
		{
			MethodName: "GetModelInformation",
			Handler:    _MXNet_GetModelInformation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dlframework.proto",
}

func (m *ErrorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ok {
		dAtA[i] = 0x8
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *ContainerArchicture) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerArchicture) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Gpu) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.Gpu)))
		i += copy(dAtA[i:], m.Gpu)
	}
	if len(m.Cpu) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.Cpu)))
		i += copy(dAtA[i:], m.Cpu)
	}
	return i, nil
}

func (m *ModelInformation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelInformation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Container) > 0 {
		for k, _ := range m.Container {
			dAtA[i] = 0x1a
			i++
			v := m.Container[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovDlframework(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovDlframework(uint64(len(k))) + msgSize
			i = encodeVarintDlframework(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDlframework(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintDlframework(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if len(m.Framework) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.Framework)))
		i += copy(dAtA[i:], m.Framework)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.DatasetName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.DatasetName)))
		i += copy(dAtA[i:], m.DatasetName)
	}
	if m.Input != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(m.Input.Size()))
		n2, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Output != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(m.Output.Size()))
		n3, err := m.Output.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.References) > 0 {
		for _, s := range m.References {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ModelInformation_Input) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelInformation_Input) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Dimensions) > 0 {
		dAtA5 := make([]byte, len(m.Dimensions)*10)
		var j4 int
		for _, num1 := range m.Dimensions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.Mean) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.Mean)*4))
		for _, num := range m.Mean {
			f6 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f6)
			i++
			dAtA[i] = uint8(f6 >> 8)
			i++
			dAtA[i] = uint8(f6 >> 16)
			i++
			dAtA[i] = uint8(f6 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *ModelInformation_Output) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelInformation_Output) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	return i, nil
}

func (m *ModelInformation_Model) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelInformation_Model) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ModelUrl != nil {
		nn7, err := m.ModelUrl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	if len(m.FeaturesUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.FeaturesUrl)))
		i += copy(dAtA[i:], m.FeaturesUrl)
	}
	return i, nil
}

func (m *ModelInformation_Model_GraphWeights_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GraphWeights != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(m.GraphWeights.Size()))
		n8, err := m.GraphWeights.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ModelInformation_Model_TrainedUrl) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TrainedUrl != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(m.TrainedUrl.Size()))
		n9, err := m.TrainedUrl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *ModelInformation_Model_GraphWeights) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelInformation_Model_GraphWeights) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GraphUrl) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.GraphUrl)))
		i += copy(dAtA[i:], m.GraphUrl)
	}
	if len(m.WeightsUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.WeightsUrl)))
		i += copy(dAtA[i:], m.WeightsUrl)
	}
	return i, nil
}

func (m *ModelInformation_Model_Trained) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelInformation_Model_Trained) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TrainedUrl) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.TrainedUrl)))
		i += copy(dAtA[i:], m.TrainedUrl)
	}
	return i, nil
}

func (m *GetModelInformationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetModelInformationsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, msg := range m.Info {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDlframework(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetModelInformationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetModelInformationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlframework(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *Null) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Null) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64Dlframework(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Dlframework(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDlframework(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedErrorStatus(r randyDlframework, easy bool) *ErrorStatus {
	this := &ErrorStatus{}
	this.Ok = bool(bool(r.Intn(2) == 0))
	this.Message = string(randStringDlframework(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedContainerArchicture(r randyDlframework, easy bool) *ContainerArchicture {
	this := &ContainerArchicture{}
	this.Gpu = string(randStringDlframework(r))
	this.Cpu = string(randStringDlframework(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedModelInformation(r randyDlframework, easy bool) *ModelInformation {
	this := &ModelInformation{}
	this.Name = string(randStringDlframework(r))
	this.Description = string(randStringDlframework(r))
	if r.Intn(10) != 0 {
		v1 := r.Intn(10)
		this.Container = make(map[string]*ContainerArchicture)
		for i := 0; i < v1; i++ {
			this.Container[randStringDlframework(r)] = NewPopulatedContainerArchicture(r, easy)
		}
	}
	this.Framework = string(randStringDlframework(r))
	this.Version = string(randStringDlframework(r))
	this.Type = string(randStringDlframework(r))
	this.DatasetName = string(randStringDlframework(r))
	if r.Intn(10) != 0 {
		this.Input = NewPopulatedModelInformation_Input(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Output = NewPopulatedModelInformation_Output(r, easy)
	}
	v2 := r.Intn(10)
	this.References = make([]string, v2)
	for i := 0; i < v2; i++ {
		this.References[i] = string(randStringDlframework(r))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedModelInformation_Input(r randyDlframework, easy bool) *ModelInformation_Input {
	this := &ModelInformation_Input{}
	this.Type = string(randStringDlframework(r))
	v3 := r.Intn(10)
	this.Dimensions = make([]int64, v3)
	for i := 0; i < v3; i++ {
		this.Dimensions[i] = int64(r.Int63())
		if r.Intn(2) == 0 {
			this.Dimensions[i] *= -1
		}
	}
	v4 := r.Intn(10)
	this.Mean = make([]float32, v4)
	for i := 0; i < v4; i++ {
		this.Mean[i] = float32(r.Float32())
		if r.Intn(2) == 0 {
			this.Mean[i] *= -1
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedModelInformation_Output(r randyDlframework, easy bool) *ModelInformation_Output {
	this := &ModelInformation_Output{}
	this.Type = string(randStringDlframework(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedModelInformation_Model(r randyDlframework, easy bool) *ModelInformation_Model {
	this := &ModelInformation_Model{}
	oneofNumber_ModelUrl := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_ModelUrl {
	case 1:
		this.ModelUrl = NewPopulatedModelInformation_Model_GraphWeights_(r, easy)
	case 2:
		this.ModelUrl = NewPopulatedModelInformation_Model_TrainedUrl(r, easy)
	}
	this.FeaturesUrl = string(randStringDlframework(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedModelInformation_Model_GraphWeights_(r randyDlframework, easy bool) *ModelInformation_Model_GraphWeights_ {
	this := &ModelInformation_Model_GraphWeights_{}
	this.GraphWeights = NewPopulatedModelInformation_Model_GraphWeights(r, easy)
	return this
}
func NewPopulatedModelInformation_Model_TrainedUrl(r randyDlframework, easy bool) *ModelInformation_Model_TrainedUrl {
	this := &ModelInformation_Model_TrainedUrl{}
	this.TrainedUrl = NewPopulatedModelInformation_Model_GraphWeights(r, easy)
	return this
}
func NewPopulatedModelInformation_Model_GraphWeights(r randyDlframework, easy bool) *ModelInformation_Model_GraphWeights {
	this := &ModelInformation_Model_GraphWeights{}
	this.GraphUrl = string(randStringDlframework(r))
	this.WeightsUrl = string(randStringDlframework(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedModelInformation_Model_Trained(r randyDlframework, easy bool) *ModelInformation_Model_Trained {
	this := &ModelInformation_Model_Trained{}
	this.TrainedUrl = string(randStringDlframework(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetModelInformationsResponse(r randyDlframework, easy bool) *GetModelInformationsResponse {
	this := &GetModelInformationsResponse{}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.Info = make([]*ModelInformation, v5)
		for i := 0; i < v5; i++ {
			this.Info[i] = NewPopulatedModelInformation(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGetModelInformationRequest(r randyDlframework, easy bool) *GetModelInformationRequest {
	this := &GetModelInformationRequest{}
	this.Name = string(randStringDlframework(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNull(r randyDlframework, easy bool) *Null {
	this := &Null{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyDlframework interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneDlframework(r randyDlframework) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringDlframework(r randyDlframework) string {
	v6 := r.Intn(100)
	tmps := make([]rune, v6)
	for i := 0; i < v6; i++ {
		tmps[i] = randUTF8RuneDlframework(r)
	}
	return string(tmps)
}
func randUnrecognizedDlframework(r randyDlframework, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldDlframework(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldDlframework(dAtA []byte, r randyDlframework, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateDlframework(dAtA, uint64(key))
		v7 := r.Int63()
		if r.Intn(2) == 0 {
			v7 *= -1
		}
		dAtA = encodeVarintPopulateDlframework(dAtA, uint64(v7))
	case 1:
		dAtA = encodeVarintPopulateDlframework(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateDlframework(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateDlframework(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateDlframework(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateDlframework(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *ErrorStatus) Size() (n int) {
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	return n
}

func (m *ContainerArchicture) Size() (n int) {
	var l int
	_ = l
	l = len(m.Gpu)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	l = len(m.Cpu)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	return n
}

func (m *ModelInformation) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	if len(m.Container) > 0 {
		for k, v := range m.Container {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDlframework(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovDlframework(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDlframework(uint64(mapEntrySize))
		}
	}
	l = len(m.Framework)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	l = len(m.DatasetName)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovDlframework(uint64(l))
	}
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovDlframework(uint64(l))
	}
	if len(m.References) > 0 {
		for _, s := range m.References {
			l = len(s)
			n += 1 + l + sovDlframework(uint64(l))
		}
	}
	return n
}

func (m *ModelInformation_Input) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	if len(m.Dimensions) > 0 {
		l = 0
		for _, e := range m.Dimensions {
			l += sovDlframework(uint64(e))
		}
		n += 1 + sovDlframework(uint64(l)) + l
	}
	if len(m.Mean) > 0 {
		n += 1 + sovDlframework(uint64(len(m.Mean)*4)) + len(m.Mean)*4
	}
	return n
}

func (m *ModelInformation_Output) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	return n
}

func (m *ModelInformation_Model) Size() (n int) {
	var l int
	_ = l
	if m.ModelUrl != nil {
		n += m.ModelUrl.Size()
	}
	l = len(m.FeaturesUrl)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	return n
}

func (m *ModelInformation_Model_GraphWeights_) Size() (n int) {
	var l int
	_ = l
	if m.GraphWeights != nil {
		l = m.GraphWeights.Size()
		n += 1 + l + sovDlframework(uint64(l))
	}
	return n
}
func (m *ModelInformation_Model_TrainedUrl) Size() (n int) {
	var l int
	_ = l
	if m.TrainedUrl != nil {
		l = m.TrainedUrl.Size()
		n += 1 + l + sovDlframework(uint64(l))
	}
	return n
}
func (m *ModelInformation_Model_GraphWeights) Size() (n int) {
	var l int
	_ = l
	l = len(m.GraphUrl)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	l = len(m.WeightsUrl)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	return n
}

func (m *ModelInformation_Model_Trained) Size() (n int) {
	var l int
	_ = l
	l = len(m.TrainedUrl)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	return n
}

func (m *GetModelInformationsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovDlframework(uint64(l))
		}
	}
	return n
}

func (m *GetModelInformationRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDlframework(uint64(l))
	}
	return n
}

func (m *Null) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovDlframework(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDlframework(x uint64) (n int) {
	return sovDlframework(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ErrorStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ErrorStatus{`,
		`Ok:` + fmt.Sprintf("%v", this.Ok) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerArchicture) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerArchicture{`,
		`Gpu:` + fmt.Sprintf("%v", this.Gpu) + `,`,
		`Cpu:` + fmt.Sprintf("%v", this.Cpu) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelInformation) String() string {
	if this == nil {
		return "nil"
	}
	keysForContainer := make([]string, 0, len(this.Container))
	for k, _ := range this.Container {
		keysForContainer = append(keysForContainer, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainer)
	mapStringForContainer := "map[string]*ContainerArchicture{"
	for _, k := range keysForContainer {
		mapStringForContainer += fmt.Sprintf("%v: %v,", k, this.Container[k])
	}
	mapStringForContainer += "}"
	s := strings.Join([]string{`&ModelInformation{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Container:` + mapStringForContainer + `,`,
		`Framework:` + fmt.Sprintf("%v", this.Framework) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`DatasetName:` + fmt.Sprintf("%v", this.DatasetName) + `,`,
		`Input:` + strings.Replace(fmt.Sprintf("%v", this.Input), "ModelInformation_Input", "ModelInformation_Input", 1) + `,`,
		`Output:` + strings.Replace(fmt.Sprintf("%v", this.Output), "ModelInformation_Output", "ModelInformation_Output", 1) + `,`,
		`References:` + fmt.Sprintf("%v", this.References) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelInformation_Input) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelInformation_Input{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Dimensions:` + fmt.Sprintf("%v", this.Dimensions) + `,`,
		`Mean:` + fmt.Sprintf("%v", this.Mean) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelInformation_Output) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelInformation_Output{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelInformation_Model) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelInformation_Model{`,
		`ModelUrl:` + fmt.Sprintf("%v", this.ModelUrl) + `,`,
		`FeaturesUrl:` + fmt.Sprintf("%v", this.FeaturesUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelInformation_Model_GraphWeights_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelInformation_Model_GraphWeights_{`,
		`GraphWeights:` + strings.Replace(fmt.Sprintf("%v", this.GraphWeights), "ModelInformation_Model_GraphWeights", "ModelInformation_Model_GraphWeights", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelInformation_Model_TrainedUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelInformation_Model_TrainedUrl{`,
		`TrainedUrl:` + strings.Replace(fmt.Sprintf("%v", this.TrainedUrl), "ModelInformation_Model_GraphWeights", "ModelInformation_Model_GraphWeights", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelInformation_Model_GraphWeights) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelInformation_Model_GraphWeights{`,
		`GraphUrl:` + fmt.Sprintf("%v", this.GraphUrl) + `,`,
		`WeightsUrl:` + fmt.Sprintf("%v", this.WeightsUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelInformation_Model_Trained) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelInformation_Model_Trained{`,
		`TrainedUrl:` + fmt.Sprintf("%v", this.TrainedUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetModelInformationsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetModelInformationsResponse{`,
		`Info:` + strings.Replace(fmt.Sprintf("%v", this.Info), "ModelInformation", "ModelInformation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetModelInformationRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetModelInformationRequest{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Null) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Null{`,
		`}`,
	}, "")
	return s
}
func valueToStringDlframework(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ErrorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlframework
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlframework(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlframework
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerArchicture) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlframework
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerArchicture: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerArchicture: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gpu = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpu = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlframework(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlframework
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelInformation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlframework
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelInformation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelInformation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthDlframework
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Container == nil {
				m.Container = make(map[string]*ContainerArchicture)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDlframework
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDlframework
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthDlframework
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthDlframework
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &ContainerArchicture{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Container[mapkey] = mapvalue
			} else {
				var mapvalue *ContainerArchicture
				m.Container[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Framework", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Framework = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &ModelInformation_Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &ModelInformation_Output{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = append(m.References, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlframework(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlframework
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelInformation_Input) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlframework
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Input: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Input: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDlframework
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dimensions = append(m.Dimensions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDlframework
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDlframework
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDlframework
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dimensions = append(m.Dimensions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
		case 3:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Mean = append(m.Mean, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDlframework
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDlframework
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Mean = append(m.Mean, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mean", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDlframework(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlframework
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelInformation_Output) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlframework
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Output: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Output: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlframework(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlframework
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelInformation_Model) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlframework
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphWeights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelInformation_Model_GraphWeights{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ModelUrl = &ModelInformation_Model_GraphWeights_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainedUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelInformation_Model_GraphWeights{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ModelUrl = &ModelInformation_Model_TrainedUrl{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeaturesUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeaturesUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlframework(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlframework
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelInformation_Model_GraphWeights) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlframework
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphWeights: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphWeights: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightsUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeightsUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlframework(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlframework
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelInformation_Model_Trained) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlframework
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trained: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trained: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainedUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrainedUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlframework(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlframework
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetModelInformationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlframework
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetModelInformationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetModelInformationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &ModelInformation{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlframework(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlframework
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetModelInformationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlframework
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetModelInformationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetModelInformationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlframework
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlframework(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlframework
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Null) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlframework
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Null: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Null: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDlframework(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlframework
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDlframework(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDlframework
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDlframework
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDlframework
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDlframework
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDlframework(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDlframework = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDlframework   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("dlframework.proto", fileDescriptorDlframework) }

var fileDescriptorDlframework = []byte{
	// 951 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcf, 0x8f, 0xdb, 0x44,
	0x18, 0xdd, 0xc9, 0xaf, 0x6e, 0xbe, 0x04, 0xb4, 0xcc, 0xb6, 0xd4, 0x78, 0x17, 0x3b, 0xf8, 0xd2,
	0xa8, 0xea, 0xa6, 0xb0, 0x95, 0x0a, 0x5a, 0x40, 0xa5, 0x86, 0xaa, 0x54, 0xa2, 0x8b, 0x14, 0x28,
	0x20, 0x2e, 0x2b, 0xaf, 0x33, 0x71, 0x4c, 0x6c, 0x8f, 0x19, 0x8f, 0x77, 0x95, 0x1b, 0x7f, 0x01,
	0xe2, 0x3f, 0xe0, 0x86, 0xf8, 0x13, 0x38, 0x72, 0xe4, 0xc8, 0x11, 0x09, 0xc9, 0xea, 0x86, 0x0b,
	0x47, 0xe4, 0x13, 0x47, 0x34, 0x63, 0x6f, 0x32, 0x8e, 0xb2, 0x28, 0x48, 0xdc, 0xe2, 0xef, 0x7d,
	0xef, 0xbd, 0x99, 0xf7, 0x79, 0xc6, 0x81, 0x97, 0x46, 0xc1, 0x98, 0x39, 0x21, 0x39, 0xa7, 0x6c,
	0x3a, 0x88, 0x19, 0xe5, 0x14, 0xdf, 0x70, 0x1d, 0x16, 0x06, 0x03, 0xca, 0xbc, 0x81, 0x02, 0xea,
	0x07, 0x9e, 0xcf, 0x27, 0xe9, 0xe9, 0xc0, 0xa5, 0xe1, 0x5d, 0x8f, 0x7a, 0xf4, 0xae, 0xec, 0x3e,
	0x4d, 0xc7, 0xf2, 0x49, 0x3e, 0xc8, 0x5f, 0x85, 0x8a, 0x15, 0x41, 0xe7, 0x11, 0x63, 0x94, 0x7d,
	0xc2, 0x1d, 0x9e, 0x26, 0xf8, 0x16, 0xd4, 0xe8, 0x54, 0x43, 0x3d, 0xd4, 0xdf, 0xb6, 0x6f, 0xe6,
	0x99, 0xb9, 0x3b, 0x73, 0xc2, 0xe0, 0xc8, 0xa2, 0xd3, 0x3b, 0x34, 0xf4, 0x39, 0x09, 0x63, 0x3e,
	0xb3, 0x86, 0x35, 0x3a, 0xc5, 0xf7, 0xe1, 0x5a, 0x48, 0x92, 0xc4, 0xf1, 0x88, 0x56, 0xeb, 0xa1,
	0x7e, 0xdb, 0xde, 0xcf, 0x33, 0x53, 0x2b, 0xba, 0x4b, 0x40, 0xa5, 0x5c, 0x36, 0x5b, 0x21, 0xec,
	0xbe, 0x4f, 0x23, 0xee, 0xf8, 0x11, 0x61, 0x0f, 0x99, 0x3b, 0xf1, 0x5d, 0x9e, 0x32, 0x82, 0x6f,
	0x43, 0xdd, 0x8b, 0x53, 0x69, 0xdc, 0xb6, 0xb5, 0x3c, 0x33, 0xaf, 0x17, 0x52, 0x5e, 0x9c, 0xaa,
	0x32, 0xa2, 0x49, 0xf4, 0xba, 0x71, 0x5a, 0xda, 0x2a, 0xbd, 0xee, 0x4a, 0xaf, 0x1b, 0xa7, 0xd6,
	0xef, 0x5d, 0xd8, 0x79, 0x4a, 0x47, 0x24, 0x78, 0x12, 0x8d, 0x29, 0x0b, 0x1d, 0xee, 0xd3, 0x08,
	0x1f, 0x40, 0x23, 0x72, 0x42, 0x52, 0xba, 0xbd, 0x92, 0x67, 0xe6, 0x8d, 0x42, 0x41, 0x54, 0x55,
	0x09, 0xd9, 0x86, 0x6d, 0xe8, 0x8c, 0x48, 0xe2, 0x32, 0x3f, 0x16, 0xec, 0xd2, 0xb7, 0x97, 0x67,
	0xe6, 0x7e, 0xc1, 0x52, 0x40, 0x95, 0xac, 0x92, 0x30, 0x87, 0xb6, 0x7b, 0xb9, 0x6d, 0xad, 0xde,
	0xab, 0xf7, 0x3b, 0x87, 0xf7, 0x07, 0x6b, 0x07, 0x38, 0x58, 0x5d, 0xee, 0x60, 0x91, 0xd7, 0xa3,
	0x88, 0xb3, 0x99, 0x6d, 0xe4, 0x99, 0xa9, 0x97, 0x3b, 0xbe, 0x44, 0x54, 0xdf, 0xa5, 0x11, 0x7e,
	0x07, 0xda, 0x0b, 0x5d, 0xad, 0x21, 0xd7, 0xad, 0xb0, 0x17, 0x50, 0x85, 0xbd, 0xa8, 0x8a, 0x11,
	0x9f, 0x11, 0x96, 0x88, 0x3d, 0x37, 0x57, 0x47, 0x5c, 0x02, 0x95, 0x11, 0x97, 0x35, 0x11, 0x2f,
	0x9f, 0xc5, 0x44, 0x6b, 0xad, 0xc6, 0x2b, 0xaa, 0x95, 0x78, 0x45, 0x01, 0x7f, 0x00, 0xdd, 0x91,
	0xc3, 0x9d, 0x84, 0xf0, 0x13, 0x39, 0x95, 0x6b, 0x92, 0xf6, 0x5a, 0x9e, 0x99, 0xaf, 0x96, 0xf9,
	0x2a, 0x68, 0x35, 0xe0, 0x02, 0x38, 0x16, 0x43, 0x3a, 0x81, 0xa6, 0x1f, 0xc5, 0x29, 0xd7, 0xb6,
	0x7b, 0xa8, 0xdf, 0x39, 0x3c, 0xd8, 0x34, 0xdc, 0x27, 0x82, 0x64, 0xeb, 0x79, 0x66, 0xbe, 0x5c,
	0xb8, 0x49, 0x15, 0xd5, 0xa6, 0xd0, 0xc5, 0x2e, 0xb4, 0x68, 0xca, 0x85, 0x43, 0x5b, 0x3a, 0x0c,
	0x36, 0x75, 0xf8, 0x58, 0xb2, 0xec, 0xbd, 0x3c, 0x33, 0x6f, 0x96, 0xa7, 0x49, 0x56, 0x54, 0x8f,
	0x52, 0x1a, 0x3f, 0x00, 0x60, 0x64, 0x4c, 0x18, 0x89, 0x5c, 0x92, 0x68, 0xd0, 0xab, 0xf7, 0xdb,
	0xb6, 0x99, 0x67, 0xe6, 0x5e, 0x41, 0x5c, 0x62, 0x2a, 0x59, 0xa1, 0xe8, 0x3f, 0x20, 0x68, 0xca,
	0x2d, 0x2d, 0xa6, 0x80, 0x36, 0x9b, 0xc2, 0x03, 0x80, 0x91, 0x1f, 0x92, 0x48, 0x4c, 0x30, 0xd1,
	0x6a, 0xbd, 0x7a, 0xbf, 0xae, 0x3a, 0x2f, 0xb1, 0x8a, 0xf3, 0xb2, 0x2c, 0xfc, 0x42, 0xe2, 0x44,
	0xf2, 0xe5, 0xae, 0xa9, 0x7e, 0xa2, 0x5a, 0xf1, 0x13, 0x05, 0xfd, 0x4d, 0x68, 0x15, 0xc1, 0xfc,
	0xc7, 0x85, 0xea, 0xdf, 0x37, 0xa0, 0x29, 0x33, 0xc6, 0x09, 0xbc, 0xe0, 0x31, 0x27, 0x9e, 0x9c,
	0x9c, 0x13, 0xdf, 0x9b, 0xf0, 0x44, 0x2a, 0x74, 0x0e, 0x8f, 0x36, 0x1d, 0x8c, 0x2c, 0x0c, 0x1e,
	0x0b, 0x89, 0xcf, 0x0b, 0x05, 0x7b, 0x27, 0xcf, 0xcc, 0x6e, 0xe1, 0x7e, 0x67, 0x1c, 0xd0, 0x73,
	0xeb, 0xc3, 0xad, 0x61, 0xd7, 0x53, 0x3a, 0x30, 0x85, 0x0e, 0x67, 0xe2, 0x74, 0x8d, 0x4e, 0x52,
	0x16, 0xc8, 0xcb, 0xe0, 0xff, 0xb7, 0x84, 0xd2, 0xe2, 0x19, 0x0b, 0xc4, 0xf1, 0x18, 0x13, 0x47,
	0x5c, 0x92, 0x89, 0x74, 0xac, 0xaf, 0x1e, 0x0f, 0x15, 0xad, 0x1c, 0x8f, 0x4b, 0xe0, 0x19, 0x0b,
	0xf4, 0x6f, 0x11, 0x74, 0x55, 0x5b, 0xfc, 0x36, 0xb4, 0x8b, 0xf0, 0x84, 0x26, 0x5a, 0xbd, 0x1a,
	0x16, 0x90, 0x2a, 0xb8, 0x2d, 0xab, 0x62, 0x4d, 0x0f, 0xa1, 0x53, 0x66, 0xbe, 0x08, 0xa1, 0x72,
	0x23, 0x2a, 0x60, 0xe5, 0x75, 0x29, 0xeb, 0x62, 0x41, 0x1f, 0xc1, 0xb5, 0x4f, 0x8b, 0x4d, 0x0a,
	0x35, 0x35, 0x52, 0xb4, 0xaa, 0xa6, 0x80, 0x15, 0xb5, 0x65, 0x48, 0x76, 0x07, 0xda, 0xa1, 0x88,
	0x56, 0xf4, 0xe8, 0x13, 0x78, 0xb1, 0x7a, 0x65, 0xe2, 0x1d, 0xa8, 0x4f, 0xc9, 0xac, 0x50, 0x1e,
	0x8a, 0x9f, 0xf8, 0x3d, 0x68, 0x9e, 0x39, 0x41, 0x4a, 0xca, 0x01, 0xde, 0xbe, 0x62, 0x80, 0x6b,
	0x3e, 0x55, 0xc3, 0x82, 0x78, 0x54, 0x7b, 0x0b, 0x59, 0x67, 0xb0, 0xff, 0x98, 0xf0, 0xd5, 0x29,
	0x27, 0x43, 0x92, 0xc4, 0x34, 0x4a, 0x08, 0xfe, 0x0c, 0x1a, 0x7e, 0x34, 0xa6, 0x1a, 0x92, 0x17,
	0xfe, 0xad, 0x0d, 0xdf, 0x12, 0xf5, 0x0c, 0x08, 0x7a, 0xe5, 0x0c, 0x88, 0x82, 0xf5, 0x3a, 0xe8,
	0x6b, 0x7c, 0x87, 0xe4, 0xeb, 0x94, 0x24, 0x1c, 0x63, 0xf5, 0xf3, 0x56, 0x7c, 0xc3, 0xac, 0x16,
	0x34, 0x8e, 0xd3, 0x20, 0x38, 0xfc, 0x13, 0x41, 0xf3, 0xe9, 0x17, 0xc7, 0x84, 0xe3, 0xaf, 0xe0,
	0xfa, 0xba, 0xb5, 0xe3, 0xbd, 0x2b, 0x56, 0x29, 0xe8, 0xfa, 0xbd, 0x2b, 0xc0, 0x7f, 0x4b, 0xc1,
	0xda, 0xc2, 0x09, 0xec, 0xae, 0xe9, 0xc0, 0x6f, 0x6c, 0xae, 0x56, 0xee, 0x4d, 0xdf, 0x34, 0x43,
	0x6b, 0xcb, 0x7e, 0xf7, 0xb7, 0x0b, 0x63, 0xeb, 0xf9, 0x85, 0x81, 0xfe, 0xba, 0x30, 0xd0, 0xdf,
	0x17, 0x06, 0xfa, 0x66, 0x6e, 0xa0, 0x1f, 0xe7, 0x06, 0xfa, 0x69, 0x6e, 0xa0, 0x9f, 0xe7, 0x06,
	0xfa, 0x65, 0x6e, 0xa0, 0x5f, 0xe7, 0x06, 0x7a, 0x3e, 0x37, 0xd0, 0x77, 0x7f, 0x18, 0x5b, 0x5f,
	0x76, 0x14, 0xc5, 0xd3, 0x96, 0xfc, 0x7f, 0x74, 0xef, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x33,
	0xc9, 0x2a, 0x6c, 0x7a, 0x09, 0x00, 0x00,
}
