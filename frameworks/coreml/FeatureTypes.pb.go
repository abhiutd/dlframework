// Code generated by protoc-gen-gogo.
// source: FeatureTypes.proto
// DO NOT EDIT!

package CoreML

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Assumes raw (decompressed) format
type ImageFeatureType_ColorSpace int32

const (
	ImageFeatureType_INVALID_COLOR_SPACE ImageFeatureType_ColorSpace = 0
	ImageFeatureType_GRAYSCALE           ImageFeatureType_ColorSpace = 10
	ImageFeatureType_RGB                 ImageFeatureType_ColorSpace = 20
	ImageFeatureType_BGR                 ImageFeatureType_ColorSpace = 30
)

var ImageFeatureType_ColorSpace_name = map[int32]string{
	0:  "INVALID_COLOR_SPACE",
	10: "GRAYSCALE",
	20: "RGB",
	30: "BGR",
}
var ImageFeatureType_ColorSpace_value = map[string]int32{
	"INVALID_COLOR_SPACE": 0,
	"GRAYSCALE":           10,
	"RGB":                 20,
	"BGR":                 30,
}

func (x ImageFeatureType_ColorSpace) String() string {
	return proto.EnumName(ImageFeatureType_ColorSpace_name, int32(x))
}
func (ImageFeatureType_ColorSpace) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorFeatureTypes, []int{3, 0}
}

type ArrayFeatureType_ArrayDataType int32

const (
	ArrayFeatureType_INVALID_ARRAY_DATA_TYPE ArrayFeatureType_ArrayDataType = 0
	ArrayFeatureType_FLOAT32                 ArrayFeatureType_ArrayDataType = 65568
	ArrayFeatureType_DOUBLE                  ArrayFeatureType_ArrayDataType = 65600
	ArrayFeatureType_INT32                   ArrayFeatureType_ArrayDataType = 131104
)

var ArrayFeatureType_ArrayDataType_name = map[int32]string{
	0:      "INVALID_ARRAY_DATA_TYPE",
	65568:  "FLOAT32",
	65600:  "DOUBLE",
	131104: "INT32",
}
var ArrayFeatureType_ArrayDataType_value = map[string]int32{
	"INVALID_ARRAY_DATA_TYPE": 0,
	"FLOAT32":                 65568,
	"DOUBLE":                  65600,
	"INT32":                   131104,
}

func (x ArrayFeatureType_ArrayDataType) String() string {
	return proto.EnumName(ArrayFeatureType_ArrayDataType_name, int32(x))
}
func (ArrayFeatureType_ArrayDataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorFeatureTypes, []int{4, 0}
}

// *
// The 64-bit integer feature type.
type Int64FeatureType struct {
}

func (m *Int64FeatureType) Reset()                    { *m = Int64FeatureType{} }
func (m *Int64FeatureType) String() string            { return proto.CompactTextString(m) }
func (*Int64FeatureType) ProtoMessage()               {}
func (*Int64FeatureType) Descriptor() ([]byte, []int) { return fileDescriptorFeatureTypes, []int{0} }

// *
// The double-precision floating point number feature type.
type DoubleFeatureType struct {
}

func (m *DoubleFeatureType) Reset()                    { *m = DoubleFeatureType{} }
func (m *DoubleFeatureType) String() string            { return proto.CompactTextString(m) }
func (*DoubleFeatureType) ProtoMessage()               {}
func (*DoubleFeatureType) Descriptor() ([]byte, []int) { return fileDescriptorFeatureTypes, []int{1} }

// *
// The string feature type.
type StringFeatureType struct {
}

func (m *StringFeatureType) Reset()                    { *m = StringFeatureType{} }
func (m *StringFeatureType) String() string            { return proto.CompactTextString(m) }
func (*StringFeatureType) ProtoMessage()               {}
func (*StringFeatureType) Descriptor() ([]byte, []int) { return fileDescriptorFeatureTypes, []int{2} }

// *
// The image feature type.
type ImageFeatureType struct {
	Width      uint64                      `protobuf:"varint,1,opt,name=width,proto3" json:"width,omitempty"`
	Height     uint64                      `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	ColorSpace ImageFeatureType_ColorSpace `protobuf:"varint,3,opt,name=colorSpace,proto3,enum=CoreML.ImageFeatureType_ColorSpace" json:"colorSpace,omitempty"`
}

func (m *ImageFeatureType) Reset()                    { *m = ImageFeatureType{} }
func (m *ImageFeatureType) String() string            { return proto.CompactTextString(m) }
func (*ImageFeatureType) ProtoMessage()               {}
func (*ImageFeatureType) Descriptor() ([]byte, []int) { return fileDescriptorFeatureTypes, []int{3} }

func (m *ImageFeatureType) GetWidth() uint64 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *ImageFeatureType) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ImageFeatureType) GetColorSpace() ImageFeatureType_ColorSpace {
	if m != nil {
		return m.ColorSpace
	}
	return ImageFeatureType_INVALID_COLOR_SPACE
}

// *
// The array feature type.
type ArrayFeatureType struct {
	Shape []uint64 `protobuf:"varint,1,rep,packed,name=shape" json:"shape,omitempty"`
	// / representing input shape [C] or [C,H,W],
	// / respectively.
	DataType ArrayFeatureType_ArrayDataType `protobuf:"varint,2,opt,name=dataType,proto3,enum=CoreML.ArrayFeatureType_ArrayDataType" json:"dataType,omitempty"`
}

func (m *ArrayFeatureType) Reset()                    { *m = ArrayFeatureType{} }
func (m *ArrayFeatureType) String() string            { return proto.CompactTextString(m) }
func (*ArrayFeatureType) ProtoMessage()               {}
func (*ArrayFeatureType) Descriptor() ([]byte, []int) { return fileDescriptorFeatureTypes, []int{4} }

func (m *ArrayFeatureType) GetShape() []uint64 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *ArrayFeatureType) GetDataType() ArrayFeatureType_ArrayDataType {
	if m != nil {
		return m.DataType
	}
	return ArrayFeatureType_INVALID_ARRAY_DATA_TYPE
}

// *
// The dictionary feature type.
type DictionaryFeatureType struct {
	// *
	//  Key/value type tags, with the following restrictions:
	//  - ``keyType`` must be a hashable type
	//  - ``valueType`` is assumed to be a ``double``
	//
	// Types that are valid to be assigned to KeyType:
	//	*DictionaryFeatureType_Int64KeyType
	//	*DictionaryFeatureType_StringKeyType
	KeyType isDictionaryFeatureType_KeyType `protobuf_oneof:"KeyType"`
}

func (m *DictionaryFeatureType) Reset()         { *m = DictionaryFeatureType{} }
func (m *DictionaryFeatureType) String() string { return proto.CompactTextString(m) }
func (*DictionaryFeatureType) ProtoMessage()    {}
func (*DictionaryFeatureType) Descriptor() ([]byte, []int) {
	return fileDescriptorFeatureTypes, []int{5}
}

type isDictionaryFeatureType_KeyType interface {
	isDictionaryFeatureType_KeyType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DictionaryFeatureType_Int64KeyType struct {
	Int64KeyType *Int64FeatureType `protobuf:"bytes,1,opt,name=int64KeyType,oneof"`
}
type DictionaryFeatureType_StringKeyType struct {
	StringKeyType *StringFeatureType `protobuf:"bytes,2,opt,name=stringKeyType,oneof"`
}

func (*DictionaryFeatureType_Int64KeyType) isDictionaryFeatureType_KeyType()  {}
func (*DictionaryFeatureType_StringKeyType) isDictionaryFeatureType_KeyType() {}

func (m *DictionaryFeatureType) GetKeyType() isDictionaryFeatureType_KeyType {
	if m != nil {
		return m.KeyType
	}
	return nil
}

func (m *DictionaryFeatureType) GetInt64KeyType() *Int64FeatureType {
	if x, ok := m.GetKeyType().(*DictionaryFeatureType_Int64KeyType); ok {
		return x.Int64KeyType
	}
	return nil
}

func (m *DictionaryFeatureType) GetStringKeyType() *StringFeatureType {
	if x, ok := m.GetKeyType().(*DictionaryFeatureType_StringKeyType); ok {
		return x.StringKeyType
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DictionaryFeatureType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DictionaryFeatureType_OneofMarshaler, _DictionaryFeatureType_OneofUnmarshaler, _DictionaryFeatureType_OneofSizer, []interface{}{
		(*DictionaryFeatureType_Int64KeyType)(nil),
		(*DictionaryFeatureType_StringKeyType)(nil),
	}
}

func _DictionaryFeatureType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DictionaryFeatureType)
	// KeyType
	switch x := m.KeyType.(type) {
	case *DictionaryFeatureType_Int64KeyType:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Int64KeyType); err != nil {
			return err
		}
	case *DictionaryFeatureType_StringKeyType:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StringKeyType); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DictionaryFeatureType.KeyType has unexpected type %T", x)
	}
	return nil
}

func _DictionaryFeatureType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DictionaryFeatureType)
	switch tag {
	case 1: // KeyType.int64KeyType
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Int64FeatureType)
		err := b.DecodeMessage(msg)
		m.KeyType = &DictionaryFeatureType_Int64KeyType{msg}
		return true, err
	case 2: // KeyType.stringKeyType
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringFeatureType)
		err := b.DecodeMessage(msg)
		m.KeyType = &DictionaryFeatureType_StringKeyType{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DictionaryFeatureType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DictionaryFeatureType)
	// KeyType
	switch x := m.KeyType.(type) {
	case *DictionaryFeatureType_Int64KeyType:
		s := proto.Size(x.Int64KeyType)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DictionaryFeatureType_StringKeyType:
		s := proto.Size(x.StringKeyType)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// A feature, which may be optional.
type FeatureType struct {
	// Types that are valid to be assigned to Type:
	//	*FeatureType_Int64Type
	//	*FeatureType_DoubleType
	//	*FeatureType_StringType
	//	*FeatureType_ImageType
	//	*FeatureType_MultiArrayType
	//	*FeatureType_DictionaryType
	Type       isFeatureType_Type `protobuf_oneof:"Type"`
	IsOptional bool               `protobuf:"varint,1000,opt,name=isOptional,proto3" json:"isOptional,omitempty"`
}

func (m *FeatureType) Reset()                    { *m = FeatureType{} }
func (m *FeatureType) String() string            { return proto.CompactTextString(m) }
func (*FeatureType) ProtoMessage()               {}
func (*FeatureType) Descriptor() ([]byte, []int) { return fileDescriptorFeatureTypes, []int{6} }

type isFeatureType_Type interface {
	isFeatureType_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FeatureType_Int64Type struct {
	Int64Type *Int64FeatureType `protobuf:"bytes,1,opt,name=int64Type,oneof"`
}
type FeatureType_DoubleType struct {
	DoubleType *DoubleFeatureType `protobuf:"bytes,2,opt,name=doubleType,oneof"`
}
type FeatureType_StringType struct {
	StringType *StringFeatureType `protobuf:"bytes,3,opt,name=stringType,oneof"`
}
type FeatureType_ImageType struct {
	ImageType *ImageFeatureType `protobuf:"bytes,4,opt,name=imageType,oneof"`
}
type FeatureType_MultiArrayType struct {
	MultiArrayType *ArrayFeatureType `protobuf:"bytes,5,opt,name=multiArrayType,oneof"`
}
type FeatureType_DictionaryType struct {
	DictionaryType *DictionaryFeatureType `protobuf:"bytes,6,opt,name=dictionaryType,oneof"`
}

func (*FeatureType_Int64Type) isFeatureType_Type()      {}
func (*FeatureType_DoubleType) isFeatureType_Type()     {}
func (*FeatureType_StringType) isFeatureType_Type()     {}
func (*FeatureType_ImageType) isFeatureType_Type()      {}
func (*FeatureType_MultiArrayType) isFeatureType_Type() {}
func (*FeatureType_DictionaryType) isFeatureType_Type() {}

func (m *FeatureType) GetType() isFeatureType_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *FeatureType) GetInt64Type() *Int64FeatureType {
	if x, ok := m.GetType().(*FeatureType_Int64Type); ok {
		return x.Int64Type
	}
	return nil
}

func (m *FeatureType) GetDoubleType() *DoubleFeatureType {
	if x, ok := m.GetType().(*FeatureType_DoubleType); ok {
		return x.DoubleType
	}
	return nil
}

func (m *FeatureType) GetStringType() *StringFeatureType {
	if x, ok := m.GetType().(*FeatureType_StringType); ok {
		return x.StringType
	}
	return nil
}

func (m *FeatureType) GetImageType() *ImageFeatureType {
	if x, ok := m.GetType().(*FeatureType_ImageType); ok {
		return x.ImageType
	}
	return nil
}

func (m *FeatureType) GetMultiArrayType() *ArrayFeatureType {
	if x, ok := m.GetType().(*FeatureType_MultiArrayType); ok {
		return x.MultiArrayType
	}
	return nil
}

func (m *FeatureType) GetDictionaryType() *DictionaryFeatureType {
	if x, ok := m.GetType().(*FeatureType_DictionaryType); ok {
		return x.DictionaryType
	}
	return nil
}

func (m *FeatureType) GetIsOptional() bool {
	if m != nil {
		return m.IsOptional
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FeatureType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FeatureType_OneofMarshaler, _FeatureType_OneofUnmarshaler, _FeatureType_OneofSizer, []interface{}{
		(*FeatureType_Int64Type)(nil),
		(*FeatureType_DoubleType)(nil),
		(*FeatureType_StringType)(nil),
		(*FeatureType_ImageType)(nil),
		(*FeatureType_MultiArrayType)(nil),
		(*FeatureType_DictionaryType)(nil),
	}
}

func _FeatureType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FeatureType)
	// Type
	switch x := m.Type.(type) {
	case *FeatureType_Int64Type:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Int64Type); err != nil {
			return err
		}
	case *FeatureType_DoubleType:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DoubleType); err != nil {
			return err
		}
	case *FeatureType_StringType:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StringType); err != nil {
			return err
		}
	case *FeatureType_ImageType:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImageType); err != nil {
			return err
		}
	case *FeatureType_MultiArrayType:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MultiArrayType); err != nil {
			return err
		}
	case *FeatureType_DictionaryType:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DictionaryType); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FeatureType.Type has unexpected type %T", x)
	}
	return nil
}

func _FeatureType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FeatureType)
	switch tag {
	case 1: // Type.int64Type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Int64FeatureType)
		err := b.DecodeMessage(msg)
		m.Type = &FeatureType_Int64Type{msg}
		return true, err
	case 2: // Type.doubleType
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DoubleFeatureType)
		err := b.DecodeMessage(msg)
		m.Type = &FeatureType_DoubleType{msg}
		return true, err
	case 3: // Type.stringType
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringFeatureType)
		err := b.DecodeMessage(msg)
		m.Type = &FeatureType_StringType{msg}
		return true, err
	case 4: // Type.imageType
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageFeatureType)
		err := b.DecodeMessage(msg)
		m.Type = &FeatureType_ImageType{msg}
		return true, err
	case 5: // Type.multiArrayType
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ArrayFeatureType)
		err := b.DecodeMessage(msg)
		m.Type = &FeatureType_MultiArrayType{msg}
		return true, err
	case 6: // Type.dictionaryType
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DictionaryFeatureType)
		err := b.DecodeMessage(msg)
		m.Type = &FeatureType_DictionaryType{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FeatureType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FeatureType)
	// Type
	switch x := m.Type.(type) {
	case *FeatureType_Int64Type:
		s := proto.Size(x.Int64Type)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FeatureType_DoubleType:
		s := proto.Size(x.DoubleType)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FeatureType_StringType:
		s := proto.Size(x.StringType)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FeatureType_ImageType:
		s := proto.Size(x.ImageType)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FeatureType_MultiArrayType:
		s := proto.Size(x.MultiArrayType)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FeatureType_DictionaryType:
		s := proto.Size(x.DictionaryType)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Int64FeatureType)(nil), "CoreML.Int64FeatureType")
	proto.RegisterType((*DoubleFeatureType)(nil), "CoreML.DoubleFeatureType")
	proto.RegisterType((*StringFeatureType)(nil), "CoreML.StringFeatureType")
	proto.RegisterType((*ImageFeatureType)(nil), "CoreML.ImageFeatureType")
	proto.RegisterType((*ArrayFeatureType)(nil), "CoreML.ArrayFeatureType")
	proto.RegisterType((*DictionaryFeatureType)(nil), "CoreML.DictionaryFeatureType")
	proto.RegisterType((*FeatureType)(nil), "CoreML.FeatureType")
	proto.RegisterEnum("CoreML.ImageFeatureType_ColorSpace", ImageFeatureType_ColorSpace_name, ImageFeatureType_ColorSpace_value)
	proto.RegisterEnum("CoreML.ArrayFeatureType_ArrayDataType", ArrayFeatureType_ArrayDataType_name, ArrayFeatureType_ArrayDataType_value)
}
func (m *Int64FeatureType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int64FeatureType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DoubleFeatureType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleFeatureType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StringFeatureType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringFeatureType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ImageFeatureType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageFeatureType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(m.Height))
	}
	if m.ColorSpace != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(m.ColorSpace))
	}
	return i, nil
}

func (m *ArrayFeatureType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArrayFeatureType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Shape) > 0 {
		dAtA2 := make([]byte, len(m.Shape)*10)
		var j1 int
		for _, num := range m.Shape {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.DataType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(m.DataType))
	}
	return i, nil
}

func (m *DictionaryFeatureType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DictionaryFeatureType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyType != nil {
		nn3, err := m.KeyType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *DictionaryFeatureType_Int64KeyType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Int64KeyType != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(m.Int64KeyType.Size()))
		n4, err := m.Int64KeyType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *DictionaryFeatureType_StringKeyType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StringKeyType != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(m.StringKeyType.Size()))
		n5, err := m.StringKeyType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *FeatureType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		nn6, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	if m.IsOptional {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x3e
		i++
		if m.IsOptional {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FeatureType_Int64Type) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Int64Type != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(m.Int64Type.Size()))
		n7, err := m.Int64Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *FeatureType_DoubleType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DoubleType != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(m.DoubleType.Size()))
		n8, err := m.DoubleType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *FeatureType_StringType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StringType != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(m.StringType.Size()))
		n9, err := m.StringType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *FeatureType_ImageType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ImageType != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(m.ImageType.Size()))
		n10, err := m.ImageType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *FeatureType_MultiArrayType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.MultiArrayType != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(m.MultiArrayType.Size()))
		n11, err := m.MultiArrayType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *FeatureType_DictionaryType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DictionaryType != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFeatureTypes(dAtA, i, uint64(m.DictionaryType.Size()))
		n12, err := m.DictionaryType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func encodeFixed64FeatureTypes(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32FeatureTypes(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintFeatureTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Int64FeatureType) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DoubleFeatureType) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *StringFeatureType) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ImageFeatureType) Size() (n int) {
	var l int
	_ = l
	if m.Width != 0 {
		n += 1 + sovFeatureTypes(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovFeatureTypes(uint64(m.Height))
	}
	if m.ColorSpace != 0 {
		n += 1 + sovFeatureTypes(uint64(m.ColorSpace))
	}
	return n
}

func (m *ArrayFeatureType) Size() (n int) {
	var l int
	_ = l
	if len(m.Shape) > 0 {
		l = 0
		for _, e := range m.Shape {
			l += sovFeatureTypes(uint64(e))
		}
		n += 1 + sovFeatureTypes(uint64(l)) + l
	}
	if m.DataType != 0 {
		n += 1 + sovFeatureTypes(uint64(m.DataType))
	}
	return n
}

func (m *DictionaryFeatureType) Size() (n int) {
	var l int
	_ = l
	if m.KeyType != nil {
		n += m.KeyType.Size()
	}
	return n
}

func (m *DictionaryFeatureType_Int64KeyType) Size() (n int) {
	var l int
	_ = l
	if m.Int64KeyType != nil {
		l = m.Int64KeyType.Size()
		n += 1 + l + sovFeatureTypes(uint64(l))
	}
	return n
}
func (m *DictionaryFeatureType_StringKeyType) Size() (n int) {
	var l int
	_ = l
	if m.StringKeyType != nil {
		l = m.StringKeyType.Size()
		n += 1 + l + sovFeatureTypes(uint64(l))
	}
	return n
}
func (m *FeatureType) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	if m.IsOptional {
		n += 3
	}
	return n
}

func (m *FeatureType_Int64Type) Size() (n int) {
	var l int
	_ = l
	if m.Int64Type != nil {
		l = m.Int64Type.Size()
		n += 1 + l + sovFeatureTypes(uint64(l))
	}
	return n
}
func (m *FeatureType_DoubleType) Size() (n int) {
	var l int
	_ = l
	if m.DoubleType != nil {
		l = m.DoubleType.Size()
		n += 1 + l + sovFeatureTypes(uint64(l))
	}
	return n
}
func (m *FeatureType_StringType) Size() (n int) {
	var l int
	_ = l
	if m.StringType != nil {
		l = m.StringType.Size()
		n += 1 + l + sovFeatureTypes(uint64(l))
	}
	return n
}
func (m *FeatureType_ImageType) Size() (n int) {
	var l int
	_ = l
	if m.ImageType != nil {
		l = m.ImageType.Size()
		n += 1 + l + sovFeatureTypes(uint64(l))
	}
	return n
}
func (m *FeatureType_MultiArrayType) Size() (n int) {
	var l int
	_ = l
	if m.MultiArrayType != nil {
		l = m.MultiArrayType.Size()
		n += 1 + l + sovFeatureTypes(uint64(l))
	}
	return n
}
func (m *FeatureType_DictionaryType) Size() (n int) {
	var l int
	_ = l
	if m.DictionaryType != nil {
		l = m.DictionaryType.Size()
		n += 1 + l + sovFeatureTypes(uint64(l))
	}
	return n
}

func sovFeatureTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFeatureTypes(x uint64) (n int) {
	return sovFeatureTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Int64FeatureType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFeatureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int64FeatureType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int64FeatureType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFeatureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleFeatureType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFeatureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleFeatureType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleFeatureType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFeatureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringFeatureType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFeatureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringFeatureType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringFeatureType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFeatureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageFeatureType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFeatureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageFeatureType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageFeatureType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorSpace", wireType)
			}
			m.ColorSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColorSpace |= (ImageFeatureType_ColorSpace(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFeatureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArrayFeatureType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFeatureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArrayFeatureType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArrayFeatureType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFeatureTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Shape = append(m.Shape, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFeatureTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFeatureTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFeatureTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Shape = append(m.Shape, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= (ArrayFeatureType_ArrayDataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFeatureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DictionaryFeatureType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFeatureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DictionaryFeatureType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DictionaryFeatureType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64KeyType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Int64FeatureType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.KeyType = &DictionaryFeatureType_Int64KeyType{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringKeyType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringFeatureType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.KeyType = &DictionaryFeatureType_StringKeyType{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFeatureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFeatureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Int64FeatureType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &FeatureType_Int64Type{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DoubleFeatureType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &FeatureType_DoubleType{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringFeatureType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &FeatureType_StringType{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ImageFeatureType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &FeatureType_ImageType{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiArrayType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ArrayFeatureType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &FeatureType_MultiArrayType{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DictionaryType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DictionaryFeatureType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &FeatureType_DictionaryType{v}
			iNdEx = postIndex
		case 1000:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOptional", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOptional = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFeatureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFeatureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFeatureTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFeatureTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFeatureTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFeatureTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFeatureTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFeatureTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFeatureTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFeatureTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("FeatureTypes.proto", fileDescriptorFeatureTypes) }

var fileDescriptorFeatureTypes = []byte{
	// 555 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xcd, 0x8a, 0xd3, 0x50,
	0x18, 0xcd, 0x9d, 0xb4, 0x69, 0xfb, 0x75, 0x5a, 0xe2, 0x9d, 0xd1, 0x89, 0x88, 0xb5, 0x44, 0x90,
	0xae, 0xba, 0xe8, 0x88, 0x08, 0x82, 0x70, 0x93, 0xf4, 0x27, 0x18, 0x27, 0xc3, 0x6d, 0x1d, 0xe8,
	0xaa, 0x64, 0xda, 0xd0, 0x06, 0x3a, 0x4d, 0x48, 0x53, 0xa4, 0xbb, 0x79, 0x04, 0x1f, 0xc1, 0x8d,
	0x0f, 0xe0, 0x1b, 0xb8, 0x70, 0xe1, 0x46, 0xf0, 0x11, 0xa4, 0x6e, 0x7c, 0x0c, 0xc9, 0x4d, 0x93,
	0x49, 0x32, 0x03, 0xce, 0xee, 0xde, 0xef, 0x9e, 0x73, 0x7a, 0x4e, 0xbf, 0x43, 0x00, 0xf7, 0x6c,
	0x2b, 0xd8, 0xf8, 0xf6, 0x68, 0xeb, 0xd9, 0xeb, 0xb6, 0xe7, 0xbb, 0x81, 0x8b, 0x05, 0xd5, 0xf5,
	0xed, 0xf7, 0x86, 0x8c, 0x41, 0xd4, 0x57, 0xc1, 0xab, 0x97, 0x29, 0x88, 0x7c, 0x04, 0x0f, 0x34,
	0x77, 0x73, 0xb9, 0xb4, 0x73, 0xc3, 0x61, 0xe0, 0x3b, 0xab, 0x79, 0x7a, 0xf8, 0x13, 0x81, 0xa8,
	0x5f, 0x59, 0xf3, 0x34, 0x12, 0x1f, 0x43, 0xf1, 0xa3, 0x33, 0x0b, 0x16, 0x12, 0x6a, 0xa2, 0x56,
	0x81, 0x46, 0x17, 0xfc, 0x08, 0x84, 0x85, 0xed, 0xcc, 0x17, 0x81, 0x74, 0xc0, 0xc6, 0xfb, 0x1b,
	0x56, 0x01, 0xa6, 0xee, 0xd2, 0xf5, 0x87, 0x9e, 0x35, 0xb5, 0x25, 0xbe, 0x89, 0x5a, 0xf5, 0xce,
	0xf3, 0x76, 0xe4, 0xae, 0x9d, 0xd7, 0x6e, 0xab, 0x09, 0x94, 0xa6, 0x68, 0x72, 0x0f, 0xe0, 0xe6,
	0x05, 0x9f, 0xc0, 0x91, 0x7e, 0x76, 0x41, 0x0c, 0x5d, 0x9b, 0xa8, 0xa6, 0x61, 0xd2, 0xc9, 0xf0,
	0x9c, 0xa8, 0x5d, 0x91, 0xc3, 0x35, 0xa8, 0xf4, 0x29, 0x19, 0x0f, 0x55, 0x62, 0x74, 0x45, 0xc0,
	0x25, 0xe0, 0x69, 0x5f, 0x11, 0x8f, 0xc3, 0x83, 0xd2, 0xa7, 0x62, 0x43, 0xfe, 0x8e, 0x40, 0x24,
	0xbe, 0x6f, 0x6d, 0x73, 0x79, 0xd6, 0x0b, 0xcb, 0xb3, 0x25, 0xd4, 0xe4, 0xc3, 0x3c, 0xec, 0x82,
	0x15, 0x28, 0xcf, 0xac, 0xc0, 0x0a, 0x11, 0x2c, 0x51, 0xbd, 0xf3, 0x22, 0x76, 0x9d, 0x57, 0x88,
	0x06, 0xda, 0x1e, 0x4d, 0x13, 0x9e, 0x7c, 0x01, 0xb5, 0xcc, 0x13, 0x7e, 0x02, 0x27, 0xb1, 0x73,
	0x42, 0x29, 0x19, 0x4f, 0x34, 0x32, 0x22, 0x93, 0xd1, 0xf8, 0x3c, 0x72, 0x5f, 0xea, 0x19, 0x26,
	0x19, 0x9d, 0x76, 0xc4, 0xcf, 0xd7, 0x05, 0x7c, 0x08, 0x82, 0x66, 0x7e, 0x50, 0x8c, 0xae, 0xf8,
	0xed, 0xba, 0x80, 0xab, 0x50, 0xd4, 0xcf, 0xa2, 0xa7, 0xb2, 0xfc, 0x05, 0xc1, 0x43, 0xcd, 0x99,
	0x06, 0x8e, 0xbb, 0xb2, 0xfc, 0x4c, 0x96, 0xb7, 0x70, 0xe8, 0x84, 0xeb, 0x7e, 0x67, 0x6f, 0x99,
	0xf3, 0x70, 0x45, 0xd5, 0x8e, 0x94, 0xfc, 0xdf, 0xb9, 0x2a, 0x0c, 0x38, 0x9a, 0xc1, 0x63, 0x02,
	0xb5, 0x35, 0x6b, 0x41, 0x2c, 0x70, 0xc0, 0x04, 0x1e, 0xc7, 0x02, 0xb7, 0x2a, 0x32, 0xe0, 0x68,
	0x96, 0xa1, 0x54, 0xa0, 0xb4, 0x3f, 0xca, 0x5f, 0x79, 0xa8, 0xa6, 0xdd, 0xbd, 0x86, 0x0a, 0xfb,
	0xb5, 0x7b, 0x5a, 0xbb, 0x01, 0xe3, 0x37, 0x00, 0x33, 0x56, 0xd9, 0xbb, 0x4c, 0xdd, 0x2a, 0xf3,
	0x80, 0xa3, 0x29, 0x78, 0x48, 0x8e, 0x2c, 0x32, 0x32, 0xff, 0xff, 0x44, 0x29, 0x38, 0xf3, 0x1c,
	0xb6, 0x94, 0x71, 0x0b, 0x39, 0xcf, 0xb9, 0xfa, 0x32, 0xcf, 0x31, 0x18, 0x2b, 0x50, 0xbf, 0xda,
	0x2c, 0x03, 0x87, 0x55, 0x80, 0xd1, 0x8b, 0x59, 0x7a, 0xbe, 0x47, 0x03, 0x8e, 0xe6, 0x18, 0xb8,
	0x0f, 0xf5, 0x59, 0xb2, 0x68, 0xa6, 0x21, 0x30, 0x8d, 0xa7, 0x49, 0xf6, 0xbb, 0x6a, 0x10, 0x0a,
	0x65, 0x69, 0xf8, 0x19, 0x80, 0xb3, 0x36, 0x3d, 0x36, 0x5a, 0x4a, 0x7f, 0x4b, 0x4d, 0xd4, 0x2a,
	0xd3, 0xd4, 0x48, 0x11, 0xa0, 0xc0, 0xd6, 0x87, 0x7f, 0xec, 0x1a, 0xe8, 0xd7, 0xae, 0x81, 0x7e,
	0xef, 0x1a, 0xe8, 0xd3, 0x9f, 0x06, 0x37, 0xe0, 0x2f, 0x05, 0xf6, 0x4d, 0x39, 0xfd, 0x17, 0x00,
	0x00, 0xff, 0xff, 0x9d, 0xdb, 0x6d, 0x3a, 0x69, 0x04, 0x00, 0x00,
}
