// Code generated by protoc-gen-gogo.
// source: TreeEnsemble.proto
// DO NOT EDIT!

package CoreML

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Ignoring public import of StringToInt64Map from DataStructures.proto

// Ignoring public import of Int64ToStringMap from DataStructures.proto

// Ignoring public import of StringToDoubleMap from DataStructures.proto

// Ignoring public import of Int64ToDoubleMap from DataStructures.proto

// Ignoring public import of StringVector from DataStructures.proto

// Ignoring public import of Int64Vector from DataStructures.proto

// Ignoring public import of DoubleVector from DataStructures.proto

// *
// A tree ensemble post-evaluation transform.
type TreeEnsemblePostEvaluationTransform int32

const (
	TreeEnsemblePostEvaluationTransform_NoTransform                                  TreeEnsemblePostEvaluationTransform = 0
	TreeEnsemblePostEvaluationTransform_Classification_SoftMax                       TreeEnsemblePostEvaluationTransform = 1
	TreeEnsemblePostEvaluationTransform_Regression_Logistic                          TreeEnsemblePostEvaluationTransform = 2
	TreeEnsemblePostEvaluationTransform_Classification_SoftMaxWithZeroClassReference TreeEnsemblePostEvaluationTransform = 3
)

var TreeEnsemblePostEvaluationTransform_name = map[int32]string{
	0: "NoTransform",
	1: "Classification_SoftMax",
	2: "Regression_Logistic",
	3: "Classification_SoftMaxWithZeroClassReference",
}
var TreeEnsemblePostEvaluationTransform_value = map[string]int32{
	"NoTransform":                                  0,
	"Classification_SoftMax":                       1,
	"Regression_Logistic":                          2,
	"Classification_SoftMaxWithZeroClassReference": 3,
}

func (x TreeEnsemblePostEvaluationTransform) String() string {
	return proto.EnumName(TreeEnsemblePostEvaluationTransform_name, int32(x))
}
func (TreeEnsemblePostEvaluationTransform) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTreeEnsemble, []int{0}
}

type TreeEnsembleParameters_TreeNode_TreeNodeBehavior int32

const (
	TreeEnsembleParameters_TreeNode_BranchOnValueLessThanEqual    TreeEnsembleParameters_TreeNode_TreeNodeBehavior = 0
	TreeEnsembleParameters_TreeNode_BranchOnValueLessThan         TreeEnsembleParameters_TreeNode_TreeNodeBehavior = 1
	TreeEnsembleParameters_TreeNode_BranchOnValueGreaterThanEqual TreeEnsembleParameters_TreeNode_TreeNodeBehavior = 2
	TreeEnsembleParameters_TreeNode_BranchOnValueGreaterThan      TreeEnsembleParameters_TreeNode_TreeNodeBehavior = 3
	TreeEnsembleParameters_TreeNode_BranchOnValueEqual            TreeEnsembleParameters_TreeNode_TreeNodeBehavior = 4
	TreeEnsembleParameters_TreeNode_BranchOnValueNotEqual         TreeEnsembleParameters_TreeNode_TreeNodeBehavior = 5
	TreeEnsembleParameters_TreeNode_LeafNode                      TreeEnsembleParameters_TreeNode_TreeNodeBehavior = 6
)

var TreeEnsembleParameters_TreeNode_TreeNodeBehavior_name = map[int32]string{
	0: "BranchOnValueLessThanEqual",
	1: "BranchOnValueLessThan",
	2: "BranchOnValueGreaterThanEqual",
	3: "BranchOnValueGreaterThan",
	4: "BranchOnValueEqual",
	5: "BranchOnValueNotEqual",
	6: "LeafNode",
}
var TreeEnsembleParameters_TreeNode_TreeNodeBehavior_value = map[string]int32{
	"BranchOnValueLessThanEqual":    0,
	"BranchOnValueLessThan":         1,
	"BranchOnValueGreaterThanEqual": 2,
	"BranchOnValueGreaterThan":      3,
	"BranchOnValueEqual":            4,
	"BranchOnValueNotEqual":         5,
	"LeafNode":                      6,
}

func (x TreeEnsembleParameters_TreeNode_TreeNodeBehavior) String() string {
	return proto.EnumName(TreeEnsembleParameters_TreeNode_TreeNodeBehavior_name, int32(x))
}
func (TreeEnsembleParameters_TreeNode_TreeNodeBehavior) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTreeEnsemble, []int{0, 0, 0}
}

// *
// Tree ensemble parameters.
type TreeEnsembleParameters struct {
	Nodes []*TreeEnsembleParameters_TreeNode `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
	// *
	// The number of prediction dimensions or classes in the model.
	//
	// All instances of ``evaluationIndex`` in a leaf node
	// must be less than this value,
	// and the number of values in the ``basePredictionValue`` field
	// must be equal to this value.
	//
	// For regression,
	// this is the dimension of the prediction.
	// For classification,
	// this is the number of classes.
	NumPredictionDimensions uint64 `protobuf:"varint,2,opt,name=numPredictionDimensions,proto3" json:"numPredictionDimensions,omitempty"`
	// *
	// The base prediction value.
	//
	// The number of values in this must match
	// the default values of the tree model.
	BasePredictionValue []float64 `protobuf:"fixed64,3,rep,packed,name=basePredictionValue" json:"basePredictionValue,omitempty"`
}

func (m *TreeEnsembleParameters) Reset()         { *m = TreeEnsembleParameters{} }
func (m *TreeEnsembleParameters) String() string { return proto.CompactTextString(m) }
func (*TreeEnsembleParameters) ProtoMessage()    {}
func (*TreeEnsembleParameters) Descriptor() ([]byte, []int) {
	return fileDescriptorTreeEnsemble, []int{0}
}

func (m *TreeEnsembleParameters) GetNodes() []*TreeEnsembleParameters_TreeNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *TreeEnsembleParameters) GetNumPredictionDimensions() uint64 {
	if m != nil {
		return m.NumPredictionDimensions
	}
	return 0
}

func (m *TreeEnsembleParameters) GetBasePredictionValue() []float64 {
	if m != nil {
		return m.BasePredictionValue
	}
	return nil
}

type TreeEnsembleParameters_TreeNode struct {
	TreeId uint64 `protobuf:"varint,1,opt,name=treeId,proto3" json:"treeId,omitempty"`
	NodeId uint64 `protobuf:"varint,2,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	// *
	// The branch mode parameters.
	//
	// If branch is false,
	// then the parameters in this section must be filled in
	// to determine how the branching functions.
	NodeBehavior TreeEnsembleParameters_TreeNode_TreeNodeBehavior `protobuf:"varint,3,opt,name=nodeBehavior,proto3,enum=CoreML.TreeEnsembleParameters_TreeNode_TreeNodeBehavior" json:"nodeBehavior,omitempty"`
	// *
	// If the node behavior mode is a branch mode,
	// then these values must be filled in.
	BranchFeatureIndex          uint64                                            `protobuf:"varint,10,opt,name=branchFeatureIndex,proto3" json:"branchFeatureIndex,omitempty"`
	BranchFeatureValue          float64                                           `protobuf:"fixed64,11,opt,name=branchFeatureValue,proto3" json:"branchFeatureValue,omitempty"`
	TrueChildNodeId             uint64                                            `protobuf:"varint,12,opt,name=trueChildNodeId,proto3" json:"trueChildNodeId,omitempty"`
	FalseChildNodeId            uint64                                            `protobuf:"varint,13,opt,name=falseChildNodeId,proto3" json:"falseChildNodeId,omitempty"`
	MissingValueTracksTrueChild bool                                              `protobuf:"varint,14,opt,name=missingValueTracksTrueChild,proto3" json:"missingValueTracksTrueChild,omitempty"`
	EvaluationInfo              []*TreeEnsembleParameters_TreeNode_EvaluationInfo `protobuf:"bytes,20,rep,name=evaluationInfo" json:"evaluationInfo,omitempty"`
	// *
	// The relative hit rate of a node for optimization purposes.
	//
	// This value has no effect on the accuracy of the result;
	// it allows the tree to optimize for frequent branches.
	// The value is relative,
	// compared to the hit rates of other branch nodes.
	//
	// You typically use a proportion of training samples
	// that reached this node
	// or some similar metric to derive this value.
	RelativeHitRate float64 `protobuf:"fixed64,30,opt,name=relativeHitRate,proto3" json:"relativeHitRate,omitempty"`
}

func (m *TreeEnsembleParameters_TreeNode) Reset()         { *m = TreeEnsembleParameters_TreeNode{} }
func (m *TreeEnsembleParameters_TreeNode) String() string { return proto.CompactTextString(m) }
func (*TreeEnsembleParameters_TreeNode) ProtoMessage()    {}
func (*TreeEnsembleParameters_TreeNode) Descriptor() ([]byte, []int) {
	return fileDescriptorTreeEnsemble, []int{0, 0}
}

func (m *TreeEnsembleParameters_TreeNode) GetTreeId() uint64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

func (m *TreeEnsembleParameters_TreeNode) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *TreeEnsembleParameters_TreeNode) GetNodeBehavior() TreeEnsembleParameters_TreeNode_TreeNodeBehavior {
	if m != nil {
		return m.NodeBehavior
	}
	return TreeEnsembleParameters_TreeNode_BranchOnValueLessThanEqual
}

func (m *TreeEnsembleParameters_TreeNode) GetBranchFeatureIndex() uint64 {
	if m != nil {
		return m.BranchFeatureIndex
	}
	return 0
}

func (m *TreeEnsembleParameters_TreeNode) GetBranchFeatureValue() float64 {
	if m != nil {
		return m.BranchFeatureValue
	}
	return 0
}

func (m *TreeEnsembleParameters_TreeNode) GetTrueChildNodeId() uint64 {
	if m != nil {
		return m.TrueChildNodeId
	}
	return 0
}

func (m *TreeEnsembleParameters_TreeNode) GetFalseChildNodeId() uint64 {
	if m != nil {
		return m.FalseChildNodeId
	}
	return 0
}

func (m *TreeEnsembleParameters_TreeNode) GetMissingValueTracksTrueChild() bool {
	if m != nil {
		return m.MissingValueTracksTrueChild
	}
	return false
}

func (m *TreeEnsembleParameters_TreeNode) GetEvaluationInfo() []*TreeEnsembleParameters_TreeNode_EvaluationInfo {
	if m != nil {
		return m.EvaluationInfo
	}
	return nil
}

func (m *TreeEnsembleParameters_TreeNode) GetRelativeHitRate() float64 {
	if m != nil {
		return m.RelativeHitRate
	}
	return 0
}

// *
// The leaf mode.
//
// If ``nodeBahavior`` == ``LeafNode``,
// then the evaluationValue is added to the base prediction value
// in order to get the final prediction.
// To support multiclass classification
// as well as regression and binary classification,
// the evaluation value is encoded here as a sparse vector,
// with evaluationIndex being the index of the base vector
// that evaluation value is added to.
// In the single class case,
// it is expected that evaluationIndex is exactly 0.
type TreeEnsembleParameters_TreeNode_EvaluationInfo struct {
	EvaluationIndex uint64  `protobuf:"varint,1,opt,name=evaluationIndex,proto3" json:"evaluationIndex,omitempty"`
	EvaluationValue float64 `protobuf:"fixed64,2,opt,name=evaluationValue,proto3" json:"evaluationValue,omitempty"`
}

func (m *TreeEnsembleParameters_TreeNode_EvaluationInfo) Reset() {
	*m = TreeEnsembleParameters_TreeNode_EvaluationInfo{}
}
func (m *TreeEnsembleParameters_TreeNode_EvaluationInfo) String() string {
	return proto.CompactTextString(m)
}
func (*TreeEnsembleParameters_TreeNode_EvaluationInfo) ProtoMessage() {}
func (*TreeEnsembleParameters_TreeNode_EvaluationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorTreeEnsemble, []int{0, 0, 0}
}

func (m *TreeEnsembleParameters_TreeNode_EvaluationInfo) GetEvaluationIndex() uint64 {
	if m != nil {
		return m.EvaluationIndex
	}
	return 0
}

func (m *TreeEnsembleParameters_TreeNode_EvaluationInfo) GetEvaluationValue() float64 {
	if m != nil {
		return m.EvaluationValue
	}
	return 0
}

// *
// A tree ensemble classifier.
type TreeEnsembleClassifier struct {
	TreeEnsemble            *TreeEnsembleParameters             `protobuf:"bytes,1,opt,name=treeEnsemble" json:"treeEnsemble,omitempty"`
	PostEvaluationTransform TreeEnsemblePostEvaluationTransform `protobuf:"varint,2,opt,name=postEvaluationTransform,proto3,enum=CoreML.TreeEnsemblePostEvaluationTransform" json:"postEvaluationTransform,omitempty"`
	// Required class label mapping
	//
	// Types that are valid to be assigned to ClassLabels:
	//	*TreeEnsembleClassifier_StringClassLabels
	//	*TreeEnsembleClassifier_Int64ClassLabels
	ClassLabels isTreeEnsembleClassifier_ClassLabels `protobuf_oneof:"ClassLabels"`
}

func (m *TreeEnsembleClassifier) Reset()         { *m = TreeEnsembleClassifier{} }
func (m *TreeEnsembleClassifier) String() string { return proto.CompactTextString(m) }
func (*TreeEnsembleClassifier) ProtoMessage()    {}
func (*TreeEnsembleClassifier) Descriptor() ([]byte, []int) {
	return fileDescriptorTreeEnsemble, []int{1}
}

type isTreeEnsembleClassifier_ClassLabels interface {
	isTreeEnsembleClassifier_ClassLabels()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TreeEnsembleClassifier_StringClassLabels struct {
	StringClassLabels *StringVector `protobuf:"bytes,100,opt,name=stringClassLabels,oneof"`
}
type TreeEnsembleClassifier_Int64ClassLabels struct {
	Int64ClassLabels *Int64Vector `protobuf:"bytes,101,opt,name=int64ClassLabels,oneof"`
}

func (*TreeEnsembleClassifier_StringClassLabels) isTreeEnsembleClassifier_ClassLabels() {}
func (*TreeEnsembleClassifier_Int64ClassLabels) isTreeEnsembleClassifier_ClassLabels()  {}

func (m *TreeEnsembleClassifier) GetClassLabels() isTreeEnsembleClassifier_ClassLabels {
	if m != nil {
		return m.ClassLabels
	}
	return nil
}

func (m *TreeEnsembleClassifier) GetTreeEnsemble() *TreeEnsembleParameters {
	if m != nil {
		return m.TreeEnsemble
	}
	return nil
}

func (m *TreeEnsembleClassifier) GetPostEvaluationTransform() TreeEnsemblePostEvaluationTransform {
	if m != nil {
		return m.PostEvaluationTransform
	}
	return TreeEnsemblePostEvaluationTransform_NoTransform
}

func (m *TreeEnsembleClassifier) GetStringClassLabels() *StringVector {
	if x, ok := m.GetClassLabels().(*TreeEnsembleClassifier_StringClassLabels); ok {
		return x.StringClassLabels
	}
	return nil
}

func (m *TreeEnsembleClassifier) GetInt64ClassLabels() *Int64Vector {
	if x, ok := m.GetClassLabels().(*TreeEnsembleClassifier_Int64ClassLabels); ok {
		return x.Int64ClassLabels
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TreeEnsembleClassifier) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TreeEnsembleClassifier_OneofMarshaler, _TreeEnsembleClassifier_OneofUnmarshaler, _TreeEnsembleClassifier_OneofSizer, []interface{}{
		(*TreeEnsembleClassifier_StringClassLabels)(nil),
		(*TreeEnsembleClassifier_Int64ClassLabels)(nil),
	}
}

func _TreeEnsembleClassifier_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TreeEnsembleClassifier)
	// ClassLabels
	switch x := m.ClassLabels.(type) {
	case *TreeEnsembleClassifier_StringClassLabels:
		_ = b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StringClassLabels); err != nil {
			return err
		}
	case *TreeEnsembleClassifier_Int64ClassLabels:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Int64ClassLabels); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TreeEnsembleClassifier.ClassLabels has unexpected type %T", x)
	}
	return nil
}

func _TreeEnsembleClassifier_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TreeEnsembleClassifier)
	switch tag {
	case 100: // ClassLabels.stringClassLabels
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringVector)
		err := b.DecodeMessage(msg)
		m.ClassLabels = &TreeEnsembleClassifier_StringClassLabels{msg}
		return true, err
	case 101: // ClassLabels.int64ClassLabels
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Int64Vector)
		err := b.DecodeMessage(msg)
		m.ClassLabels = &TreeEnsembleClassifier_Int64ClassLabels{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TreeEnsembleClassifier_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TreeEnsembleClassifier)
	// ClassLabels
	switch x := m.ClassLabels.(type) {
	case *TreeEnsembleClassifier_StringClassLabels:
		s := proto.Size(x.StringClassLabels)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TreeEnsembleClassifier_Int64ClassLabels:
		s := proto.Size(x.Int64ClassLabels)
		n += proto.SizeVarint(101<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// A tree ensemble regressor.
type TreeEnsembleRegressor struct {
	TreeEnsemble            *TreeEnsembleParameters             `protobuf:"bytes,1,opt,name=treeEnsemble" json:"treeEnsemble,omitempty"`
	PostEvaluationTransform TreeEnsemblePostEvaluationTransform `protobuf:"varint,2,opt,name=postEvaluationTransform,proto3,enum=CoreML.TreeEnsemblePostEvaluationTransform" json:"postEvaluationTransform,omitempty"`
}

func (m *TreeEnsembleRegressor) Reset()         { *m = TreeEnsembleRegressor{} }
func (m *TreeEnsembleRegressor) String() string { return proto.CompactTextString(m) }
func (*TreeEnsembleRegressor) ProtoMessage()    {}
func (*TreeEnsembleRegressor) Descriptor() ([]byte, []int) {
	return fileDescriptorTreeEnsemble, []int{2}
}

func (m *TreeEnsembleRegressor) GetTreeEnsemble() *TreeEnsembleParameters {
	if m != nil {
		return m.TreeEnsemble
	}
	return nil
}

func (m *TreeEnsembleRegressor) GetPostEvaluationTransform() TreeEnsemblePostEvaluationTransform {
	if m != nil {
		return m.PostEvaluationTransform
	}
	return TreeEnsemblePostEvaluationTransform_NoTransform
}

func init() {
	proto.RegisterType((*TreeEnsembleParameters)(nil), "CoreML.TreeEnsembleParameters")
	proto.RegisterType((*TreeEnsembleParameters_TreeNode)(nil), "CoreML.TreeEnsembleParameters.TreeNode")
	proto.RegisterType((*TreeEnsembleParameters_TreeNode_EvaluationInfo)(nil), "CoreML.TreeEnsembleParameters.TreeNode.EvaluationInfo")
	proto.RegisterType((*TreeEnsembleClassifier)(nil), "CoreML.TreeEnsembleClassifier")
	proto.RegisterType((*TreeEnsembleRegressor)(nil), "CoreML.TreeEnsembleRegressor")
	proto.RegisterEnum("CoreML.TreeEnsemblePostEvaluationTransform", TreeEnsemblePostEvaluationTransform_name, TreeEnsemblePostEvaluationTransform_value)
	proto.RegisterEnum("CoreML.TreeEnsembleParameters_TreeNode_TreeNodeBehavior", TreeEnsembleParameters_TreeNode_TreeNodeBehavior_name, TreeEnsembleParameters_TreeNode_TreeNodeBehavior_value)
}
func (m *TreeEnsembleParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeEnsembleParameters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTreeEnsemble(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NumPredictionDimensions != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.NumPredictionDimensions))
	}
	if len(m.BasePredictionValue) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(len(m.BasePredictionValue)*8))
		for _, num := range m.BasePredictionValue {
			f1 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f1)
			i++
			dAtA[i] = uint8(f1 >> 8)
			i++
			dAtA[i] = uint8(f1 >> 16)
			i++
			dAtA[i] = uint8(f1 >> 24)
			i++
			dAtA[i] = uint8(f1 >> 32)
			i++
			dAtA[i] = uint8(f1 >> 40)
			i++
			dAtA[i] = uint8(f1 >> 48)
			i++
			dAtA[i] = uint8(f1 >> 56)
			i++
		}
	}
	return i, nil
}

func (m *TreeEnsembleParameters_TreeNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeEnsembleParameters_TreeNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.TreeId))
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.NodeId))
	}
	if m.NodeBehavior != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.NodeBehavior))
	}
	if m.BranchFeatureIndex != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.BranchFeatureIndex))
	}
	if m.BranchFeatureValue != 0 {
		dAtA[i] = 0x59
		i++
		i = encodeFixed64TreeEnsemble(dAtA, i, uint64(math.Float64bits(float64(m.BranchFeatureValue))))
	}
	if m.TrueChildNodeId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.TrueChildNodeId))
	}
	if m.FalseChildNodeId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.FalseChildNodeId))
	}
	if m.MissingValueTracksTrueChild {
		dAtA[i] = 0x70
		i++
		if m.MissingValueTracksTrueChild {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.EvaluationInfo) > 0 {
		for _, msg := range m.EvaluationInfo {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTreeEnsemble(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RelativeHitRate != 0 {
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64TreeEnsemble(dAtA, i, uint64(math.Float64bits(float64(m.RelativeHitRate))))
	}
	return i, nil
}

func (m *TreeEnsembleParameters_TreeNode_EvaluationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeEnsembleParameters_TreeNode_EvaluationInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EvaluationIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.EvaluationIndex))
	}
	if m.EvaluationValue != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64TreeEnsemble(dAtA, i, uint64(math.Float64bits(float64(m.EvaluationValue))))
	}
	return i, nil
}

func (m *TreeEnsembleClassifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeEnsembleClassifier) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreeEnsemble != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.TreeEnsemble.Size()))
		n2, err := m.TreeEnsemble.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.PostEvaluationTransform != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.PostEvaluationTransform))
	}
	if m.ClassLabels != nil {
		nn3, err := m.ClassLabels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *TreeEnsembleClassifier_StringClassLabels) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StringClassLabels != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.StringClassLabels.Size()))
		n4, err := m.StringClassLabels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *TreeEnsembleClassifier_Int64ClassLabels) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Int64ClassLabels != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.Int64ClassLabels.Size()))
		n5, err := m.Int64ClassLabels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *TreeEnsembleRegressor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeEnsembleRegressor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreeEnsemble != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.TreeEnsemble.Size()))
		n6, err := m.TreeEnsemble.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.PostEvaluationTransform != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreeEnsemble(dAtA, i, uint64(m.PostEvaluationTransform))
	}
	return i, nil
}

func encodeFixed64TreeEnsemble(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32TreeEnsemble(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTreeEnsemble(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TreeEnsembleParameters) Size() (n int) {
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovTreeEnsemble(uint64(l))
		}
	}
	if m.NumPredictionDimensions != 0 {
		n += 1 + sovTreeEnsemble(uint64(m.NumPredictionDimensions))
	}
	if len(m.BasePredictionValue) > 0 {
		n += 1 + sovTreeEnsemble(uint64(len(m.BasePredictionValue)*8)) + len(m.BasePredictionValue)*8
	}
	return n
}

func (m *TreeEnsembleParameters_TreeNode) Size() (n int) {
	var l int
	_ = l
	if m.TreeId != 0 {
		n += 1 + sovTreeEnsemble(uint64(m.TreeId))
	}
	if m.NodeId != 0 {
		n += 1 + sovTreeEnsemble(uint64(m.NodeId))
	}
	if m.NodeBehavior != 0 {
		n += 1 + sovTreeEnsemble(uint64(m.NodeBehavior))
	}
	if m.BranchFeatureIndex != 0 {
		n += 1 + sovTreeEnsemble(uint64(m.BranchFeatureIndex))
	}
	if m.BranchFeatureValue != 0 {
		n += 9
	}
	if m.TrueChildNodeId != 0 {
		n += 1 + sovTreeEnsemble(uint64(m.TrueChildNodeId))
	}
	if m.FalseChildNodeId != 0 {
		n += 1 + sovTreeEnsemble(uint64(m.FalseChildNodeId))
	}
	if m.MissingValueTracksTrueChild {
		n += 2
	}
	if len(m.EvaluationInfo) > 0 {
		for _, e := range m.EvaluationInfo {
			l = e.Size()
			n += 2 + l + sovTreeEnsemble(uint64(l))
		}
	}
	if m.RelativeHitRate != 0 {
		n += 10
	}
	return n
}

func (m *TreeEnsembleParameters_TreeNode_EvaluationInfo) Size() (n int) {
	var l int
	_ = l
	if m.EvaluationIndex != 0 {
		n += 1 + sovTreeEnsemble(uint64(m.EvaluationIndex))
	}
	if m.EvaluationValue != 0 {
		n += 9
	}
	return n
}

func (m *TreeEnsembleClassifier) Size() (n int) {
	var l int
	_ = l
	if m.TreeEnsemble != nil {
		l = m.TreeEnsemble.Size()
		n += 1 + l + sovTreeEnsemble(uint64(l))
	}
	if m.PostEvaluationTransform != 0 {
		n += 1 + sovTreeEnsemble(uint64(m.PostEvaluationTransform))
	}
	if m.ClassLabels != nil {
		n += m.ClassLabels.Size()
	}
	return n
}

func (m *TreeEnsembleClassifier_StringClassLabels) Size() (n int) {
	var l int
	_ = l
	if m.StringClassLabels != nil {
		l = m.StringClassLabels.Size()
		n += 2 + l + sovTreeEnsemble(uint64(l))
	}
	return n
}
func (m *TreeEnsembleClassifier_Int64ClassLabels) Size() (n int) {
	var l int
	_ = l
	if m.Int64ClassLabels != nil {
		l = m.Int64ClassLabels.Size()
		n += 2 + l + sovTreeEnsemble(uint64(l))
	}
	return n
}
func (m *TreeEnsembleRegressor) Size() (n int) {
	var l int
	_ = l
	if m.TreeEnsemble != nil {
		l = m.TreeEnsemble.Size()
		n += 1 + l + sovTreeEnsemble(uint64(l))
	}
	if m.PostEvaluationTransform != 0 {
		n += 1 + sovTreeEnsemble(uint64(m.PostEvaluationTransform))
	}
	return n
}

func sovTreeEnsemble(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTreeEnsemble(x uint64) (n int) {
	return sovTreeEnsemble(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TreeEnsembleParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeEnsemble
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeEnsembleParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeEnsembleParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeEnsemble
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &TreeEnsembleParameters_TreeNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPredictionDimensions", wireType)
			}
			m.NumPredictionDimensions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPredictionDimensions |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.BasePredictionValue = append(m.BasePredictionValue, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreeEnsemble
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreeEnsemble
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.BasePredictionValue = append(m.BasePredictionValue, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePredictionValue", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreeEnsemble(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeEnsemble
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeEnsembleParameters_TreeNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeEnsemble
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeId", wireType)
			}
			m.TreeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeBehavior", wireType)
			}
			m.NodeBehavior = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeBehavior |= (TreeEnsembleParameters_TreeNode_TreeNodeBehavior(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchFeatureIndex", wireType)
			}
			m.BranchFeatureIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BranchFeatureIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchFeatureValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.BranchFeatureValue = float64(math.Float64frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrueChildNodeId", wireType)
			}
			m.TrueChildNodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrueChildNodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FalseChildNodeId", wireType)
			}
			m.FalseChildNodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FalseChildNodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingValueTracksTrueChild", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MissingValueTracksTrueChild = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluationInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeEnsemble
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvaluationInfo = append(m.EvaluationInfo, &TreeEnsembleParameters_TreeNode_EvaluationInfo{})
			if err := m.EvaluationInfo[len(m.EvaluationInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeHitRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.RelativeHitRate = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTreeEnsemble(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeEnsemble
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeEnsembleParameters_TreeNode_EvaluationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeEnsemble
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvaluationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvaluationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluationIndex", wireType)
			}
			m.EvaluationIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EvaluationIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluationValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.EvaluationValue = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTreeEnsemble(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeEnsemble
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeEnsembleClassifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeEnsemble
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeEnsembleClassifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeEnsembleClassifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeEnsemble", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeEnsemble
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreeEnsemble == nil {
				m.TreeEnsemble = &TreeEnsembleParameters{}
			}
			if err := m.TreeEnsemble.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostEvaluationTransform", wireType)
			}
			m.PostEvaluationTransform = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostEvaluationTransform |= (TreeEnsemblePostEvaluationTransform(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringClassLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeEnsemble
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringVector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClassLabels = &TreeEnsembleClassifier_StringClassLabels{v}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64ClassLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeEnsemble
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Int64Vector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClassLabels = &TreeEnsembleClassifier_Int64ClassLabels{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreeEnsemble(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeEnsemble
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeEnsembleRegressor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeEnsemble
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeEnsembleRegressor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeEnsembleRegressor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeEnsemble", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeEnsemble
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreeEnsemble == nil {
				m.TreeEnsemble = &TreeEnsembleParameters{}
			}
			if err := m.TreeEnsemble.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostEvaluationTransform", wireType)
			}
			m.PostEvaluationTransform = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostEvaluationTransform |= (TreeEnsemblePostEvaluationTransform(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreeEnsemble(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeEnsemble
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTreeEnsemble(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTreeEnsemble
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTreeEnsemble
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTreeEnsemble
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTreeEnsemble
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTreeEnsemble(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTreeEnsemble = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTreeEnsemble   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("TreeEnsemble.proto", fileDescriptorTreeEnsemble) }

var fileDescriptorTreeEnsemble = []byte{
	// 720 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x55, 0x4f, 0x6f, 0x1a, 0x47,
	0x14, 0x67, 0xc0, 0x46, 0xe8, 0x81, 0xf1, 0x76, 0x6c, 0xe3, 0x2d, 0x6d, 0x11, 0xa5, 0x87, 0x22,
	0xb7, 0x42, 0x16, 0xad, 0x2c, 0x5f, 0x2a, 0xb5, 0xd8, 0xb4, 0x46, 0xc2, 0xd4, 0x5a, 0x23, 0x57,
	0xaa, 0xa2, 0x44, 0xc3, 0xee, 0x03, 0x46, 0x59, 0x76, 0x9c, 0x99, 0xc1, 0xf2, 0xc7, 0xc8, 0x31,
	0x97, 0x7c, 0x99, 0x9c, 0x72, 0x4b, 0x94, 0x6b, 0x2e, 0x91, 0xf3, 0x45, 0xa2, 0x9d, 0x05, 0x9b,
	0x85, 0xb5, 0xe5, 0x6b, 0x6e, 0x3b, 0xbf, 0x7f, 0x6f, 0xde, 0x7b, 0x23, 0x00, 0xda, 0x97, 0x88,
	0xed, 0x40, 0xe1, 0x64, 0xe0, 0x63, 0xe3, 0x52, 0x0a, 0x2d, 0x68, 0xf6, 0x48, 0x48, 0x3c, 0xed,
	0x96, 0xb7, 0x8f, 0x99, 0x66, 0xe7, 0x5a, 0x4e, 0x5d, 0x3d, 0x95, 0xa8, 0x22, 0xb6, 0xf6, 0x2a,
	0x07, 0xa5, 0x45, 0xd3, 0x19, 0x93, 0x6c, 0x82, 0x1a, 0xa5, 0xa2, 0x7f, 0xc0, 0x7a, 0x20, 0x3c,
	0x54, 0x36, 0xa9, 0x66, 0xea, 0xf9, 0xe6, 0xcf, 0x8d, 0x28, 0xa8, 0x91, 0x2c, 0x37, 0x70, 0x4f,
	0x78, 0xe8, 0x44, 0x2e, 0x7a, 0x08, 0xbb, 0xc1, 0x74, 0x72, 0x26, 0xd1, 0xe3, 0xae, 0xe6, 0x22,
	0x38, 0xe6, 0x13, 0x0c, 0x14, 0x17, 0x81, 0xb2, 0xd3, 0x55, 0x52, 0x5f, 0x73, 0xee, 0xa3, 0xe9,
	0x3e, 0x6c, 0x0d, 0x98, 0xc2, 0x3b, 0xee, 0x82, 0xf9, 0x53, 0xb4, 0x33, 0xd5, 0x4c, 0x9d, 0x38,
	0x49, 0x54, 0xf9, 0x43, 0x16, 0x72, 0xf3, 0xfa, 0xb4, 0x04, 0x59, 0x2d, 0x11, 0x3b, 0x9e, 0x4d,
	0x4c, 0x9d, 0xd9, 0x29, 0xc4, 0xc3, 0x9b, 0x75, 0xbc, 0x59, 0xfd, 0xd9, 0x89, 0x3e, 0x81, 0x42,
	0xf8, 0xd5, 0xc2, 0x31, 0xbb, 0xe2, 0x42, 0xda, 0x99, 0x2a, 0xa9, 0x17, 0x9b, 0x87, 0x8f, 0x6c,
	0xf7, 0xf6, 0x63, 0xee, 0x77, 0x62, 0x69, 0xb4, 0x01, 0x74, 0x20, 0x59, 0xe0, 0x8e, 0xff, 0x46,
	0x16, 0x0e, 0xbe, 0x13, 0x78, 0x78, 0x6d, 0x83, 0xb9, 0x41, 0x02, 0xb3, 0xa2, 0x8f, 0x7a, 0xcf,
	0x57, 0x49, 0x9d, 0x38, 0x09, 0x0c, 0xad, 0xc3, 0xa6, 0x96, 0x53, 0x3c, 0x1a, 0x73, 0xdf, 0xeb,
	0x45, 0xed, 0x15, 0x4c, 0xf8, 0x32, 0x4c, 0xf7, 0xc0, 0x1a, 0x32, 0x5f, 0xc5, 0xa4, 0x1b, 0x46,
	0xba, 0x82, 0xd3, 0x3f, 0xe1, 0xbb, 0x09, 0x57, 0x8a, 0x07, 0x23, 0x53, 0xa5, 0x2f, 0x99, 0xfb,
	0x5c, 0xf5, 0xe7, 0x81, 0x76, 0xb1, 0x4a, 0xea, 0x39, 0xe7, 0x21, 0x09, 0x7d, 0x0a, 0x45, 0xbc,
	0x62, 0xfe, 0x94, 0x85, 0x5b, 0xea, 0x04, 0x43, 0x61, 0x6f, 0x9b, 0x67, 0x74, 0xf0, 0xd8, 0xb9,
	0xb6, 0x63, 0x6e, 0x67, 0x29, 0x2d, 0xec, 0x5b, 0xa2, 0xcf, 0x34, 0xbf, 0xc2, 0x13, 0xae, 0x1d,
	0xa6, 0xd1, 0xae, 0x98, 0x21, 0x2d, 0xc3, 0x65, 0x0f, 0x8a, 0xed, 0x15, 0xef, 0x62, 0x5a, 0xb8,
	0x90, 0xe8, 0xa9, 0x2c, 0xc3, 0x71, 0x65, 0xb4, 0x8a, 0x74, 0x54, 0x65, 0x09, 0xae, 0xbd, 0x23,
	0x60, 0x2d, 0x3f, 0x05, 0x5a, 0x81, 0x72, 0xcb, 0xac, 0xec, 0xdf, 0x48, 0xd5, 0x45, 0xa5, 0xfa,
	0x63, 0x16, 0xb4, 0x5f, 0x4c, 0x99, 0x6f, 0xa5, 0xe8, 0xb7, 0xb0, 0x93, 0xc8, 0x5b, 0x84, 0xfe,
	0x08, 0x3f, 0xc4, 0xa8, 0x7f, 0x24, 0x32, 0x8d, 0xf2, 0xce, 0x9d, 0xa6, 0xdf, 0x83, 0x7d, 0x9f,
	0xc4, 0xca, 0xd0, 0x12, 0xd0, 0x18, 0x1b, 0xb9, 0xd6, 0x56, 0x6a, 0xf6, 0x84, 0x8e, 0xa8, 0x75,
	0x5a, 0x80, 0x5c, 0x17, 0xd9, 0x30, 0x6c, 0xc1, 0xca, 0xd6, 0x3e, 0xa6, 0xe3, 0x3f, 0x0d, 0x47,
	0x3e, 0x53, 0x8a, 0x0f, 0x39, 0x4a, 0xda, 0x82, 0x82, 0x5e, 0x60, 0xcc, 0xf4, 0xf2, 0xcd, 0xca,
	0xc3, 0xab, 0x75, 0x62, 0x1e, 0x8a, 0xb0, 0x7b, 0x29, 0x94, 0xbe, 0x5b, 0x4d, 0x5f, 0xb2, 0x40,
	0x0d, 0x85, 0x9c, 0x98, 0x11, 0x17, 0x9b, 0xbf, 0x24, 0xc6, 0x25, 0x5b, 0x9c, 0xfb, 0xb2, 0xe8,
	0x31, 0x7c, 0xa3, 0xb4, 0xe4, 0xc1, 0xc8, 0x5c, 0xbf, 0xcb, 0x06, 0xe8, 0x2b, 0xdb, 0x33, 0xf7,
	0xdd, 0x9e, 0x17, 0x38, 0x37, 0x82, 0x0b, 0x74, 0xb5, 0x90, 0x27, 0x29, 0x67, 0xd5, 0x40, 0xff,
	0x02, 0x8b, 0x07, 0xfa, 0xe0, 0xf7, 0xc5, 0x10, 0x34, 0x21, 0x5b, 0xf3, 0x90, 0x4e, 0xc8, 0xdf,
	0x66, 0xac, 0xc8, 0x5b, 0x1b, 0x90, 0x5f, 0x38, 0xd6, 0xde, 0x10, 0xd8, 0x59, 0x6c, 0xcc, 0xc1,
	0x91, 0x44, 0xa5, 0xc4, 0xd7, 0x34, 0xdc, 0xbd, 0xd7, 0x04, 0x7e, 0x7a, 0x44, 0x00, 0xdd, 0x84,
	0x7c, 0x4f, 0xdc, 0x1e, 0xad, 0x14, 0x2d, 0x43, 0x69, 0xfe, 0x9c, 0x5c, 0xa3, 0x7d, 0x76, 0x2e,
	0x86, 0xfa, 0x94, 0x5d, 0x5b, 0x84, 0xee, 0xc2, 0xd6, 0x6c, 0x18, 0x21, 0xde, 0x15, 0x23, 0xae,
	0x34, 0x77, 0xad, 0x34, 0xdd, 0x87, 0x5f, 0x93, 0x4d, 0xff, 0x71, 0x3d, 0xfe, 0x1f, 0xa5, 0x30,
	0xac, 0x83, 0x43, 0x94, 0x18, 0xb8, 0x68, 0x65, 0x5a, 0xf4, 0xed, 0x4d, 0x85, 0xbc, 0xbf, 0xa9,
	0x90, 0x4f, 0x37, 0x15, 0xf2, 0xf2, 0x73, 0x25, 0x75, 0x92, 0x39, 0x4b, 0x0d, 0xb2, 0xe6, 0xaf,
	0xef, 0xb7, 0x2f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf8, 0x28, 0x4d, 0xfa, 0x2e, 0x07, 0x00, 0x00,
}
