// Code generated by protoc-gen-gogo.
// source: Imputer.proto
// DO NOT EDIT!

package CoreML

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Ignoring public import of StringToInt64Map from DataStructures.proto

// Ignoring public import of Int64ToStringMap from DataStructures.proto

// Ignoring public import of StringToDoubleMap from DataStructures.proto

// Ignoring public import of Int64ToDoubleMap from DataStructures.proto

// Ignoring public import of StringVector from DataStructures.proto

// Ignoring public import of Int64Vector from DataStructures.proto

// Ignoring public import of DoubleVector from DataStructures.proto

// *
// A transformer that replaces missing values with a default value,
// such as a statistically-derived value.
//
// If ``ReplaceValue`` is set, then missing values of that type are
// replaced with the corresponding value.
//
// For example: if ``replaceDoubleValue`` is set to ``NaN``
// and a single ``NaN`` double value is provided as input,
// then it is replaced by ``imputedDoubleValue``. However
// if the input is an array of doubles, then any instances
// of ``NaN`` in the array is replaced with the corresponding
// value in ``imputedDoubleArray``.
type Imputer struct {
	// Types that are valid to be assigned to ImputedValue:
	//	*Imputer_ImputedDoubleValue
	//	*Imputer_ImputedInt64Value
	//	*Imputer_ImputedStringValue
	//	*Imputer_ImputedDoubleArray
	//	*Imputer_ImputedInt64Array
	//	*Imputer_ImputedStringDictionary
	//	*Imputer_ImputedInt64Dictionary
	ImputedValue isImputer_ImputedValue `protobuf_oneof:"ImputedValue"`
	// Types that are valid to be assigned to ReplaceValue:
	//	*Imputer_ReplaceDoubleValue
	//	*Imputer_ReplaceInt64Value
	//	*Imputer_ReplaceStringValue
	ReplaceValue isImputer_ReplaceValue `protobuf_oneof:"ReplaceValue"`
}

func (m *Imputer) Reset()                    { *m = Imputer{} }
func (m *Imputer) String() string            { return proto.CompactTextString(m) }
func (*Imputer) ProtoMessage()               {}
func (*Imputer) Descriptor() ([]byte, []int) { return fileDescriptorImputer, []int{0} }

type isImputer_ImputedValue interface {
	isImputer_ImputedValue()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isImputer_ReplaceValue interface {
	isImputer_ReplaceValue()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Imputer_ImputedDoubleValue struct {
	ImputedDoubleValue float64 `protobuf:"fixed64,1,opt,name=imputedDoubleValue,proto3,oneof"`
}
type Imputer_ImputedInt64Value struct {
	ImputedInt64Value int64 `protobuf:"varint,2,opt,name=imputedInt64Value,proto3,oneof"`
}
type Imputer_ImputedStringValue struct {
	ImputedStringValue string `protobuf:"bytes,3,opt,name=imputedStringValue,proto3,oneof"`
}
type Imputer_ImputedDoubleArray struct {
	ImputedDoubleArray *DoubleVector `protobuf:"bytes,4,opt,name=imputedDoubleArray,oneof"`
}
type Imputer_ImputedInt64Array struct {
	ImputedInt64Array *Int64Vector `protobuf:"bytes,5,opt,name=imputedInt64Array,oneof"`
}
type Imputer_ImputedStringDictionary struct {
	ImputedStringDictionary *StringToDoubleMap `protobuf:"bytes,6,opt,name=imputedStringDictionary,oneof"`
}
type Imputer_ImputedInt64Dictionary struct {
	ImputedInt64Dictionary *Int64ToDoubleMap `protobuf:"bytes,7,opt,name=imputedInt64Dictionary,oneof"`
}
type Imputer_ReplaceDoubleValue struct {
	ReplaceDoubleValue float64 `protobuf:"fixed64,11,opt,name=replaceDoubleValue,proto3,oneof"`
}
type Imputer_ReplaceInt64Value struct {
	ReplaceInt64Value int64 `protobuf:"varint,12,opt,name=replaceInt64Value,proto3,oneof"`
}
type Imputer_ReplaceStringValue struct {
	ReplaceStringValue string `protobuf:"bytes,13,opt,name=replaceStringValue,proto3,oneof"`
}

func (*Imputer_ImputedDoubleValue) isImputer_ImputedValue()      {}
func (*Imputer_ImputedInt64Value) isImputer_ImputedValue()       {}
func (*Imputer_ImputedStringValue) isImputer_ImputedValue()      {}
func (*Imputer_ImputedDoubleArray) isImputer_ImputedValue()      {}
func (*Imputer_ImputedInt64Array) isImputer_ImputedValue()       {}
func (*Imputer_ImputedStringDictionary) isImputer_ImputedValue() {}
func (*Imputer_ImputedInt64Dictionary) isImputer_ImputedValue()  {}
func (*Imputer_ReplaceDoubleValue) isImputer_ReplaceValue()      {}
func (*Imputer_ReplaceInt64Value) isImputer_ReplaceValue()       {}
func (*Imputer_ReplaceStringValue) isImputer_ReplaceValue()      {}

func (m *Imputer) GetImputedValue() isImputer_ImputedValue {
	if m != nil {
		return m.ImputedValue
	}
	return nil
}
func (m *Imputer) GetReplaceValue() isImputer_ReplaceValue {
	if m != nil {
		return m.ReplaceValue
	}
	return nil
}

func (m *Imputer) GetImputedDoubleValue() float64 {
	if x, ok := m.GetImputedValue().(*Imputer_ImputedDoubleValue); ok {
		return x.ImputedDoubleValue
	}
	return 0
}

func (m *Imputer) GetImputedInt64Value() int64 {
	if x, ok := m.GetImputedValue().(*Imputer_ImputedInt64Value); ok {
		return x.ImputedInt64Value
	}
	return 0
}

func (m *Imputer) GetImputedStringValue() string {
	if x, ok := m.GetImputedValue().(*Imputer_ImputedStringValue); ok {
		return x.ImputedStringValue
	}
	return ""
}

func (m *Imputer) GetImputedDoubleArray() *DoubleVector {
	if x, ok := m.GetImputedValue().(*Imputer_ImputedDoubleArray); ok {
		return x.ImputedDoubleArray
	}
	return nil
}

func (m *Imputer) GetImputedInt64Array() *Int64Vector {
	if x, ok := m.GetImputedValue().(*Imputer_ImputedInt64Array); ok {
		return x.ImputedInt64Array
	}
	return nil
}

func (m *Imputer) GetImputedStringDictionary() *StringToDoubleMap {
	if x, ok := m.GetImputedValue().(*Imputer_ImputedStringDictionary); ok {
		return x.ImputedStringDictionary
	}
	return nil
}

func (m *Imputer) GetImputedInt64Dictionary() *Int64ToDoubleMap {
	if x, ok := m.GetImputedValue().(*Imputer_ImputedInt64Dictionary); ok {
		return x.ImputedInt64Dictionary
	}
	return nil
}

func (m *Imputer) GetReplaceDoubleValue() float64 {
	if x, ok := m.GetReplaceValue().(*Imputer_ReplaceDoubleValue); ok {
		return x.ReplaceDoubleValue
	}
	return 0
}

func (m *Imputer) GetReplaceInt64Value() int64 {
	if x, ok := m.GetReplaceValue().(*Imputer_ReplaceInt64Value); ok {
		return x.ReplaceInt64Value
	}
	return 0
}

func (m *Imputer) GetReplaceStringValue() string {
	if x, ok := m.GetReplaceValue().(*Imputer_ReplaceStringValue); ok {
		return x.ReplaceStringValue
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Imputer) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Imputer_OneofMarshaler, _Imputer_OneofUnmarshaler, _Imputer_OneofSizer, []interface{}{
		(*Imputer_ImputedDoubleValue)(nil),
		(*Imputer_ImputedInt64Value)(nil),
		(*Imputer_ImputedStringValue)(nil),
		(*Imputer_ImputedDoubleArray)(nil),
		(*Imputer_ImputedInt64Array)(nil),
		(*Imputer_ImputedStringDictionary)(nil),
		(*Imputer_ImputedInt64Dictionary)(nil),
		(*Imputer_ReplaceDoubleValue)(nil),
		(*Imputer_ReplaceInt64Value)(nil),
		(*Imputer_ReplaceStringValue)(nil),
	}
}

func _Imputer_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Imputer)
	// ImputedValue
	switch x := m.ImputedValue.(type) {
	case *Imputer_ImputedDoubleValue:
		_ = b.EncodeVarint(1<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(math.Float64bits(x.ImputedDoubleValue))
	case *Imputer_ImputedInt64Value:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.ImputedInt64Value))
	case *Imputer_ImputedStringValue:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ImputedStringValue)
	case *Imputer_ImputedDoubleArray:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImputedDoubleArray); err != nil {
			return err
		}
	case *Imputer_ImputedInt64Array:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImputedInt64Array); err != nil {
			return err
		}
	case *Imputer_ImputedStringDictionary:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImputedStringDictionary); err != nil {
			return err
		}
	case *Imputer_ImputedInt64Dictionary:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ImputedInt64Dictionary); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Imputer.ImputedValue has unexpected type %T", x)
	}
	// ReplaceValue
	switch x := m.ReplaceValue.(type) {
	case *Imputer_ReplaceDoubleValue:
		_ = b.EncodeVarint(11<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(math.Float64bits(x.ReplaceDoubleValue))
	case *Imputer_ReplaceInt64Value:
		_ = b.EncodeVarint(12<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.ReplaceInt64Value))
	case *Imputer_ReplaceStringValue:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ReplaceStringValue)
	case nil:
	default:
		return fmt.Errorf("Imputer.ReplaceValue has unexpected type %T", x)
	}
	return nil
}

func _Imputer_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Imputer)
	switch tag {
	case 1: // ImputedValue.imputedDoubleValue
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.ImputedValue = &Imputer_ImputedDoubleValue{math.Float64frombits(x)}
		return true, err
	case 2: // ImputedValue.imputedInt64Value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ImputedValue = &Imputer_ImputedInt64Value{int64(x)}
		return true, err
	case 3: // ImputedValue.imputedStringValue
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ImputedValue = &Imputer_ImputedStringValue{x}
		return true, err
	case 4: // ImputedValue.imputedDoubleArray
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DoubleVector)
		err := b.DecodeMessage(msg)
		m.ImputedValue = &Imputer_ImputedDoubleArray{msg}
		return true, err
	case 5: // ImputedValue.imputedInt64Array
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Int64Vector)
		err := b.DecodeMessage(msg)
		m.ImputedValue = &Imputer_ImputedInt64Array{msg}
		return true, err
	case 6: // ImputedValue.imputedStringDictionary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringToDoubleMap)
		err := b.DecodeMessage(msg)
		m.ImputedValue = &Imputer_ImputedStringDictionary{msg}
		return true, err
	case 7: // ImputedValue.imputedInt64Dictionary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Int64ToDoubleMap)
		err := b.DecodeMessage(msg)
		m.ImputedValue = &Imputer_ImputedInt64Dictionary{msg}
		return true, err
	case 11: // ReplaceValue.replaceDoubleValue
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.ReplaceValue = &Imputer_ReplaceDoubleValue{math.Float64frombits(x)}
		return true, err
	case 12: // ReplaceValue.replaceInt64Value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ReplaceValue = &Imputer_ReplaceInt64Value{int64(x)}
		return true, err
	case 13: // ReplaceValue.replaceStringValue
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ReplaceValue = &Imputer_ReplaceStringValue{x}
		return true, err
	default:
		return false, nil
	}
}

func _Imputer_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Imputer)
	// ImputedValue
	switch x := m.ImputedValue.(type) {
	case *Imputer_ImputedDoubleValue:
		n += proto.SizeVarint(1<<3 | proto.WireFixed64)
		n += 8
	case *Imputer_ImputedInt64Value:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ImputedInt64Value))
	case *Imputer_ImputedStringValue:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ImputedStringValue)))
		n += len(x.ImputedStringValue)
	case *Imputer_ImputedDoubleArray:
		s := proto.Size(x.ImputedDoubleArray)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Imputer_ImputedInt64Array:
		s := proto.Size(x.ImputedInt64Array)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Imputer_ImputedStringDictionary:
		s := proto.Size(x.ImputedStringDictionary)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Imputer_ImputedInt64Dictionary:
		s := proto.Size(x.ImputedInt64Dictionary)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// ReplaceValue
	switch x := m.ReplaceValue.(type) {
	case *Imputer_ReplaceDoubleValue:
		n += proto.SizeVarint(11<<3 | proto.WireFixed64)
		n += 8
	case *Imputer_ReplaceInt64Value:
		n += proto.SizeVarint(12<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ReplaceInt64Value))
	case *Imputer_ReplaceStringValue:
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ReplaceStringValue)))
		n += len(x.ReplaceStringValue)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Imputer)(nil), "CoreML.Imputer")
}
func (m *Imputer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Imputer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ImputedValue != nil {
		nn1, err := m.ImputedValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.ReplaceValue != nil {
		nn2, err := m.ReplaceValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *Imputer_ImputedDoubleValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Imputer(dAtA, i, uint64(math.Float64bits(float64(m.ImputedDoubleValue))))
	return i, nil
}
func (m *Imputer_ImputedInt64Value) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintImputer(dAtA, i, uint64(m.ImputedInt64Value))
	return i, nil
}
func (m *Imputer_ImputedStringValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintImputer(dAtA, i, uint64(len(m.ImputedStringValue)))
	i += copy(dAtA[i:], m.ImputedStringValue)
	return i, nil
}
func (m *Imputer_ImputedDoubleArray) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ImputedDoubleArray != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImputer(dAtA, i, uint64(m.ImputedDoubleArray.Size()))
		n3, err := m.ImputedDoubleArray.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Imputer_ImputedInt64Array) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ImputedInt64Array != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImputer(dAtA, i, uint64(m.ImputedInt64Array.Size()))
		n4, err := m.ImputedInt64Array.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Imputer_ImputedStringDictionary) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ImputedStringDictionary != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImputer(dAtA, i, uint64(m.ImputedStringDictionary.Size()))
		n5, err := m.ImputedStringDictionary.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Imputer_ImputedInt64Dictionary) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ImputedInt64Dictionary != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImputer(dAtA, i, uint64(m.ImputedInt64Dictionary.Size()))
		n6, err := m.ImputedInt64Dictionary.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Imputer_ReplaceDoubleValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x59
	i++
	i = encodeFixed64Imputer(dAtA, i, uint64(math.Float64bits(float64(m.ReplaceDoubleValue))))
	return i, nil
}
func (m *Imputer_ReplaceInt64Value) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x60
	i++
	i = encodeVarintImputer(dAtA, i, uint64(m.ReplaceInt64Value))
	return i, nil
}
func (m *Imputer_ReplaceStringValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x6a
	i++
	i = encodeVarintImputer(dAtA, i, uint64(len(m.ReplaceStringValue)))
	i += copy(dAtA[i:], m.ReplaceStringValue)
	return i, nil
}
func encodeFixed64Imputer(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Imputer(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintImputer(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Imputer) Size() (n int) {
	var l int
	_ = l
	if m.ImputedValue != nil {
		n += m.ImputedValue.Size()
	}
	if m.ReplaceValue != nil {
		n += m.ReplaceValue.Size()
	}
	return n
}

func (m *Imputer_ImputedDoubleValue) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *Imputer_ImputedInt64Value) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovImputer(uint64(m.ImputedInt64Value))
	return n
}
func (m *Imputer_ImputedStringValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.ImputedStringValue)
	n += 1 + l + sovImputer(uint64(l))
	return n
}
func (m *Imputer_ImputedDoubleArray) Size() (n int) {
	var l int
	_ = l
	if m.ImputedDoubleArray != nil {
		l = m.ImputedDoubleArray.Size()
		n += 1 + l + sovImputer(uint64(l))
	}
	return n
}
func (m *Imputer_ImputedInt64Array) Size() (n int) {
	var l int
	_ = l
	if m.ImputedInt64Array != nil {
		l = m.ImputedInt64Array.Size()
		n += 1 + l + sovImputer(uint64(l))
	}
	return n
}
func (m *Imputer_ImputedStringDictionary) Size() (n int) {
	var l int
	_ = l
	if m.ImputedStringDictionary != nil {
		l = m.ImputedStringDictionary.Size()
		n += 1 + l + sovImputer(uint64(l))
	}
	return n
}
func (m *Imputer_ImputedInt64Dictionary) Size() (n int) {
	var l int
	_ = l
	if m.ImputedInt64Dictionary != nil {
		l = m.ImputedInt64Dictionary.Size()
		n += 1 + l + sovImputer(uint64(l))
	}
	return n
}
func (m *Imputer_ReplaceDoubleValue) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *Imputer_ReplaceInt64Value) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovImputer(uint64(m.ReplaceInt64Value))
	return n
}
func (m *Imputer_ReplaceStringValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.ReplaceStringValue)
	n += 1 + l + sovImputer(uint64(l))
	return n
}

func sovImputer(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImputer(x uint64) (n int) {
	return sovImputer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Imputer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImputer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Imputer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Imputer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImputedDoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ImputedValue = &Imputer_ImputedDoubleValue{float64(math.Float64frombits(v))}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImputedInt64Value", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImputer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImputedValue = &Imputer_ImputedInt64Value{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImputedStringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImputer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImputer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImputedValue = &Imputer_ImputedStringValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImputedDoubleArray", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImputer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImputer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DoubleVector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ImputedValue = &Imputer_ImputedDoubleArray{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImputedInt64Array", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImputer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImputer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Int64Vector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ImputedValue = &Imputer_ImputedInt64Array{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImputedStringDictionary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImputer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImputer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringToDoubleMap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ImputedValue = &Imputer_ImputedStringDictionary{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImputedInt64Dictionary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImputer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImputer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Int64ToDoubleMap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ImputedValue = &Imputer_ImputedInt64Dictionary{v}
			iNdEx = postIndex
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceDoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ReplaceValue = &Imputer_ReplaceDoubleValue{float64(math.Float64frombits(v))}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceInt64Value", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImputer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplaceValue = &Imputer_ReplaceInt64Value{v}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceStringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImputer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImputer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplaceValue = &Imputer_ReplaceStringValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImputer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImputer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImputer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImputer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImputer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImputer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImputer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImputer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImputer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImputer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImputer   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("Imputer.proto", fileDescriptorImputer) }

var fileDescriptorImputer = []byte{
	// 335 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x52, 0x4f, 0x4f, 0xbb, 0x30,
	0x18, 0xa6, 0x3f, 0x7e, 0x63, 0xb1, 0xdb, 0x4c, 0xac, 0x8b, 0xa2, 0x07, 0x42, 0x3c, 0x71, 0x22,
	0x46, 0x8d, 0x77, 0x1d, 0x31, 0x2c, 0x71, 0x89, 0xe9, 0xd4, 0x7b, 0xc7, 0x1a, 0x43, 0x82, 0x94,
	0xd4, 0x72, 0xd8, 0x47, 0xf0, 0xe6, 0xc7, 0xf2, 0xe8, 0x47, 0x30, 0xf8, 0x45, 0xcc, 0xfa, 0x82,
	0x16, 0xd9, 0x6e, 0xb4, 0xcf, 0xfb, 0xfc, 0xa1, 0xcf, 0x8b, 0x47, 0xd3, 0xe7, 0xa2, 0x54, 0x5c,
	0x86, 0x85, 0x14, 0x4a, 0x10, 0x67, 0x22, 0x24, 0x9f, 0xdd, 0x1e, 0x8f, 0x23, 0xa6, 0xd8, 0x5c,
	0xc9, 0x32, 0x51, 0xa5, 0xe4, 0x2f, 0x80, 0x9e, 0xbc, 0xf6, 0x70, 0xbf, 0x9e, 0x27, 0xa7, 0x98,
	0xa4, 0xfa, 0x73, 0x19, 0x89, 0x72, 0x91, 0xf1, 0x47, 0x96, 0x95, 0xdc, 0x45, 0x3e, 0x0a, 0x50,
	0x6c, 0xd1, 0x0d, 0x18, 0x09, 0xf1, 0x5e, 0x7d, 0x3b, 0xcd, 0xd5, 0xe5, 0x05, 0x10, 0xfe, 0xf9,
	0x28, 0xb0, 0x63, 0x8b, 0x76, 0x21, 0xc3, 0x61, 0xae, 0x64, 0x9a, 0x3f, 0x01, 0xc1, 0xf6, 0x51,
	0xb0, 0x63, 0x38, 0x18, 0x18, 0xb9, 0xf9, 0x93, 0xe9, 0x4a, 0x4a, 0xb6, 0x72, 0xff, 0xfb, 0x28,
	0x18, 0x9c, 0x8d, 0x43, 0xf8, 0xb5, 0xb0, 0x8e, 0xc4, 0x13, 0x25, 0x64, 0x27, 0xa9, 0x66, 0x90,
	0x49, 0x3b, 0x29, 0xc8, 0xf4, 0xb4, 0xcc, 0x7e, 0x23, 0x03, 0x41, 0x1b, 0x95, 0xee, 0x3c, 0x79,
	0xc0, 0x87, 0xad, 0x88, 0x51, 0x9a, 0xa8, 0x54, 0xe4, 0x4c, 0xae, 0x5c, 0x47, 0x4b, 0x1d, 0x35,
	0x52, 0x80, 0xdf, 0x0b, 0x88, 0x30, 0x63, 0x45, 0x6c, 0xd1, 0x6d, 0x5c, 0x42, 0xf1, 0x81, 0xe9,
	0x65, 0xa8, 0xf6, 0xb5, 0xaa, 0xdb, 0x0a, 0xd8, 0x16, 0xdd, 0xc2, 0x5c, 0xbf, 0xb4, 0xe4, 0x45,
	0xc6, 0x12, 0x6e, 0x76, 0x39, 0xd0, 0x5d, 0x22, 0xba, 0x01, 0x5b, 0x77, 0x59, 0xdf, 0x1a, 0x5d,
	0x0e, 0x75, 0x97, 0x88, 0x76, 0x21, 0xc3, 0xc1, 0xec, 0x72, 0xa4, 0xbb, 0xfc, 0x75, 0x30, 0xb0,
	0xeb, 0x5d, 0x3c, 0x84, 0x55, 0x5b, 0xfe, 0x9c, 0x29, 0x4c, 0xc1, 0x99, 0xbc, 0x57, 0x1e, 0xfa,
	0xa8, 0x3c, 0xf4, 0x59, 0x79, 0xe8, 0xed, 0xcb, 0xb3, 0x62, 0xfb, 0xce, 0x5a, 0x38, 0x7a, 0x51,
	0xcf, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x57, 0x93, 0x15, 0xc2, 0xd7, 0x02, 0x00, 0x00,
}
